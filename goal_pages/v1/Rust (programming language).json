{"title": "Rust (programming language)", "key": "Rust_(programming_language)", "summary": "{{Short description|General-purpose programming language}}\n{{Good article}}\n{{Use American English|date=July 2022}}\n{{Use mdy dates|date=July 2022|cs1-dates=y}}\n{{Infobox programming language\n| name = Rust\n| logo = Rust programming language black logo.svg\n| logo alt = Rust logo; a capital letter R set into a sprocket\n| paradigms = {{cslist|\n  [[Concurrent computing|Concurrent]]|\n  [[Functional programming|functional]]|\n  [[Generic programming|generic]]|\n  [[Imperative programming|imperative]]|\n  [[Structured programming|structured]]|\n}}\n| released = {{Start date and age|2015|05|15}}\n| developer = [[Rust Foundation]]\n| latest release version = {{wikidata|property|edit|reference|P548=Q2804309|P348}}\n| latest release date = {{start date and age|{{wikidata|qualifier|mdy|P548=Q2804309|P348|P577}}}}\n| typing = {{cslist|\n  [[Affine type system|Affine]]|\n  [[Type inference|inferred]]|\n  [[Nominal type system|nominal]]|\n  [[Static typing|static]]|\n  [[Strong and weak typing|strong]]|\n}}\n| programming language = Rust\n| platform = [[Cross-platform software|Cross-platform]]{{refn|group=note|Including build tools, host tools, and standard library support for [[x86-64]], [[ARM architecture family|ARM]], [[MIPS architecture|MIPS]], [[RISC-V]], [[WebAssembly]], [[P6 (microarchitecture)|i686]], [[AArch64]], [[PowerPC]], and [[Linux on IBM Z|s390x]].<ref name=CrossPlatform>{{Cite web |title=Platform Support |website=The rustc book |url=https://doc.rust-lang.org/rustc/platform-support.html |access-date=2022-06-27}}</ref>}}\n| operating system = [[Cross-platform software|Cross-platform]]{{refn|group=note|Including [[Windows]], [[Linux]], [[macOS]], [[FreeBSD]], [[NetBSD]], and [[Illumos]]. Host build tools on [[Android (operating system)|Android]], [[iOS]], [[Haiku (operating system)|Haiku]], [[Redox (operating system)|Redox]], and [[Fuchsia (operating system)|Fuchsia]] are not officially shipped; these operating systems are supported as targets.<ref name=\"CrossPlatform\" />}}\n| license = [[MIT License|MIT]] and [[Apache License|Apache 2.0]]{{refn|group=note|Third-party dependencies, e.g., [[LLVM]] or [[MSVC]], are subject to their own licenses.<ref>{{cite web |title=The Rust Programming Language |url=https://github.com/rust-lang/rust/blob/master/COPYRIGHT |publisher=The Rust Programming Language |date=19 October 2022}}</ref><ref name=\"legal\" />}}\n| file ext = <code>.rs</code>, <code>.rlib</code>\n| influenced by = {{cslist|\n  [[Alef (programming language)|Alef]]<ref name=\"influences\" />|\n  [[C Sharp (programming language)|C#]]<ref name=\"influences\" />|\n  [[C++]]<ref name=\"influences\" />|\n  [[Cyclone (programming language)|Cyclone]]<ref name=\"influences\" />|\n  [[Elm (programming language)|Elm]]<ref>{{Cite web |title=Uniqueness Types |url=https://blog.rust-lang.org/2016/08/10/Shape-of-errors-to-come.html |access-date=2016-10-08 |website= Rust Blog |quote=\"Those of you familiar with the Elm style may recognize that the updated {{mono|--explain}} messages draw heavy inspiration from the Elm approach.\"}}</ref>|\n  [[Erlang (programming language)|Erlang]]<ref name=\"influences\" />|\n  [[Haskell]]<ref name=\"influences\" />|\n  [[Limbo (programming language)|Limbo]]<ref name=\"influences\" />|\n  [[Newsqueak]]<ref name=\"influences\" />|\n  [[OCaml]]<ref name=\"influences\" />|\n  [[Ruby (programming language)|Ruby]]<ref name=\"influences\" />|\n  [[Scheme (programming language)|Scheme]]<ref name=\"influences\" />|\n  [[Standard ML]]<ref name=\"influences\" />|\n  [[Swift (programming language)|Swift]]<ref name=\"influences\" />\n}}\n| influenced = {{cslist|\n  [[Idris (programming language)|Idris]]<ref>{{Cite web |title=Uniqueness Types |url=http://docs.idris-lang.org/en/latest/reference/uniqueness-types.html |access-date=2022-07-14 |website=Idris 1.3.3 documentation |quote=\"They are inspired by ... ownership types and borrowed pointers in the Rust programming language.\"}}</ref>|\n  <!-- The article was deleted -- can be reinstated in the future if the article topic is deemed notable\n  [[Mojo (programming language)|Mojo]]<ref>{{Cite web |last=Claburn |first=Thomas |title=Modular reveals Mojo, Python superset with C-level speed |url=https://www.theregister.com/2023/05/05/modular_struts_its_mojo_a/ |access-date=2023-05-13 |website=The Register |language=en}}</ref>|\n  -->\n  [[Project Verona]]<ref name=\"Project Verona\" />|\n  [[SPARK (programming language)|Spark]]<ref name=\"Jaloyan\" />|\n  [[Swift (programming language)|Swift]]<ref name=\"Lattner\" />|\n  [[V (programming language)|V]]<ref>{{Cite web |title=V documentation (Introduction) |url=https://github.com/vlang/v/blob/master/doc/docs.md#introduction |access-date=2023-11-04|website=GitHub |language=en}}</ref>|\n  [[Zig (programming language)|Zig]]<ref>{{Cite web |last=Yegulalp |first=Serdar |date=2016-08-29 |title=New challenger joins Rust to topple C language |url=https://www.infoworld.com/article/3113083/new-challenger-joins-rust-to-upend-c-language.html |access-date=2022-10-19 |website=InfoWorld |language=en}}</ref>|\n}}\n}}\n\n'''Rust''' is a [[Programming paradigm|multi-paradigm]], [[general-purpose programming language]] that emphasizes [[computer performance|performance]], [[type safety]], and [[Concurrency (computer science)|concurrency]]. It enforces [[memory safety]]\u2014meaning that all [[reference (computer science)|references]] point to valid memory\u2014without a [[garbage collection (computer science)|garbage collector]]. To simultaneously enforce memory safety and prevent [[data race]]s, its \"borrow checker\" tracks the [[object lifetime]] of all references in a program during [[Compilation (computing)|compilation]]. Rust was influenced by ideas from [[functional programming]], including [[Immutable object|immutability]], [[higher-order function]]s, and [[algebraic data type]]s. It is popular for [[systems programming]].<ref>{{Cite book |last=Eshwarla |first=Prabhu |url=https://books.google.com/books?id=eEUREAAAQBAJ |title=Practical System Programming for Rust Developers: Build fast and secure software for Linux/Unix systems with the help of practical examples |date=2020-12-24 |publisher=Packt Publishing Ltd |isbn=978-1-80056-201-1 |language=en}}</ref><ref>{{Cite book |last1=Blandy |first1=Jim |url=https://books.google.com/books?id=h8c_DwAAQBAJ |title=Programming Rust: Fast, Safe Systems Development |last2=Orendorff |first2=Jason |date=2017-11-21 |publisher=O'Reilly Media, Inc. |isbn=978-1-4919-2725-0 |language=en}}</ref><ref>{{Cite journal |last1=Blanco-Cuaresma |first1=Sergi |last2=Bolmont |first2=Emeline |date=2017-05-30 |title=What can the programming language Rust do for astrophysics? |url=https://www.cambridge.org/core/journals/proceedings-of-the-international-astronomical-union/article/what-can-the-programming-language-rust-do-for-astrophysics/B51B6DF72B7641F2352C05A502F3D881 |journal=Proceedings of the International Astronomical Union |language=en |volume=12 |issue=S325 |pages=341\u2013344 |doi=10.1017/S1743921316013168 |arxiv=1702.02951 |bibcode=2017IAUS..325..341B |s2cid=7857871 |issn=1743-9213}}</ref>\n\nSoftware developer Graydon Hoare created Rust as a personal project while working at [[Mozilla]] Research in 2006. Mozilla officially sponsored the project in 2009. In the years following the first stable release in May 2015, Rust was adopted by companies including [[Amazon (company)|Amazon]], [[Discord]], [[Dropbox]], [[Google]] ([[Alphabet Inc.|Alphabet]]), [[Meta Platforms|Meta]], and [[Microsoft]]. In December 2022, it became the first language other than [[C (programming language)|C]] and [[Assembly language|assembly]] to be supported in the development of the [[Linux kernel]].\n\nRust has been noted for its rapid adoption,<ref name=\"Nature\">{{Cite journal |last=Perkel |first=Jeffrey M. |date=2020-12-01 |title=Why scientists are turning to Rust |url=https://www.nature.com/articles/d41586-020-03382-2 |journal=[[Nature (journal)|Nature]] |language=en |volume=588 |issue=7836 |pages=185\u2013186 |doi=10.1038/d41586-020-03382-2 |pmid=33262490 |bibcode=2020Natur.588..185P |s2cid=227251258 |access-date=May 15, 2022 |archive-date=May 6, 2022 |archive-url=https://web.archive.org/web/20220506040523/https://www.nature.com/articles/d41586-020-03382-2 |url-status=live}}</ref> and has been studied in [[programming language theory]] research.<ref>{{Cite web |title=Computer Scientist proves safety claims of the programming language Rust |url=https://www.eurekalert.org/news-releases/610682 |access-date=2022-05-15 |website=EurekAlert! |language=en |archive-date=February 24, 2022 |archive-url=https://web.archive.org/web/20220224160140/https://www.eurekalert.org/news-releases/610682 |url-status=live}}</ref><ref>{{Cite journal |last1=Jung |first1=Ralf |last2=Jourdan |first2=Jacques-Henri |last3=Krebbers |first3=Robbert |last4=Dreyer |first4=Derek |date=2017-12-27 |title=RustBelt: securing the foundations of the Rust programming language |url=https://doi.org/10.1145/3158154 |journal=Proceedings of the ACM on Programming Languages |volume=2 |issue=POPL |pages=66:1\u201366:34 |doi=10.1145/3158154 |s2cid=215791659 |access-date=May 15, 2022 |archive-date=June 11, 2022 |archive-url=https://web.archive.org/web/20220611034059/https://dl.acm.org/doi/10.1145/3158154 |url-status=live|doi-access=free |hdl=21.11116/0000-0003-34C6-3 |hdl-access=free }}</ref><ref>{{Cite thesis |last=Jung |first=Ralf |year=2020 |title=Understanding and evolving the Rust programming language |url=https://publikationen.sulb.uni-saarland.de/handle/20.500.11880/29647 |language=en |doi=10.22028/D291-31946 |access-date=May 15, 2022 |archive-date=March 8, 2022 |archive-url=https://web.archive.org/web/20220308050018/https://publikationen.sulb.uni-saarland.de/handle/20.500.11880/29647 |url-status=live |degree=PhD |publisher=[[Saarland University]]}}</ref>\n\n", "sections": [{"title": " Syntax and features ", "content": "Rust's [[Syntax (programming languages)|syntax]] is similar to that of [[C (programming language)|C]] and C++,<ref>{{Cite web |last=Proven |first=Liam |date=2019-11-27 |title=Rebecca Rumbul named new CEO of The Rust Foundation |url=https://www.theregister.com/2021/11/19/rust_foundation_ceo/ |access-date=2022-07-14 |website=The Register |language=en |quote=\"Both are curly bracket languages, with C-like syntax that makes them unintimidating for C programmers.\"}}</ref><ref name=\":4\" /> although many of its features were influenced by [[functional programming]] languages.{{sfn|Klabnik|Nichols|2019|p=263}} Hoare described Rust as targeted at \"frustrated C++ developers\" and emphasized features such as safety, control of [[memory map|memory layout]], and [[Concurrency (computer science)|concurrency]].<ref name=\"infoq2012\"/> Safety in Rust includes the guarantees of memory safety, type safety, and lack of data races.\n\n=== Hello World program ===\nBelow is a [[\"Hello, World!\" program]] in Rust. The {{Rust|fn}} keyword denotes a [[Function (computer programming)|function]], and the <code>println!</code> [[Macro (computer science)|macro]] prints the message to [[standard output]].{{sfn|Klabnik|Nichols|2019|pp=5\u20136}} [[Statement (computer science)|Statements]] in Rust are [[Semicolon#Programming|separated]] by semicolons.\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    println!(\"Hello, World!\");\n}\n</syntaxhighlight>\n\n=== Keywords and control flow ===\nIn Rust, blocks of code are delimited by [[Bracket#Curly brackets|curly brackets]], and [[control flow]] is implemented by keywords including <code>[[Conditional (computer programming)|if]]</code>, <code>else</code>, <code>[[While loop|while]]</code>, and <code>[[For loop|for]]</code>.{{sfn|Klabnik|Nichols|2019|pp=49\u201357}} [[Pattern matching]] can be done using the {{Rust|match}} keyword.{{sfn|Klabnik|Nichols|2019|pp=104\u2013109}} In the examples below, explanations are given in [[comment (computer programming)|comment]]s, which start with {{code|//}}.{{sfn|Klabnik|Nichols|2019|p=49}}\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    // Defining a mutable variable with 'let mut'\n    // Using the macro vec! to create a vector\n    let mut values = vec![1, 2, 3, 4];\n\n    for value in &values {\n        println!(\"value = {}\", value);\n    }\n\n    if values.len() > 5 {\n        println!(\"List is longer than five items\");\n    }\n\n    // Pattern matching\n    match values.len() {\n        0 => println!(\"Empty\"),\n        1 => println!(\"One value\"),\n        // pattern matching can use ranges of integers\n        2..=10 => println!(\"Between two and ten values\"),\n        11 => println!(\"Eleven values\"),\n        // A `_` pattern is called a \"wildcard\", it matches any value\n        _ => println!(\"Many values\"),\n    };\n\n    // while loop with predicate and pattern matching using let\n    while let Some(value) = values.pop() {\n        println!(\"value = {value}\"); // using curly brackets to format a local variable\n    }\n}\n</syntaxhighlight>\n\n=== Expression blocks ===\nRust is [[Expression-oriented programming language|expression-oriented]], with nearly every part of a function body being an [[Expression (computer science)|expression]], including control-flow operators.{{sfn|Klabnik|Nichols|2019|pp=50\u201353}} The ordinary <code>if</code> expression is used instead of [[?:|C's ternary conditional]]. With returns being implicit, a function does not need to end with a <code>return</code> expression; if the semicolon is omitted, the value of the last expression in the function is used as the [[return value]],<ref>{{Cite web |last=Tyson |first=Matthew |date=2022-03-03 |title=Rust programming for Java developers |url=https://www.infoworld.com/article/3651362/rust-programming-for-java-developers.html |access-date=2022-07-14 |website=InfoWorld |language=en}}</ref> as seen in the following [[Recursion (computer science)|recursive]] implementation of the [[factorial]] function:\n\n<syntaxhighlight lang=\"rust\">\nfn factorial(i: u64) -> u64 {\n    if i == 0 {\n        1\n    } else {\n        i * factorial(i - 1)\n    }\n}\n</syntaxhighlight>\n\nThe following [[Iteration (computer science)|iterative]] implementation uses the <code>..=</code> operator to create an inclusive range:\n\n<syntaxhighlight lang=\"rust\">\nfn factorial(i: u64) -> u64 {\n    (2..=i).product()\n}\n</syntaxhighlight>\n\n==== Closures ====\n{{excerpt|Anonymous function|Rust|subsections=yes}}\n\n=== Types ===\nRust is [[strongly typed]] and [[statically typed]]. The types of all variables must be known at compilation time; assigning a value of a particular type to a differently typed variable causes a [[compilation error]]. Variables are declared with the [[Reserved word|keyword]] <code>let</code>, and type inference is used to determine their type.{{sfn|Klabnik|Nichols|2019|pp=24}} Variables assigned multiple times must be marked with the keyword <code>mut</code> (short for mutable).{{sfn|Klabnik|Nichols|2019|pp=32\u201333}}\n\nThe default integer type is {{rust|i32}}, and the default [[floating point]] type is {{rust|f64}}. If the type of a [[Literal (computer programming)|literal]] number is not explicitly provided, either it is [[type inference|inferred]] from the context or the default type is used.{{sfn|Klabnik|Nichols|2019|pp=36\u201338}}\n\n==== Primitive types ====\n{| class=\"wikitable\"\n|+Summary of Rust's [[Primitive data type|Primitive Types]]\n!Type\n!Description\n!Examples\n|-\n|{{rust|bool}}\n|[[Boolean value]]\n|{{plainlist|\n* {{rust|true}}\n* {{rust|false}}\n  }}\n|-\n|{{rust|u8}}\n|Unsigned [[8-bit integer]] (a [[byte]])\n|{{plainlist|\n* {{rust|255u8}}<ref group=\"note\" name=\"ExplicitSuffix\">This literal uses an explicit suffix, which is not needed when type can be inferred from the context</ref>\n* {{Rust|b'W'}} ([[ASCII]] encoded byte)\n  }}\n|-\n|{{plainlist|\n* {{rust|i8}}\n* {{rust|i16}}\n* {{rust|i32}}\n* {{rust|i64}}\n* {{rust|i128}}\n  }}\n|[[Signed integer]]s, up to [[128-bit computing|128 bits]]\n|{{plainlist|\n* {{rust|7}}<ref group=\"note\" name=\"Default\">Interpreted as {{rust|i32}} by default, or inferred from the context</ref>\n* {{rust|7i128}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n  }}\n|-\n|{{plainlist|\n* {{rust|u16}}\n* {{rust|u32}}\n* {{rust|u64}}\n* {{rust|u128}}\n  }}\n|[[Unsigned integer]]s, up to [[128-bit computing|128 bits]]\n|{{plainlist|\n* {{rust|14}}<ref group=\"note\" name=\"Inferred\">Type inferred from the context</ref>\n* {{rust|14u128}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n  }}\n|-\n|{{plainlist|\n* {{rust|usize}}\n* {{rust|isize}}\n  }}\n|[[Pointer (computer programming)|Pointer]]-sized integers (size depends on [[computing platform|platform]])\n|{{plainlist|\n* {{rust|14usize}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n* {{rust|-2isize}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n  }}\n|-\n|{{plainlist|\n* {{rust|f32}}\n* {{rust|f64}}\n  }}\n|[[Floating-point arithmetic|Floating-point number]]s\n|{{plainlist|\n* {{rust|-3f32}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n  }}\n|-\n|{{Rust|char}}\n|{{Plainlist|\n* [[UTF-32]] scalar value (occupies 4 bytes)\n* A [[Unicode codepoint]] that is not a [[Universal Character Set characters#Surrogates|surrogate]]{{sfn|Klabnik|Nichols|2019|pp=39\u201340}}\n  }}\n|{{plainlist|\n* {{Rust|'a'}}\n* {{Rust|'\u8bed'}}\n* {{Rust|'\ud83e\udd80'}} ([[Emoji]])\n* {{Rust|'\\u{200D}'}} (Unicode escape, [[zero-width joiner]])\n  }}\n|-\n|{{Rust|str}}\n|[[UTF-8]]-encoded string slice, the primitive string type. It is usually seen in its borrowed form, {{Rust|&str}}. It is also the type of string literals, {{Rust|&'static str}}<ref>{{Cite web |title=str \u2013 Rust |url=https://doc.rust-lang.org/beta/std/primitive.str.html |access-date=2023-06-23 |website=doc.rust-lang.org}}</ref>\n|{{plainlist|\n* {{Rust|\"Hello\"}}\n* {{Rust|\"3\"}}\n* {{Rust|\"\ud83e\udd80\ud83e\udd80\ud83e\udd80\"}}\n  }}\n|-\n|{{Rust|[T; N]}}\n|[[Array (data structure)|Array]] \u2013 collection of N objects of the same type T, stored in contiguous memory\n|{{plainlist|\n* {{Rust|[2, 4, 6]}}\n* {{Rust|[0; 100]}}\n* {{Rust|b\"Hello\"}}\n  }}\n|-\n|{{Rust|[T]}}\n|Slice \u2013 a dynamically-sized view into a contiguous sequence<ref>{{Cite web |title=slice \u2013 Rust |url=https://doc.rust-lang.org/beta/std/primitive.slice.html |access-date=2023-06-23 |website=doc.rust-lang.org}}</ref>\n|{{plainlist|\n* {{Rust|[1, 2, 3, 4, 5][..i]}}\n* {{Rust|\"Hello, world!\".as_bytes()}}\n* {{Rust|let v {{=}} vec![1, 2, 3]; v.as_slice()}}\n  }}\n|-\n|{{plainlist|{{Rust|(T, U, ..)}}}}\n|[[Tuple]] \u2013 a finite heterogeneous sequence\n|{{plainlist|\n* {{Rust|()}} (An empty tuple, the [[unit type]] in Rust)\n* {{Rust|(5,)}} ({{Rust|(5)}} is parsed as an integer)<ref>{{Cite web |title=Tuples |url=https://doc.rust-lang.org/rust-by-example/primitives/tuples.html |access-date=2023-10-01 |website=Rust By Example}}</ref>\n* {{Rust|(\"Age\", 10)}}\n* {{Rust|(1, true, \"Name\")}}\n  }}\n|-\n| {{Rust|!}}\n| [[Bottom type|Never type]] (unreachable value)\n| {{Rust|let x {{=}} { return 123 };}}\n|}\n\n==== Standard library ====\n{| class=\"wikitable\"\n|+Summary of Rust's types in the [[standard library]]\n!Type\n!Description\n!Examples\n|-\n|{{Rust|String}}\n|UTF-8-encoded strings (dynamic)\n|{{plainlist|\n* {{Rust|String::new()}}\n* {{Rust|String::from(\"Hello\")}}\n* {{Rust|\"\ud83e\udd80\ud83e\udd80\ud83e\udd80\".to_string()}}\n  }}\n|-\n|{{plainlist|\n* {{Rust|OsStr}}\n* {{Rust|OsString}}\n  }}\n|Platform-native strings<ref group=\"note\" name=\"OsString\">On Unix systems, this is often UTF-8 strings without an internal 0 byte. On Windows, this is [[UTF-16]] strings without an internal 0 byte. Unlike these, {{Rust|str}} and {{Rust|String}} are always valid UTF-8 and can contain internal zeros.</ref> (borrowed<ref>{{Cite web |title=OsStr in std::ffi \u2013 Rust |url=https://doc.rust-lang.org/beta/std/ffi/struct.OsStr.html |access-date=2023-10-02 |website=doc.rust-lang.org}}</ref> and dynamic<ref>{{Cite web |title=OsString in std::ffi \u2013 Rust |url=https://doc.rust-lang.org/beta/std/ffi/struct.OsString.html |access-date=2023-10-02 |website=doc.rust-lang.org}}</ref>)\n|{{plainlist|\n* {{Rust|OsStr::new(\"Hello\")}}\n* {{Rust|OsString::from(\"world\")}}\n  }}\n|-\n|{{plainlist|\n* {{Rust|Path}}\n* {{Rust|PathBuf}}\n  }}\n|[[Path (computing)|Paths]] (borrowed<ref>{{Cite web |title=Path in std::path \u2013 Rust |url=https://doc.rust-lang.org/beta/std/path/struct.Path.html |access-date=2023-10-02 |website=doc.rust-lang.org}}</ref> and dynamic<ref>{{Cite web |title=PathBuf in std::path \u2013 Rust |url=https://doc.rust-lang.org/beta/std/path/struct.PathBuf.html |access-date=2023-10-02 |website=doc.rust-lang.org}}</ref>)\n|{{plainlist|\n* {{Rust|Path::new(\"./path/to\")}}\n* {{Rust|PathBuf::from(r\"C:.\\path\\to\")}}\n  }}\n|-\n|{{plainlist|\n* {{Rust|CStr}}\n* {{Rust|CString}}\n  }}\n|[[C (programming language)|C]]-compatible, [[null-terminated string]]s (borrowed<ref name=\"std::boxed \u2013 Rust\">{{Cite web |title=std::boxed \u2013 Rust |url=https://doc.rust-lang.org/std/boxed/index.html |access-date=2023-06-23 |website=doc.rust-lang.org}}</ref> and dynamic<ref name=\"std::boxed \u2013 Rust\"/>)\n|{{plainlist|\n* {{Rust|CStr::from_bytes_with_nul(b\"Hello\\0\").unwrap()}}\n* {{Rust|CString::new(\"world\").unwrap()}}\n  }}\n|-\n|{{Rust|Vec<T>}}\n|[[Dynamic array]]s\n|{{plainlist|\n* {{Rust|Vec::new()}}\n* {{Rust|vec![1, 2, 3, 4, 5]}}\n  }}\n|-\n|{{Rust|Option<T>}}\n|[[Option type]]\n|{{plainlist|\n* {{Rust|None}}\n* {{Rust|Some(3)}}\n* {{Rust|Some(\"hello\")}}\n  }}\n|-\n|{{Rust|Result<T, E>}}\n|[[Exception handling|Error handling]] using a [[result type]]\n|{{plainlist|\n* {{Rust|Ok(3)}}\n* {{Rust|Err(\"something went wrong\")}}\n  }}\n|-\n|{{Rust|Box<T>}}\n|A pointer to a [[Heap (programming)|heap]]-allocated value<ref>{{Cite web |title=std::boxed \u2013 Rust |url=https://doc.rust-lang.org/std/boxed/index.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>. Similar to C++'s [https://en.cppreference.com/w/cpp/memory/unique_ptr std::unique_ptr].\n| <syntaxhighlight lang=\"rust\">\nlet boxed: Box<u8> = Box::new(5);\nlet val: u8 = *boxed;\n</syntaxhighlight>\n|-\n|{{Rust|Rc<T>}}\n|[[Reference counting]] pointer<ref>{{Cite web |title=Rc in std::rc \u2013 Rust |url=https://doc.rust-lang.org/beta/std/rc/struct.Rc.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet five = Rc::new(5);\nlet also_five = five.clone();\n</syntaxhighlight>\n|-\n|{{Rust|Arc<T>}}\n|[[Linearizability|Atomic]], [[Thread safety|thread-safe]] reference counting pointer<ref>{{Cite web |title=Arc in std::sync \u2013 Rust |url=https://doc.rust-lang.org/beta/std/sync/struct.Arc.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet foo = Arc::new(vec![1.0, 2.0]);\nlet a = foo.clone(); // a can be sent to another thread\n</syntaxhighlight>\n|-\n|{{Rust|Cell<T>}}\n|A mutable memory location<ref>{{Cite web |title=Cell in std::cell \u2013 Rust |url=https://doc.rust-lang.org/beta/std/cell/struct.Cell.html# |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet c = Cell::new(5);\nc.set(10);\n</syntaxhighlight>\n|-\n|<code>Mutex<T></code>\n|A [[Lock (computer science)|mutex lock]] for shared data contained within.<ref>{{Cite web |title=Mutex in std::sync \u2013 Rust |url=https://doc.rust-lang.org/beta/std/sync/struct.Mutex.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet mutex = Mutex::new(0_u32);\nlet _guard = mutex.lock();\n</syntaxhighlight>\n|-\n|{{Rust|RwLock<T>}}\n|[[Readers\u2013writer lock]]<ref>{{Cite web |title=RwLock in std::sync \u2013 Rust |url=https://doc.rust-lang.org/beta/std/sync/struct.RwLock.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet lock = RwLock::new(5);\nlet r1 = lock.read().unwrap();\n</syntaxhighlight>\n|-\n|{{Rust|Condvar}}\n|A [[Monitor (synchronization)|conditional monitor]] for shared data<ref>{{Cite web |title=Condvar in std::sync \u2013 Rust |url=https://doc.rust-lang.org/beta/std/sync/struct.Condvar.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\n let (lock, cvar) = (Mutex::new(true), Condvar::new());\n// As long as the value inside the `Mutex<bool>` is `true`, we wait.\nlet _guard = cvar.wait_while(lock.lock().unwrap(), |pending| { *pending }).unwrap();\n\n</syntaxhighlight>\n|-\n|{{Rust|Duration}}\n|Type that represents a span of time<ref>{{Cite web |title=Duration in std::time \u2013 Rust |url=https://doc.rust-lang.org/beta/std/time/struct.Duration.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nDuration::from_millis(1) // 1ms\n</syntaxhighlight>\n|-\n|{{Rust|1=HashMap<K, V>}}\n|[[Hash table]]<ref>{{Cite web |title=HashMap in std::collections \u2013 Rust |url=https://doc.rust-lang.org/beta/std/collections/struct.HashMap.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet mut player_stats = HashMap::new();\nplayer_stats.insert(\"damage\", 1);\nplayer_stats.entry(\"health\").or_insert(100);\n</syntaxhighlight>\n|-\n|{{Rust|1=BTreeMap<K, V>}}\n|[[B-tree]]<ref>{{Cite web |title=BTreeMap in std::collections \u2013 Rust |url=https://doc.rust-lang.org/beta/std/collections/struct.BTreeMap.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet mut solar_distance = BTreeMap::from([\n    (\"Mercury\", 0.4),\n    (\"Venus\", 0.7),\n]);\nsolar_distance.entry(\"Earth\").or_insert(1.0);\n\n</syntaxhighlight>\n|}\n\n[[Option type|<code>Option</code>]] values are handled using [[syntactic sugar]], such as the <code>if let</code> construction, to access the inner value (in this case, a string):{{sfn|McNamara|2021}}\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    let name1: Option<&str> = None;\n    // In this case, nothing will be printed out\n    if let Some(name) = name1 {\n        println!(\"{name}\");\n    }\n\n    let name2: Option<&str> = Some(\"Matthew\");\n    // In this case, the word \"Matthew\" will be printed out\n    if let Some(name) = name2 {\n        println!(\"{name}\");\n    }\n}\n</syntaxhighlight>\n\n==== Pointers ====\n{| class=\"wikitable\"\n|+Summary of Rust's [[Pointer (computer programming)|pointer]] and [[Reference (computer science)|reference]] primitive types\n!Type\n!Description\n!Examples\n|-\n|{{plainlist|\n* {{Rust|&T}}\n* {{Rust|&mut T}}\n  }}\n|[[Reference (computer science)|References]] (immutable and mutable)\n|{{plainlist|\n* {{Rust|let x_ref {{=}} {{not a typo|&x;}}}}\n* {{Rust|let x_ref {{=}} &mut x;}}\n  }}\n|-\n|{{plainlist|\n* {{Rust|Option<&T>}}\n* {{Rust|Option<&mut T>}}\n  }}\n|{{plainlist|\n* Option wrapped reference\n* Possibly null reference\n  }}\n|{{plainlist|\n* {{Rust|None}}\n* {{Rust|let x_ref {{=}} Some(&x);}}\n* {{Rust|let x_ref {{=}} Some(&mut x);}}\n  }}\n|-\n|{{Plain list|* {{Rust|Box<T>}}\n* {{Rust|Option<Box<T>>}}}}\n|A pointer to heap-allocated value\n(or possibly null pointer if wrapped in option)<ref name=\"std::boxed \u2013 Rust\"/>\n|{{Plain list|* {{Rust|let boxed {{=}} Box::new(0);}}\n* {{Rust|let boxed {{=}} Some(Box::new(\"Hello World\"));}}}}\n|-\n|{{Plainlist|\n* {{Rust|*const T}}\n* {{Rust|*mut T}}\n  }}\n|{{Plainlist|\n* Raw pointers (immutable and mutable)\n* Possibly [[Null pointer|null]]; {{Rust|unsafe}} to [[dereference]]\n  }}\n|{{Plainlist|\n* {{Rust|let x_ptr {{=}} &x as *const T;}}\n* {{Rust|let x_ptr {{=}} &mut x as *mut T;}}\n  }}\n|}\n\nRust does not use [[null pointer]]s to indicate a lack of data, as doing so can lead to [[Null pointer#Null dereferencing|null dereferencing]]. Accordingly, the basic <code>&</code> and <code>&mut</code> references are guaranteed to not be null. Rust instead uses <code>Option</code> for this purpose: <code>Some(T)</code> indicates that a value is present, and <code>None</code> is analogous to the null pointer.{{sfn|Klabnik|Nichols|2019|pp=101\u2013104}} <code>Option</code> implements a \"null pointer optimization\", avoiding any spatial overhead for types that cannot have a null value (references or the <code>NonZero</code> types, for example).<ref>{{Cite web |title=std::option - Rust |url=https://doc.rust-lang.org/std/option/index.html#representation |access-date=2023-11-12 |website=doc.rust-lang.org}}</ref>\n\nUnlike references, the raw pointer types <code>*const</code> and <code>*mut</code> may be null; however, it is impossible to dereference them unless the code is explicitly declared unsafe through the use of an <code>unsafe</code> block. Unlike dereferencing, the creation of raw pointers is allowed inside of safe Rust code.{{sfn|Klabnik|Nichols|2019|pp=418\u2013427}}\n\n==== User-defined types ====\nUser-defined types are created with the <code>struct</code> or <code>enum</code> keywords. The <code>struct</code> keyword is used to denote a [[Record (computer science)|record type]] that groups multiple related values.{{sfn|Klabnik|Nichols|2019|p=83}} <code>enum</code>s can take on different variants at runtime, with its capabilities similar to [[algebraic data types]] found in functional programming languages.{{sfn|Klabnik|Nichols|2019|p=97}} Both structs and enums can contain [[Field (computer science)|fields]] with different types.{{sfn|Klabnik|Nichols|2019|pp=98\u2013101}} Alternative names for the same type can be defined with the <code>type</code> keyword.{{sfn|Klabnik|Nichols|2019|pp=438\u2013440}}\n\nThe <code>impl</code> keyword can define methods for a user-defined type (data and functions are defined separately). Implementations fulfill a role similar to that of classes within other languages.{{sfn|Klabnik|Nichols|2019|pp=93}}\n\n==== Type conversion ====\n{{excerpt|Type conversion|Rust}}\n\n=== Ownership and lifetimes ===\nRust's ownership system consists of rules that ensure memory safety without using a garbage collector. At compile time, each value must be attached to a variable called the ''owner'' of that value, and every value must have exactly one owner.{{sfn|Klabnik|Nichols|2019|pp=59\u201361}} Values are moved between different owners through assignment or passing a value as a function parameter.  Values can also be ''borrowed,'' meaning they are temporarily passed to a different function before being returned to the owner.{{sfn|Klabnik|Nichols|2019|pp=63\u201368}} With these rules, Rust can prevent the creation and use of [[dangling pointers]]:{{sfn|Klabnik|Nichols|2019|pp=63\u201368}}{{sfn|Klabnik|Nichols|2019|pp=74\u201375}}\n\n<syntaxhighlight lang=\"rust\">\nfn print_string(s: String) {\n    println!(\"{}\", s);\n}\n\nfn main() {\n    let s = String::from(\"Hello, World\");\n    print_string(s); // s consumed by print_string\n    // s has been moved, so cannot be used any more\n    // another print_string(s); would result in a compile error\n}\n</syntaxhighlight>\n\nBecause of these ownership rules, Rust types are known as ''[[linear types|linear]]'' or ''affine'' types, meaning each value can be used exactly once. This enforces a form of [[software fault isolation]] as the owner of a value is solely responsible for its correctness and deallocation.<ref name=\"BeyondSafety\">{{Cite book |last1=Balasubramanian |first1=Abhiram |last2=Baranowski |first2=Marek S. |last3=Burtsev |first3=Anton |last4=Panda |first4=Aurojit |last5=Rakamari\u0107 |first5=Zvonimir |last6=Ryzhyk |first6=Leonid |title=Proceedings of the 16th Workshop on Hot Topics in Operating Systems |chapter=System Programming in Rust |date=2017-05-07 |chapter-url=https://doi.org/10.1145/3102980.3103006 |series=HotOS '17 |location=New York, NY, US |publisher=Association for Computing Machinery |pages=156\u2013161 |doi=10.1145/3102980.3103006 |isbn=978-1-4503-5068-6 |s2cid=24100599 |access-date=June 1, 2022 |archive-date=June 11, 2022 |archive-url=https://web.archive.org/web/20220611034046/https://dl.acm.org/doi/10.1145/3102980.3103006 |url-status=live}}</ref>\n\nWhen a value goes out of scope, it is ''dropped'' by running its [[Destructor (computer programming)|destructor]]. The destructor may be programmatically defined through implementing the {{code|Drop}} [[#Traits|trait]]. This helps manage resources such as file handles, network sockets, and [[Lock (computer science)|locks]], since when objects are dropped, the resources associated with them are closed or released automatically.{{sfn|Klabnik|Nichols|2023|pp=327-30}}\n\n''Lifetimes'' are usually an implicit part of all [[Reference (computer science)|reference types]] in Rust. Each lifetime encompasses a set of locations in the code for which a variable is valid. For example, a reference to a local variable has a lifetime corresponding to the block it is defined in:{{sfn|Klabnik|Nichols|2019|p=194}}\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    let x = 5;                              // ------------------+- Lifetime 'b\n                                            //                   |\n    let r = &x;                             // -+-- Lifetime 'a  |\n                                            //  |                |\n    println!(\"r: {}\", r);                   //  |                |\n                                            //  |                |\n                                            // -+                |\n}                                           // ------------------+\n</syntaxhighlight>\n\nThe borrow checker in the Rust compiler uses lifetimes to ensure that the values a reference points to remain valid.{{sfn|Klabnik|Nichols|2019|pp=75,134}}<ref>{{Cite web |last=Shamrell-Harrington |first=Nell |title=The Rust Borrow Checker \u2013 a Deep Dive |url=https://www.infoq.com/presentations/rust-borrow-checker/ |access-date=2022-06-25 |website=InfoQ |language=en}}</ref> In the example above, storing a reference to variable {{code|x}} to {{code|r}} is valid, as variable {{code|x}} has a longer lifetime ({{code|'b}}) than variable {{code|r}} ({{code|'a}}). However, when {{code|x}} has a shorter lifetime, the borrow checker would reject the program:\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    let r;                                  // ------------------+- Lifetime 'a\n                                            //                   |\n    {                                       //                   |\n        let x = 5;                          // -+-- Lifetime 'b  |\n        r = x;                              //  |                |\n    }                                       //  |                |\n                                            //                   |\n    println!(\"r: {}\", r);                   //                   |\n}                                           // ------------------+\n</syntaxhighlight>\n\nSince the lifetime of the referenced variable ({{code|'b}}) is shorter than the lifetime of the variable holding the reference ({{code|'a}}), the borrow checker errors, preventing {{code|x}} from being used from outside its scope.{{sfn|Klabnik|Nichols|2019|pp=194-195}}\n\nRust defines the relationship between the lifetimes of the objects created and used by functions, using ''lifetime parameters'', as a signature feature.{{sfn|Klabnik|Nichols|2019|pp=192\u2013204}}\n\nThe example below parses some configuration options from a string and creates a struct containing the options. The struct only contains references to the data; so, for the struct to remain valid, the data referred to by the struct must be valid as well. The function signature for <code>parse_config</code> specifies this relationship explicitly. In this example, the explicit lifetimes are unnecessary in newer Rust versions, due to lifetime elision, which is an algorithm that automatically assigns lifetimes to functions if they are trivial.{{sfn|Klabnik|Nichols|2019|pp=201\u2013203}}\n\n<syntaxhighlight lang=\"rust\">\nuse std::collections::HashMap;\n\n// This struct has one lifetime parameter, 'src. The name is only used within the struct's definition.\n#[derive(Debug)]\nstruct Config<'src> {\n    hostname: &'src str,\n    username: &'src str,\n}\n\n// This function also has a lifetime parameter, 'cfg. 'cfg is attached to the \"config\" parameter, which\n// establishes that the data in \"config\" lives at least as long as the 'cfg lifetime.\n// The returned struct also uses 'cfg for its lifetime, so it can live at most as long as 'cfg.\nfn parse_config<'cfg>(config: &'cfg str) -> Config<'cfg> {\n    let key_values: HashMap<_, _> = config\n        .lines()\n        .filter(|line| !line.starts_with('#'))\n        .filter_map(|line| line.split_once('='))\n        .map(|(key, value)| (key.trim(), value.trim()))\n        .collect();\n    Config {\n        hostname: key_values[\"hostname\"],\n        username: key_values[\"username\"],\n    }\n}\n\nfn main() {\n    let config = parse_config(\n        r#\"hostname = foobar\nusername=barfoo\"#,\n    );\n    println!(\"Parsed config: {:#?}\", config);\n}\n</syntaxhighlight>\n\n[[File:Rust 101.webm|thumb|A presentation on Rust by Emily Dunham from [[Mozilla]]'s Rust team ([[linux.conf.au]] conference, Hobart, 2017)]]\n\n=== Memory safety ===\nRust is designed to be [[memory safe]]. It does not permit null pointers, [[dangling pointer]]s, or [[data race]]s.<ref name=\"cnet\">{{cite web |url=http://reviews.cnet.com/8301-3514_7-57577639/samsung-joins-mozillas-quest-for-rust/ |title=Samsung joins Mozilla's quest for Rust |last=Rosenblatt |first=Seth |date=2013-04-03 |publisher=[[CNET]] |access-date=2013-04-05 |archive-date=2013-04-04 |archive-url=https://web.archive.org/web/20130404142333/http://reviews.cnet.com/8301-3514_7-57577639/samsung-joins-mozillas-quest-for-rust/ |url-status=live}}</ref><ref name=\"lwn\">{{cite web |url=https://lwn.net/Articles/547145/ |title=A taste of Rust |last=Brown |first=Neil |date=2013-04-17 |access-date=2013-04-25 |archive-date=2013-04-26 |archive-url=https://web.archive.org/web/20130426010754/http://lwn.net/Articles/547145/ |url-status=live}}</ref><ref name=\"The Rustonomicon\">{{Cite web|url=https://doc.rust-lang.org/nomicon/races.html|title=Races \u2013 The Rustonomicon|website=doc.rust-lang.org|access-date=2017-07-03|archive-date=2017-07-10|archive-url=https://web.archive.org/web/20170710194643/https://doc.rust-lang.org/nomicon/races.html|url-status=live}}</ref> Data values can be initialized only through a fixed set of forms, all of which require their inputs to be already initialized.<ref name=\"lang-faq\">{{cite web  |title=The Rust Language FAQ |website=static.rust-lang.org |url=http://static.rust-lang.org/doc/master/complement-lang-faq.html |url-status=dead |archive-url=https://web.archive.org/web/20150420104147/http://static.rust-lang.org/doc/master/complement-lang-faq.html |archive-date=2015-04-20 |year=2015 |access-date=2017-04-24}}</ref>\n\nUnsafe code can subvert some of these restrictions, using the <code>unsafe</code> keyword.{{sfn|Klabnik|Nichols|2019|pp=418\u2013427}} Unsafe code may also be used for low-level functionality, such as [[Volatile (computer programming)|volatile memory access]], architecture-specific intrinsics, [[type punning]], and inline assembly.{{sfn|McNamara|2021|p=139, 376\u2013379, 395}}\n\n=== Memory management ===\nRust does not use [[garbage collection (computer science)|garbage collection]]. Memory and other resources are instead managed through the \"resource acquisition is initialization\" convention,<ref>{{Cite web|title=RAII \u2013 Rust By Example|url=https://doc.rust-lang.org/rust-by-example/scope/raii.html|access-date=2020-11-22|website=doc.rust-lang.org|archive-date=2019-04-21|archive-url=https://web.archive.org/web/20190421131142/https://doc.rust-lang.org/rust-by-example/scope/raii.html|url-status=live}}</ref> with optional [[reference counting]]. Rust provides deterministic management of resources, with very low [[Overhead (computing)|overhead]].<ref>{{Cite web|url=https://blog.rust-lang.org/2015/05/11/traits.html|title=Abstraction without overhead: traits in Rust|website=Rust Blog|access-date=October 19, 2021|archive-date=September 23, 2021|archive-url=https://web.archive.org/web/20210923101530/https://blog.rust-lang.org/2015/05/11/traits.html|url-status=live}}</ref> Values are [[Stack-based memory allocation|allocated on the stack]] by default, and all [[dynamic allocation]]s must be explicit.<ref>{{Cite web |title=Box, stack and heap |url=https://doc.rust-lang.org/stable/rust-by-example/std/box.html |access-date=2022-06-13 |website=Rust By Example}}</ref>\n\nThe built-in reference types using the <code>&</code> symbol do not involve run-time reference counting. The safety and validity of the underlying pointers is verified at compile time, preventing [[dangling pointers]] and other forms of [[undefined behavior]].{{sfn|Klabnik|Nichols|2019|pp=70\u201375}} Rust's type system separates shared, [[Immutable object|immutable]] references of the form <code>&T</code> from unique, mutable references of the form <code>&mut T</code>. A mutable reference can be coerced to an immutable reference, but not vice versa.{{sfn|Klabnik|Nichols|2019|p=323}}\n\n=== Polymorphism ===\n==== Generics ====\nRust's more advanced features include the use of [[generic function]]s. A generic function is given [[Generic programming|generic]] [[Parameter (computer programming)|parameters]], which allow the same function to be applied to different variable types. This capability reduces [[duplicate code]]{{sfn|Klabnik|Nichols|2019|pp=171\u2013172}} and is known as [[parametric polymorphism]].\n\nThe following program calculates the sum of two things, for which addition is implemented using a generic function:\n\n<syntaxhighlight lang=\"rust\">\nuse std::ops::Add;\n\n// sum is a generic function with one type parameter, T\nfn sum<T>(num1: T, num2: T) -> T\nwhere  \n    T: Add<Output = T>,  // T must implement the Add trait where addition returns another T\n{\n    num1 + num2  // num1 + num2 is syntactic sugar for num1.add(num2) provided by the Add trait\n}\n\nfn main() {\n    let result1 = sum(10, 20);\n    println!(\"Sum is: {}\", result1); // Sum is: 30\n\n    let result2 = sum(10.23, 20.45);\n    println!(\"Sum is: {}\", result2); // Sum is: 30.68\n}\n</syntaxhighlight>\n\nAt compile time, polymorphic functions like <code>sum</code> are [[Instance (computer science)|instantiated]] with the specific types the code requires; in this case, sum of integers and sum of floats.\n\nGenerics can be used in functions to allow implementing a behavior for different types without repeating the same code. Generic functions can be written in relation to other generics, without knowing the actual type.{{sfn|Klabnik|Nichols|2019|pp=171\u2013172,205}}\n\n==== Traits ====\nRust's type system supports a mechanism called traits, inspired by [[type class]]es in the [[Haskell]] language,<ref name=\"influences\"/> to define shared behavior between different types. For example, the <code>Add</code> trait can be implemented for floats and integers, which can be added; and the <code>Display</code> or <code>Debug</code> traits can be implemented for any type that can be converted to a string. Traits can be used to provide a set of common behavior for different types without knowing the actual type. This facility is known as [[ad hoc polymorphism]].\n\nGeneric functions can constrain the generic type to implement a particular trait or traits; for example, an <code>add_one</code> function might require the type to implement <code>Add</code>. This means that a generic function can be type-checked as soon as it is defined. The implementation of generics is similar to the typical implementation of C++ templates: a separate copy of the code is generated for each instantiation. This is called [[monomorphization]] and contrasts with the [[type erasure]] scheme typically used in Java and Haskell. Type erasure is also available via the keyword <code>dyn</code> (short for dynamic).{{sfn|Klabnik|Nichols|2019|pp=181,182}} Because monomorphization duplicates the code for each type used, it can result in more optimized code for specific-use cases, but compile time and size of the output binary are also increased.{{sfn|Gjengset|2021|p=25}}\n\nIn addition to defining methods for a user-defined type, the <code>impl</code> keyword can be used to implement a trait for a type.{{sfn|Klabnik|Nichols|2019|pp=93}} Traits can provide additional derived methods when implemented.{{sfn|Klabnik|Nichols|2019|pp=182\u2013184}} For example, the trait <code>Iterator</code> requires that the <code>next</code> method be defined for the type. Once the <code>next</code> method is defined, the trait can provide common functional helper methods over the iterator, such as <code>map</code> or <code>filter</code>.{{sfn|Klabnik|Nichols|2019|pp=281\u2013283}}\n\n==== Trait objects ====\nRust traits are implemented using [[static dispatch]], meaning that the type of all values is known at compile time; however, Rust also uses a feature known as ''trait objects'' to accomplish [[dynamic dispatch]] (also known as [[duck typing]]).<ref name=TraitObjectsBook>{{Cite web |title=Using Trait Objects That Allow for Values of Different Types \u2013 The Rust Programming Language |url=https://doc.rust-lang.org/book/ch17-02-trait-objects.html |access-date=2022-07-11 |website=doc.rust-lang.org}}</ref> Dynamically dispatched trait objects are declared using the syntax <code>dyn Tr</code> where <code>Tr</code> is a trait. Trait objects are dynamically sized, therefore they must be put behind a pointer, such as <code>Box</code>.{{sfn|Klabnik|Nichols|2019|pp=441\u2013442}} The following example creates a list of objects where each object can be printed out using the <code>Display</code> trait:\n\n<syntaxhighlight lang=\"Rust\">\nuse std::fmt::Display;\n\nlet v: Vec<Box<dyn Display>> = vec![\n    Box::new(3),\n    Box::new(5.0),\n    Box::new(\"hi\"),\n];\n\nfor x in v {\n    println!(\"{x}\");\n}\n</syntaxhighlight>\n\nIf an element in the list does not implement the <code>Display</code> trait, it will cause a compile-time error.{{sfn|Klabnik|Nichols|2019|pp=379\u2013380}}\n\n=== Iterators ===\n[[For loop]]s in Rust work in a functional style as operations over an [[iterator]] type. For example, in the loop\n\n<syntaxhighlight lang=\"rust\">\nfor x in 0..100 {\n   f(x);\n}\n</syntaxhighlight>\n\n<code>0..100</code> is a value of type <code>Range</code> which implements the <code>Iterator</code> trait; the code applies the function <code>f</code> to each element returned by the iterator. Iterators can be combined with functions over iterators like <code>map</code>, <code>filter</code>, and <code>sum</code>. For example, the following adds up all numbers between 1 and 100 that are multiples of 3:\n\n<syntaxhighlight lang=\"rust\">\n(1..=100).filter(|&x| x % 3 == 0).sum()\n</syntaxhighlight>\n\n=== Macros ===\nIt is possible to extend the Rust language using macros.\n\n==== Declarative macros ====\nA declarative macro (also called a \"macro by example\") is a macro that uses pattern matching to determine its expansion.<ref name=\"Rust Ref. \u2013 Macros By Example\">{{cite web |title=Macros By Example |url=https://doc.rust-lang.org/reference/macros-by-example.html |archive-url= |archive-date= |url-status= |website=The Rust Reference |access-date=21 April 2023}}</ref>{{sfn|Klabnik|Nichols|2019|pp=446\u2013448}}\n\n==== Procedural macros ====\nProcedural macros are Rust functions that run and modify the compiler's input [[Token (parser)|token]] stream, before any other components are compiled. They are generally more flexible than declarative macros, but are more difficult to maintain due to their complexity.<ref name=\"rust-procedural-macros\">{{cite web |url=https://doc.rust-lang.org/reference/procedural-macros.html |title=Procedural Macros |website=The Rust Programming Language Reference |access-date=23 Mar 2021 |archive-date=7 November 2020 |archive-url=https://web.archive.org/web/20201107233444/https://doc.rust-lang.org/reference/procedural-macros.html |url-status=live}}</ref>{{sfn|Klabnik|Nichols|2019|pp=449\u2013455}}\n\nProcedural macros come in three flavors:\n* Function-like macros <code>custom!(...)</code>\n* Derive macros <code>#[derive(CustomDerive)]</code>\n* Attribute macros <code>#[custom_attribute]</code>\n\nThe <code>println!</code> macro is an example of a function-like macro. The<code>serde_derive</code> macro<ref>{{cite web|url=https://serde.rs/derive.html|title=Serde Derive|website=Serde Derive documentation|access-date=23 Mar 2021|archive-date=17 April 2021|archive-url=https://web.archive.org/web/20210417114849/https://serde.rs/derive.html|url-status=live}}</ref> provides a commonly used library for generating code\nfor reading and writing data in many formats, such as [[JSON]]. Attribute macros are commonly used for language bindings, such as the <code>extendr</code> library for Rust bindings to [[R (programming language)|R]].<ref>{{cite web|url=https://extendr.github.io/extendr/extendr_api/index.html|title=extendr_api \u2013 Rust|website=Extendr Api Documentation|access-date=23 Mar 2021|archive-date=May 25, 2021|archive-url=https://web.archive.org/web/20210525082129/https://extendr.github.io/extendr/extendr_api/index.html|url-status=live}}</ref>\n\nThe following code shows the use of the <code>Serialize</code>, <code>Deserialize</code>, and <code>Debug</code>-derived procedural macros\nto implement JSON reading and writing, as well as the ability to format a structure for debugging.\n[[File:Rust serde UML diagram.svg|thumb|A [[UML diagram]] depicting a Rust struct named Point.]]\n<syntaxhighlight lang=\"rust\">\nuse serde_json::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let point = Point { x: 1, y: 2 };\n\n    let serialized = serde_json::to_string(&point).unwrap();\n    println!(\"serialized = {}\", serialized);\n\n    let deserialized: Point = serde_json::from_str(&serialized).unwrap();\n    println!(\"deserialized = {:?}\", deserialized);\n}\n</syntaxhighlight>\n\n==== Variadic macros ====\n{{excerpt|Variadic function|In Rust|subsections=yes}}\n\n=== Interface with C and C++ ===\nRust has a [[foreign function interface]] (FFI) that can be used both to call code written in languages such as [[C (programming language)|C]] from Rust and to call Rust code from those languages. As of 2023, an external library called CXX exists for calling to or from C++.<ref>{{Cite web|title=Safe Interoperability between Rust and C++ with CXX|url=https://www.infoq.com/news/2020/12/cpp-rust-interop-cxx/|date=2020-12-06|access-date=2021-01-03|website=InfoQ|language=en|archive-date=January 22, 2021|archive-url=https://web.archive.org/web/20210122142035/https://www.infoq.com/news/2020/12/cpp-rust-interop-cxx/|url-status=live}}</ref> Rust and C differ in how they lay out structs in memory, so Rust structs may be given a <code>#[repr(C)]</code> attribute, forcing the same layout as the equivalent C struct.<ref>{{cite web |title=Type layout \u2013 The Rust Reference |url=https://doc.rust-lang.org/reference/type-layout.html#the-c-representation |website=doc.rust-lang.org |access-date=15 July 2022}}</ref>\n\n", "goals": ["The student will be able to define and use Rust's primitive types, standard library types, and user-defined types", "The student will be able to define and use Rust's primitive types, standard library types, and user-defined types", "The student will be able to define and use Rust's primitive types, standard library types, and user-defined types", "The student will be able to define and use Rust's primitive types, standard library types, and user-defined types", "The student will be able to define and use Rust's primitive types, standard library types, and user-defined types"]}, {"title": " Types ", "content": "Rust is [[strongly typed]] and [[statically typed]]. The types of all variables must be known at compilation time; assigning a value of a particular type to a differently typed variable causes a [[compilation error]]. Variables are declared with the [[Reserved word|keyword]] <code>let</code>, and type inference is used to determine their type.{{sfn|Klabnik|Nichols|2019|pp=24}} Variables assigned multiple times must be marked with the keyword <code>mut</code> (short for mutable).{{sfn|Klabnik|Nichols|2019|pp=32\u201333}}\n\nThe default integer type is {{rust|i32}}, and the default [[floating point]] type is {{rust|f64}}. If the type of a [[Literal (computer programming)|literal]] number is not explicitly provided, either it is [[type inference|inferred]] from the context or the default type is used.{{sfn|Klabnik|Nichols|2019|pp=36\u201338}}\n\n==== Primitive types ====\n{| class=\"wikitable\"\n|+Summary of Rust's [[Primitive data type|Primitive Types]]\n!Type\n!Description\n!Examples\n|-\n|{{rust|bool}}\n|[[Boolean value]]\n|{{plainlist|\n* {{rust|true}}\n* {{rust|false}}\n  }}\n|-\n|{{rust|u8}}\n|Unsigned [[8-bit integer]] (a [[byte]])\n|{{plainlist|\n* {{rust|255u8}}<ref group=\"note\" name=\"ExplicitSuffix\">This literal uses an explicit suffix, which is not needed when type can be inferred from the context</ref>\n* {{Rust|b'W'}} ([[ASCII]] encoded byte)\n  }}\n|-\n|{{plainlist|\n* {{rust|i8}}\n* {{rust|i16}}\n* {{rust|i32}}\n* {{rust|i64}}\n* {{rust|i128}}\n  }}\n|[[Signed integer]]s, up to [[128-bit computing|128 bits]]\n|{{plainlist|\n* {{rust|7}}<ref group=\"note\" name=\"Default\">Interpreted as {{rust|i32}} by default, or inferred from the context</ref>\n* {{rust|7i128}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n  }}\n|-\n|{{plainlist|\n* {{rust|u16}}\n* {{rust|u32}}\n* {{rust|u64}}\n* {{rust|u128}}\n  }}\n|[[Unsigned integer]]s, up to [[128-bit computing|128 bits]]\n|{{plainlist|\n* {{rust|14}}<ref group=\"note\" name=\"Inferred\">Type inferred from the context</ref>\n* {{rust|14u128}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n  }}\n|-\n|{{plainlist|\n* {{rust|usize}}\n* {{rust|isize}}\n  }}\n|[[Pointer (computer programming)|Pointer]]-sized integers (size depends on [[computing platform|platform]])\n|{{plainlist|\n* {{rust|14usize}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n* {{rust|-2isize}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n  }}\n|-\n|{{plainlist|\n* {{rust|f32}}\n* {{rust|f64}}\n  }}\n|[[Floating-point arithmetic|Floating-point number]]s\n|{{plainlist|\n* {{rust|-3f32}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n  }}\n|-\n|{{Rust|char}}\n|{{Plainlist|\n* [[UTF-32]] scalar value (occupies 4 bytes)\n* A [[Unicode codepoint]] that is not a [[Universal Character Set characters#Surrogates|surrogate]]{{sfn|Klabnik|Nichols|2019|pp=39\u201340}}\n  }}\n|{{plainlist|\n* {{Rust|'a'}}\n* {{Rust|'\u8bed'}}\n* {{Rust|'\ud83e\udd80'}} ([[Emoji]])\n* {{Rust|'\\u{200D}'}} (Unicode escape, [[zero-width joiner]])\n  }}\n|-\n|{{Rust|str}}\n|[[UTF-8]]-encoded string slice, the primitive string type. It is usually seen in its borrowed form, {{Rust|&str}}. It is also the type of string literals, {{Rust|&'static str}}<ref>{{Cite web |title=str \u2013 Rust |url=https://doc.rust-lang.org/beta/std/primitive.str.html |access-date=2023-06-23 |website=doc.rust-lang.org}}</ref>\n|{{plainlist|\n* {{Rust|\"Hello\"}}\n* {{Rust|\"3\"}}\n* {{Rust|\"\ud83e\udd80\ud83e\udd80\ud83e\udd80\"}}\n  }}\n|-\n|{{Rust|[T; N]}}\n|[[Array (data structure)|Array]] \u2013 collection of N objects of the same type T, stored in contiguous memory\n|{{plainlist|\n* {{Rust|[2, 4, 6]}}\n* {{Rust|[0; 100]}}\n* {{Rust|b\"Hello\"}}\n  }}\n|-\n|{{Rust|[T]}}\n|Slice \u2013 a dynamically-sized view into a contiguous sequence<ref>{{Cite web |title=slice \u2013 Rust |url=https://doc.rust-lang.org/beta/std/primitive.slice.html |access-date=2023-06-23 |website=doc.rust-lang.org}}</ref>\n|{{plainlist|\n* {{Rust|[1, 2, 3, 4, 5][..i]}}\n* {{Rust|\"Hello, world!\".as_bytes()}}\n* {{Rust|let v {{=}} vec![1, 2, 3]; v.as_slice()}}\n  }}\n|-\n|{{plainlist|{{Rust|(T, U, ..)}}}}\n|[[Tuple]] \u2013 a finite heterogeneous sequence\n|{{plainlist|\n* {{Rust|()}} (An empty tuple, the [[unit type]] in Rust)\n* {{Rust|(5,)}} ({{Rust|(5)}} is parsed as an integer)<ref>{{Cite web |title=Tuples |url=https://doc.rust-lang.org/rust-by-example/primitives/tuples.html |access-date=2023-10-01 |website=Rust By Example}}</ref>\n* {{Rust|(\"Age\", 10)}}\n* {{Rust|(1, true, \"Name\")}}\n  }}\n|-\n| {{Rust|!}}\n| [[Bottom type|Never type]] (unreachable value)\n| {{Rust|let x {{=}} { return 123 };}}\n|}\n\n==== Standard library ====\n{| class=\"wikitable\"\n|+Summary of Rust's types in the [[standard library]]\n!Type\n!Description\n!Examples\n|-\n|{{Rust|String}}\n|UTF-8-encoded strings (dynamic)\n|{{plainlist|\n* {{Rust|String::new()}}\n* {{Rust|String::from(\"Hello\")}}\n* {{Rust|\"\ud83e\udd80\ud83e\udd80\ud83e\udd80\".to_string()}}\n  }}\n|-\n|{{plainlist|\n* {{Rust|OsStr}}\n* {{Rust|OsString}}\n  }}\n|Platform-native strings<ref group=\"note\" name=\"OsString\">On Unix systems, this is often UTF-8 strings without an internal 0 byte. On Windows, this is [[UTF-16]] strings without an internal 0 byte. Unlike these, {{Rust|str}} and {{Rust|String}} are always valid UTF-8 and can contain internal zeros.</ref> (borrowed<ref>{{Cite web |title=OsStr in std::ffi \u2013 Rust |url=https://doc.rust-lang.org/beta/std/ffi/struct.OsStr.html |access-date=2023-10-02 |website=doc.rust-lang.org}}</ref> and dynamic<ref>{{Cite web |title=OsString in std::ffi \u2013 Rust |url=https://doc.rust-lang.org/beta/std/ffi/struct.OsString.html |access-date=2023-10-02 |website=doc.rust-lang.org}}</ref>)\n|{{plainlist|\n* {{Rust|OsStr::new(\"Hello\")}}\n* {{Rust|OsString::from(\"world\")}}\n  }}\n|-\n|{{plainlist|\n* {{Rust|Path}}\n* {{Rust|PathBuf}}\n  }}\n|[[Path (computing)|Paths]] (borrowed<ref>{{Cite web |title=Path in std::path \u2013 Rust |url=https://doc.rust-lang.org/beta/std/path/struct.Path.html |access-date=2023-10-02 |website=doc.rust-lang.org}}</ref> and dynamic<ref>{{Cite web |title=PathBuf in std::path \u2013 Rust |url=https://doc.rust-lang.org/beta/std/path/struct.PathBuf.html |access-date=2023-10-02 |website=doc.rust-lang.org}}</ref>)\n|{{plainlist|\n* {{Rust|Path::new(\"./path/to\")}}\n* {{Rust|PathBuf::from(r\"C:.\\path\\to\")}}\n  }}\n|-\n|{{plainlist|\n* {{Rust|CStr}}\n* {{Rust|CString}}\n  }}\n|[[C (programming language)|C]]-compatible, [[null-terminated string]]s (borrowed<ref name=\"std::boxed \u2013 Rust\">{{Cite web |title=std::boxed \u2013 Rust |url=https://doc.rust-lang.org/std/boxed/index.html |access-date=2023-06-23 |website=doc.rust-lang.org}}</ref> and dynamic<ref name=\"std::boxed \u2013 Rust\"/>)\n|{{plainlist|\n* {{Rust|CStr::from_bytes_with_nul(b\"Hello\\0\").unwrap()}}\n* {{Rust|CString::new(\"world\").unwrap()}}\n  }}\n|-\n|{{Rust|Vec<T>}}\n|[[Dynamic array]]s\n|{{plainlist|\n* {{Rust|Vec::new()}}\n* {{Rust|vec![1, 2, 3, 4, 5]}}\n  }}\n|-\n|{{Rust|Option<T>}}\n|[[Option type]]\n|{{plainlist|\n* {{Rust|None}}\n* {{Rust|Some(3)}}\n* {{Rust|Some(\"hello\")}}\n  }}\n|-\n|{{Rust|Result<T, E>}}\n|[[Exception handling|Error handling]] using a [[result type]]\n|{{plainlist|\n* {{Rust|Ok(3)}}\n* {{Rust|Err(\"something went wrong\")}}\n  }}\n|-\n|{{Rust|Box<T>}}\n|A pointer to a [[Heap (programming)|heap]]-allocated value<ref>{{Cite web |title=std::boxed \u2013 Rust |url=https://doc.rust-lang.org/std/boxed/index.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>. Similar to C++'s [https://en.cppreference.com/w/cpp/memory/unique_ptr std::unique_ptr].\n| <syntaxhighlight lang=\"rust\">\nlet boxed: Box<u8> = Box::new(5);\nlet val: u8 = *boxed;\n</syntaxhighlight>\n|-\n|{{Rust|Rc<T>}}\n|[[Reference counting]] pointer<ref>{{Cite web |title=Rc in std::rc \u2013 Rust |url=https://doc.rust-lang.org/beta/std/rc/struct.Rc.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet five = Rc::new(5);\nlet also_five = five.clone();\n</syntaxhighlight>\n|-\n|{{Rust|Arc<T>}}\n|[[Linearizability|Atomic]], [[Thread safety|thread-safe]] reference counting pointer<ref>{{Cite web |title=Arc in std::sync \u2013 Rust |url=https://doc.rust-lang.org/beta/std/sync/struct.Arc.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet foo = Arc::new(vec![1.0, 2.0]);\nlet a = foo.clone(); // a can be sent to another thread\n</syntaxhighlight>\n|-\n|{{Rust|Cell<T>}}\n|A mutable memory location<ref>{{Cite web |title=Cell in std::cell \u2013 Rust |url=https://doc.rust-lang.org/beta/std/cell/struct.Cell.html# |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet c = Cell::new(5);\nc.set(10);\n</syntaxhighlight>\n|-\n|<code>Mutex<T></code>\n|A [[Lock (computer science)|mutex lock]] for shared data contained within.<ref>{{Cite web |title=Mutex in std::sync \u2013 Rust |url=https://doc.rust-lang.org/beta/std/sync/struct.Mutex.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet mutex = Mutex::new(0_u32);\nlet _guard = mutex.lock();\n</syntaxhighlight>\n|-\n|{{Rust|RwLock<T>}}\n|[[Readers\u2013writer lock]]<ref>{{Cite web |title=RwLock in std::sync \u2013 Rust |url=https://doc.rust-lang.org/beta/std/sync/struct.RwLock.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet lock = RwLock::new(5);\nlet r1 = lock.read().unwrap();\n</syntaxhighlight>\n|-\n|{{Rust|Condvar}}\n|A [[Monitor (synchronization)|conditional monitor]] for shared data<ref>{{Cite web |title=Condvar in std::sync \u2013 Rust |url=https://doc.rust-lang.org/beta/std/sync/struct.Condvar.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\n let (lock, cvar) = (Mutex::new(true), Condvar::new());\n// As long as the value inside the `Mutex<bool>` is `true`, we wait.\nlet _guard = cvar.wait_while(lock.lock().unwrap(), |pending| { *pending }).unwrap();\n\n</syntaxhighlight>\n|-\n|{{Rust|Duration}}\n|Type that represents a span of time<ref>{{Cite web |title=Duration in std::time \u2013 Rust |url=https://doc.rust-lang.org/beta/std/time/struct.Duration.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nDuration::from_millis(1) // 1ms\n</syntaxhighlight>\n|-\n|{{Rust|1=HashMap<K, V>}}\n|[[Hash table]]<ref>{{Cite web |title=HashMap in std::collections \u2013 Rust |url=https://doc.rust-lang.org/beta/std/collections/struct.HashMap.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet mut player_stats = HashMap::new();\nplayer_stats.insert(\"damage\", 1);\nplayer_stats.entry(\"health\").or_insert(100);\n</syntaxhighlight>\n|-\n|{{Rust|1=BTreeMap<K, V>}}\n|[[B-tree]]<ref>{{Cite web |title=BTreeMap in std::collections \u2013 Rust |url=https://doc.rust-lang.org/beta/std/collections/struct.BTreeMap.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet mut solar_distance = BTreeMap::from([\n    (\"Mercury\", 0.4),\n    (\"Venus\", 0.7),\n]);\nsolar_distance.entry(\"Earth\").or_insert(1.0);\n\n</syntaxhighlight>\n|}\n\n[[Option type|<code>Option</code>]] values are handled using [[syntactic sugar]], such as the <code>if let</code> construction, to access the inner value (in this case, a string):{{sfn|McNamara|2021}}\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    let name1: Option<&str> = None;\n    // In this case, nothing will be printed out\n    if let Some(name) = name1 {\n        println!(\"{name}\");\n    }\n\n    let name2: Option<&str> = Some(\"Matthew\");\n    // In this case, the word \"Matthew\" will be printed out\n    if let Some(name) = name2 {\n        println!(\"{name}\");\n    }\n}\n</syntaxhighlight>\n\n==== Pointers ====\n{| class=\"wikitable\"\n|+Summary of Rust's [[Pointer (computer programming)|pointer]] and [[Reference (computer science)|reference]] primitive types\n!Type\n!Description\n!Examples\n|-\n|{{plainlist|\n* {{Rust|&T}}\n* {{Rust|&mut T}}\n  }}\n|[[Reference (computer science)|References]] (immutable and mutable)\n|{{plainlist|\n* {{Rust|let x_ref {{=}} {{not a typo|&x;}}}}\n* {{Rust|let x_ref {{=}} &mut x;}}\n  }}\n|-\n|{{plainlist|\n* {{Rust|Option<&T>}}\n* {{Rust|Option<&mut T>}}\n  }}\n|{{plainlist|\n* Option wrapped reference\n* Possibly null reference\n  }}\n|{{plainlist|\n* {{Rust|None}}\n* {{Rust|let x_ref {{=}} Some(&x);}}\n* {{Rust|let x_ref {{=}} Some(&mut x);}}\n  }}\n|-\n|{{Plain list|* {{Rust|Box<T>}}\n* {{Rust|Option<Box<T>>}}}}\n|A pointer to heap-allocated value\n(or possibly null pointer if wrapped in option)<ref name=\"std::boxed \u2013 Rust\"/>\n|{{Plain list|* {{Rust|let boxed {{=}} Box::new(0);}}\n* {{Rust|let boxed {{=}} Some(Box::new(\"Hello World\"));}}}}\n|-\n|{{Plainlist|\n* {{Rust|*const T}}\n* {{Rust|*mut T}}\n  }}\n|{{Plainlist|\n* Raw pointers (immutable and mutable)\n* Possibly [[Null pointer|null]]; {{Rust|unsafe}} to [[dereference]]\n  }}\n|{{Plainlist|\n* {{Rust|let x_ptr {{=}} &x as *const T;}}\n* {{Rust|let x_ptr {{=}} &mut x as *mut T;}}\n  }}\n|}\n\nRust does not use [[null pointer]]s to indicate a lack of data, as doing so can lead to [[Null pointer#Null dereferencing|null dereferencing]]. Accordingly, the basic <code>&</code> and <code>&mut</code> references are guaranteed to not be null. Rust instead uses <code>Option</code> for this purpose: <code>Some(T)</code> indicates that a value is present, and <code>None</code> is analogous to the null pointer.{{sfn|Klabnik|Nichols|2019|pp=101\u2013104}} <code>Option</code> implements a \"null pointer optimization\", avoiding any spatial overhead for types that cannot have a null value (references or the <code>NonZero</code> types, for example).<ref>{{Cite web |title=std::option - Rust |url=https://doc.rust-lang.org/std/option/index.html#representation |access-date=2023-11-12 |website=doc.rust-lang.org}}</ref>\n\nUnlike references, the raw pointer types <code>*const</code> and <code>*mut</code> may be null; however, it is impossible to dereference them unless the code is explicitly declared unsafe through the use of an <code>unsafe</code> block. Unlike dereferencing, the creation of raw pointers is allowed inside of safe Rust code.{{sfn|Klabnik|Nichols|2019|pp=418\u2013427}}\n\n==== User-defined types ====\nUser-defined types are created with the <code>struct</code> or <code>enum</code> keywords. The <code>struct</code> keyword is used to denote a [[Record (computer science)|record type]] that groups multiple related values.{{sfn|Klabnik|Nichols|2019|p=83}} <code>enum</code>s can take on different variants at runtime, with its capabilities similar to [[algebraic data types]] found in functional programming languages.{{sfn|Klabnik|Nichols|2019|p=97}} Both structs and enums can contain [[Field (computer science)|fields]] with different types.{{sfn|Klabnik|Nichols|2019|pp=98\u2013101}} Alternative names for the same type can be defined with the <code>type</code> keyword.{{sfn|Klabnik|Nichols|2019|pp=438\u2013440}}\n\nThe <code>impl</code> keyword can define methods for a user-defined type (data and functions are defined separately). Implementations fulfill a role similar to that of classes within other languages.{{sfn|Klabnik|Nichols|2019|pp=93}}\n\n==== Type conversion ====\n{{excerpt|Type conversion|Rust}}\n\n", "goals": ["The student will be able to define and use the following types:\n\n- [[Primitive data type|Primitive Types]]\n- [[Standard library]] types\n- [[User-defined types]]\n- [[Type conversion]]\n\nThe student will be able to:\n\n", "The student will be able to define and use the following types:\n\n- [[Primitive data type|Primitive Types]]\n- [[Standard library]] types\n- [[User-defined types]]\n- [[Type conversion]]\n\nThe student will be able to:\n\n-", "The student will be able to define and use the following types:\n\n- [[Primitive data type|Primitive Types]]\n- [[Standard library]] types\n- [[User-defined types]]\n- [[Type conversion]]\n\nThe student will be able to:\n\n-", "The student will be able to define and use the following types:\n\n- [[Primitive data type|Primitive Types]]\n- [[Standard library]] types\n- [[User-defined types]]\n- [[Type conversion]]\n\nThe student will be able to:\n\n-", "The student will be able to define and use the following types:\n\n- [[Primitive data type|Primitive Types]]\n- [[Standard library]] types\n- [[User-defined types]]\n- [[Type conversion]]\n\nThe student will be able to:\n\n-"]}, {"title": " Memory safety ", "content": "Rust is designed to be [[memory safe]]. It does not permit null pointers, [[dangling pointer]]s, or [[data race]]s.<ref name=\"cnet\">{{cite web |url=http://reviews.cnet.com/8301-3514_7-57577639/samsung-joins-mozillas-quest-for-rust/ |title=Samsung joins Mozilla's quest for Rust |last=Rosenblatt |first=Seth |date=2013-04-03 |publisher=[[CNET]] |access-date=2013-04-05 |archive-date=2013-04-04 |archive-url=https://web.archive.org/web/20130404142333/http://reviews.cnet.com/8301-3514_7-57577639/samsung-joins-mozillas-quest-for-rust/ |url-status=live}}</ref><ref name=\"lwn\">{{cite web |url=https://lwn.net/Articles/547145/ |title=A taste of Rust |last=Brown |first=Neil |date=2013-04-17 |access-date=2013-04-25 |archive-date=2013-04-26 |archive-url=https://web.archive.org/web/20130426010754/http://lwn.net/Articles/547145/ |url-status=live}}</ref><ref name=\"The Rustonomicon\">{{Cite web|url=https://doc.rust-lang.org/nomicon/races.html|title=Races \u2013 The Rustonomicon|website=doc.rust-lang.org|access-date=2017-07-03|archive-date=2017-07-10|archive-url=https://web.archive.org/web/20170710194643/https://doc.rust-lang.org/nomicon/races.html|url-status=live}}</ref> Data values can be initialized only through a fixed set of forms, all of which require their inputs to be already initialized.<ref name=\"lang-faq\">{{cite web  |title=The Rust Language FAQ |website=static.rust-lang.org |url=http://static.rust-lang.org/doc/master/complement-lang-faq.html |url-status=dead |archive-url=https://web.archive.org/web/20150420104147/http://static.rust-lang.org/doc/master/complement-lang-faq.html |archive-date=2015-04-20 |year=2015 |access-date=2017-04-24}}</ref>\n\nUnsafe code can subvert some of these restrictions, using the <code>unsafe</code> keyword.{{sfn|Klabnik|Nichols|2019|pp=418\u2013427}} Unsafe code may also be used for low-level functionality, such as [[Volatile (computer programming)|volatile memory access]], architecture-specific intrinsics, [[type punning]], and inline assembly.{{sfn|McNamara|2021|p=139, 376\u2013379, 395}}\n\n", "goals": ["The student will be able to define and use the concept of memory safety in Rust", "The student will be able to define and use the concept of dangling pointers in Rust", "The student will be able to define and use the concept of data races in Rust", "The student will be able to define and use the concept of null pointers in Rust", "The student will be able to define and use the concept of volatile memory access in Rust"]}, {"title": " Memory management ", "content": "Rust does not use [[garbage collection (computer science)|garbage collection]]. Memory and other resources are instead managed through the \"resource acquisition is initialization\" convention,<ref>{{Cite web|title=RAII \u2013 Rust By Example|url=https://doc.rust-lang.org/rust-by-example/scope/raii.html|access-date=2020-11-22|website=doc.rust-lang.org|archive-date=2019-04-21|archive-url=https://web.archive.org/web/20190421131142/https://doc.rust-lang.org/rust-by-example/scope/raii.html|url-status=live}}</ref> with optional [[reference counting]]. Rust provides deterministic management of resources, with very low [[Overhead (computing)|overhead]].<ref>{{Cite web|url=https://blog.rust-lang.org/2015/05/11/traits.html|title=Abstraction without overhead: traits in Rust|website=Rust Blog|access-date=October 19, 2021|archive-date=September 23, 2021|archive-url=https://web.archive.org/web/20210923101530/https://blog.rust-lang.org/2015/05/11/traits.html|url-status=live}}</ref> Values are [[Stack-based memory allocation|allocated on the stack]] by default, and all [[dynamic allocation]]s must be explicit.<ref>{{Cite web |title=Box, stack and heap |url=https://doc.rust-lang.org/stable/rust-by-example/std/box.html |access-date=2022-06-13 |website=Rust By Example}}</ref>\n\nThe built-in reference types using the <code>&</code> symbol do not involve run-time reference counting. The safety and validity of the underlying pointers is verified at compile time, preventing [[dangling pointers]] and other forms of [[undefined behavior]].{{sfn|Klabnik|Nichols|2019|pp=70\u201375}} Rust's type system separates shared, [[Immutable object|immutable]] references of the form <code>&T</code> from unique, mutable references of the form <code>&mut T</code>. A mutable reference can be coerced to an immutable reference, but not vice versa.{{sfn|Klabnik|Nichols|2019|p=323}}\n\n", "goals": ["The student will be able to identify and understand the concept of Rust's resource management, including the ", "The student will be able to identify and understand the concept of Rust's resource management, including the ", "The student will be able to identify and understand the concept of Rust's resource management, including the ", "The student will be able to identify and understand the concept of Rust's resource management, including the ", "The student will be able to identify and understand the concept of Rust's resource management, including the "]}, {"title": " Iterators ", "content": "[[For loop]]s in Rust work in a functional style as operations over an [[iterator]] type. For example, in the loop\n\n<syntaxhighlight lang=\"rust\">\nfor x in 0..100 {\n   f(x);\n}\n</syntaxhighlight>\n\n<code>0..100</code> is a value of type <code>Range</code> which implements the <code>Iterator</code> trait; the code applies the function <code>f</code> to each element returned by the iterator. Iterators can be combined with functions over iterators like <code>map</code>, <code>filter</code>, and <code>sum</code>. For example, the following adds up all numbers between 1 and 100 that are multiples of 3:\n\n<syntaxhighlight lang=\"rust\">\n(1..=100).filter(|&x| x % 3 == 0).sum()\n</syntaxhighlight>\n\n", "goals": ["The student will be able to use the for loop in Rust to iterate over a range of numbers and perform operations on each number", "The student will be able to use the map function in Rust to apply a function to each element of an iterator", "The student will be able to use the filter function in Rust to filter an iterator based on a condition", "The student will be able to use the sum function in Rust to calculate the sum of the elements of an iterator", "The student will be able to use the range function in Rust to create an iterator of numbers between a start and end value"]}, {"title": " Macros ", "content": "It is possible to extend the Rust language using macros.\n\n==== Declarative macros ====\nA declarative macro (also called a \"macro by example\") is a macro that uses pattern matching to determine its expansion.<ref name=\"Rust Ref. \u2013 Macros By Example\">{{cite web |title=Macros By Example |url=https://doc.rust-lang.org/reference/macros-by-example.html |archive-url= |archive-date= |url-status= |website=The Rust Reference |access-date=21 April 2023}}</ref>{{sfn|Klabnik|Nichols|2019|pp=446\u2013448}}\n\n==== Procedural macros ====\nProcedural macros are Rust functions that run and modify the compiler's input [[Token (parser)|token]] stream, before any other components are compiled. They are generally more flexible than declarative macros, but are more difficult to maintain due to their complexity.<ref name=\"rust-procedural-macros\">{{cite web |url=https://doc.rust-lang.org/reference/procedural-macros.html |title=Procedural Macros |website=The Rust Programming Language Reference |access-date=23 Mar 2021 |archive-date=7 November 2020 |archive-url=https://web.archive.org/web/20201107233444/https://doc.rust-lang.org/reference/procedural-macros.html |url-status=live}}</ref>{{sfn|Klabnik|Nichols|2019|pp=449\u2013455}}\n\nProcedural macros come in three flavors:\n* Function-like macros <code>custom!(...)</code>\n* Derive macros <code>#[derive(CustomDerive)]</code>\n* Attribute macros <code>#[custom_attribute]</code>\n\nThe <code>println!</code> macro is an example of a function-like macro. The<code>serde_derive</code> macro<ref>{{cite web|url=https://serde.rs/derive.html|title=Serde Derive|website=Serde Derive documentation|access-date=23 Mar 2021|archive-date=17 April 2021|archive-url=https://web.archive.org/web/20210417114849/https://serde.rs/derive.html|url-status=live}}</ref> provides a commonly used library for generating code\nfor reading and writing data in many formats, such as [[JSON]]. Attribute macros are commonly used for language bindings, such as the <code>extendr</code> library for Rust bindings to [[R (programming language)|R]].<ref>{{cite web|url=https://extendr.github.io/extendr/extendr_api/index.html|title=extendr_api \u2013 Rust|website=Extendr Api Documentation|access-date=23 Mar 2021|archive-date=May 25, 2021|archive-url=https://web.archive.org/web/20210525082129/https://extendr.github.io/extendr/extendr_api/index.html|url-status=live}}</ref>\n\nThe following code shows the use of the <code>Serialize</code>, <code>Deserialize</code>, and <code>Debug</code>-derived procedural macros\nto implement JSON reading and writing, as well as the ability to format a structure for debugging.\n[[File:Rust serde UML diagram.svg|thumb|A [[UML diagram]] depicting a Rust struct named Point.]]\n<syntaxhighlight lang=\"rust\">\nuse serde_json::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let point = Point { x: 1, y: 2 };\n\n    let serialized = serde_json::to_string(&point).unwrap();\n    println!(\"serialized = {}\", serialized);\n\n    let deserialized: Point = serde_json::from_str(&serialized).unwrap();\n    println!(\"deserialized = {:?}\", deserialized);\n}\n</syntaxhighlight>\n\n==== Variadic macros ====\n{{excerpt|Variadic function|In Rust|subsections=yes}}\n\n", "goals": ["The student will be able to define and use variadic macros in Rust", "The student will be able to define and use procedural macros in Rust", "The student will be able to define and use attribute macros in Rust", "The student will be able to define and use function-like macros in Rust", "The student will be able to define and use derive macros in Rust"]}, {"title": " Compiler ", "content": "The Rust compiler is named <code>rustc</code>, and translates Rust code into a low level language called LLVM intermediate representation (LLVM IR). LLVM is then invoked as a subcomponent to translate IR code into [[machine code]]. A [[Linker (computing)|linker]] is then used to combine multiple crates together as a single executable or binary file.{{sfn|McNamara|2021|pp=411-412}}<ref>{{Cite web |title=Overview of the compiler |url=https://rustc-dev-guide.rust-lang.org/overview.html |access-date=2023-06-02 |website=Rust Compiler Development Guide}}</ref>\n\nOther than LLVM, the compiler also supports using alternative backends such as [[GNU Compiler Collection|GCC]] and [[Cranelift]] for code generation.<ref>{{cite web |title=Code Generation - Rust Compiler Development Guide |url=https://rustc-dev-guide.rust-lang.org/backend/codegen.html |website=rustc-dev-guide.rust-lang.org |access-date=3 March 2024}}</ref> The intention of those alternative backends is to increase platform coverage of Rust or to improve compilation times.<ref>{{cite web |title=rust-lang/rustc_codegen_gcc |url=https://github.com/rust-lang/rustc_codegen_gcc#Motivation |website=GitHub |publisher=The Rust Programming Language |access-date=3 March 2024 |date=2 March 2024}}</ref><ref>{{cite web |title=rust-lang/rustc_codegen_cranelift |url=https://github.com/rust-lang/rustc_codegen_cranelift |website=GitHub |publisher=The Rust Programming Language |access-date=3 March 2024 |date=2 March 2024}}</ref>\n\n", "goals": ["The student will be able to explain the role of the Rust compiler in translating Rust code into a low-level language called LLVM intermediate representation (LLVM IR)", "The student will be able to explain the role of the LLVM in translating IR code into machine code", "The student will be able to explain the role of the linker in combining multiple crates together as a single executable or binary file", "The student will be able to explain the role of alternative backends such as GCC and Cranelift in increasing platform coverage of Rust or improving compilation times", "The student will be able to explain the role of the Rust compiler in translating Rust code into a low-level language called LLVM intermediate representation (LLVM IR)"]}, {"title": " Rustfmt ", "content": "Rustfmt is a [[code formatter]] for Rust. It formats whitespace and [[Indentation style|indentation]] to produce code in accordance with a common [[Programming style|style]], unless otherwise specified. It can be invoked as a standalone program, or from a Rust project through Cargo.{{sfn|Klabnik|Nichols|2019|pp=511\u2013512}}\n\n[[File:Cargo clippy hello world example.png|thumb|right|Example output of Clippy on a hello world Rust program]]\n\n", "goals": ["The student will be able to identify and understand the purpose of Rustfmt and its role in maintaining a consistent style in Rust programming", "The student will be able to describe and apply the process of using Rustfmt to format Rust code, including invoking it as a standalone program or from a Rust project through Cargo", "The student will be able to explain and apply the concept of Rustfmt's ability to format whitespace and indentation to produce code in accordance with a common style, and understand the importance of maintaining a consistent style in Rust programming", "The student will be able to describe and apply the concept of Rustfmt's ability to be invoked as a standalone program or from a Rust project through Cargo, and understand the importance of using Rustfmt to maintain a consistent style in Rust programming", "The student will be able to describe and apply the concept of Rustfmt's ability to format whitespace and indentation to produce code in accordance with a common style, and understand the importance of using Rustfmt to maintain a consistent style in Rust programming"]}]}