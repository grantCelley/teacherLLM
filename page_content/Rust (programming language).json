{"id": 29414838, "key": "Rust_(programming_language)", "title": "Rust (programming language)", "latest": {"id": 1217258267, "timestamp": "2024-04-04T19:21:19Z"}, "content_model": "wikitext", "license": {"url": "https://creativecommons.org/licenses/by-sa/4.0/deed.en", "title": "Creative Commons Attribution-Share Alike 4.0"}, "source": "{{Short description|General-purpose programming language}}\n{{Good article}}\n{{Use American English|date=July 2022}}\n{{Use mdy dates|date=July 2022|cs1-dates=y}}\n{{Infobox programming language\n| name = Rust\n| logo = Rust programming language black logo.svg\n| logo alt = Rust logo; a capital letter R set into a sprocket\n| paradigms = {{cslist|\n  [[Concurrent computing|Concurrent]]|\n  [[Functional programming|functional]]|\n  [[Generic programming|generic]]|\n  [[Imperative programming|imperative]]|\n  [[Structured programming|structured]]|\n}}\n| released = {{Start date and age|2015|05|15}}\n| developer = [[Rust Foundation]]\n| latest release version = {{wikidata|property|edit|reference|P548=Q2804309|P348}}\n| latest release date = {{start date and age|{{wikidata|qualifier|mdy|P548=Q2804309|P348|P577}}}}\n| typing = {{cslist|\n  [[Affine type system|Affine]]|\n  [[Type inference|inferred]]|\n  [[Nominal type system|nominal]]|\n  [[Static typing|static]]|\n  [[Strong and weak typing|strong]]|\n}}\n| programming language = Rust\n| platform = [[Cross-platform software|Cross-platform]]{{refn|group=note|Including build tools, host tools, and standard library support for [[x86-64]], [[ARM architecture family|ARM]], [[MIPS architecture|MIPS]], [[RISC-V]], [[WebAssembly]], [[P6 (microarchitecture)|i686]], [[AArch64]], [[PowerPC]], and [[Linux on IBM Z|s390x]].<ref name=CrossPlatform>{{Cite web |title=Platform Support |website=The rustc book |url=https://doc.rust-lang.org/rustc/platform-support.html |access-date=2022-06-27}}</ref>}}\n| operating system = [[Cross-platform software|Cross-platform]]{{refn|group=note|Including [[Windows]], [[Linux]], [[macOS]], [[FreeBSD]], [[NetBSD]], and [[Illumos]]. Host build tools on [[Android (operating system)|Android]], [[iOS]], [[Haiku (operating system)|Haiku]], [[Redox (operating system)|Redox]], and [[Fuchsia (operating system)|Fuchsia]] are not officially shipped; these operating systems are supported as targets.<ref name=\"CrossPlatform\" />}}\n| license = [[MIT License|MIT]] and [[Apache License|Apache 2.0]]{{refn|group=note|Third-party dependencies, e.g., [[LLVM]] or [[MSVC]], are subject to their own licenses.<ref>{{cite web |title=The Rust Programming Language |url=https://github.com/rust-lang/rust/blob/master/COPYRIGHT |publisher=The Rust Programming Language |date=19 October 2022}}</ref><ref name=\"legal\" />}}\n| file ext = <code>.rs</code>, <code>.rlib</code>\n| influenced by = {{cslist|\n  [[Alef (programming language)|Alef]]<ref name=\"influences\" />|\n  [[C Sharp (programming language)|C#]]<ref name=\"influences\" />|\n  [[C++]]<ref name=\"influences\" />|\n  [[Cyclone (programming language)|Cyclone]]<ref name=\"influences\" />|\n  [[Elm (programming language)|Elm]]<ref>{{Cite web |title=Uniqueness Types |url=https://blog.rust-lang.org/2016/08/10/Shape-of-errors-to-come.html |access-date=2016-10-08 |website= Rust Blog |quote=\"Those of you familiar with the Elm style may recognize that the updated {{mono|--explain}} messages draw heavy inspiration from the Elm approach.\"}}</ref>|\n  [[Erlang (programming language)|Erlang]]<ref name=\"influences\" />|\n  [[Haskell]]<ref name=\"influences\" />|\n  [[Limbo (programming language)|Limbo]]<ref name=\"influences\" />|\n  [[Newsqueak]]<ref name=\"influences\" />|\n  [[OCaml]]<ref name=\"influences\" />|\n  [[Ruby (programming language)|Ruby]]<ref name=\"influences\" />|\n  [[Scheme (programming language)|Scheme]]<ref name=\"influences\" />|\n  [[Standard ML]]<ref name=\"influences\" />|\n  [[Swift (programming language)|Swift]]<ref name=\"influences\" />\n}}\n| influenced = {{cslist|\n  [[Idris (programming language)|Idris]]<ref>{{Cite web |title=Uniqueness Types |url=http://docs.idris-lang.org/en/latest/reference/uniqueness-types.html |access-date=2022-07-14 |website=Idris 1.3.3 documentation |quote=\"They are inspired by ... ownership types and borrowed pointers in the Rust programming language.\"}}</ref>|\n  <!-- The article was deleted -- can be reinstated in the future if the article topic is deemed notable\n  [[Mojo (programming language)|Mojo]]<ref>{{Cite web |last=Claburn |first=Thomas |title=Modular reveals Mojo, Python superset with C-level speed |url=https://www.theregister.com/2023/05/05/modular_struts_its_mojo_a/ |access-date=2023-05-13 |website=The Register |language=en}}</ref>|\n  -->\n  [[Project Verona]]<ref name=\"Project Verona\" />|\n  [[SPARK (programming language)|Spark]]<ref name=\"Jaloyan\" />|\n  [[Swift (programming language)|Swift]]<ref name=\"Lattner\" />|\n  [[V (programming language)|V]]<ref>{{Cite web |title=V documentation (Introduction) |url=https://github.com/vlang/v/blob/master/doc/docs.md#introduction |access-date=2023-11-04|website=GitHub |language=en}}</ref>|\n  [[Zig (programming language)|Zig]]<ref>{{Cite web |last=Yegulalp |first=Serdar |date=2016-08-29 |title=New challenger joins Rust to topple C language |url=https://www.infoworld.com/article/3113083/new-challenger-joins-rust-to-upend-c-language.html |access-date=2022-10-19 |website=InfoWorld |language=en}}</ref>|\n}}\n}}\n\n'''Rust''' is a [[Programming paradigm|multi-paradigm]], [[general-purpose programming language]] that emphasizes [[computer performance|performance]], [[type safety]], and [[Concurrency (computer science)|concurrency]]. It enforces [[memory safety]]\u2014meaning that all [[reference (computer science)|references]] point to valid memory\u2014without a [[garbage collection (computer science)|garbage collector]]. To simultaneously enforce memory safety and prevent [[data race]]s, its \"borrow checker\" tracks the [[object lifetime]] of all references in a program during [[Compilation (computing)|compilation]]. Rust was influenced by ideas from [[functional programming]], including [[Immutable object|immutability]], [[higher-order function]]s, and [[algebraic data type]]s. It is popular for [[systems programming]].<ref>{{Cite book |last=Eshwarla |first=Prabhu |url=https://books.google.com/books?id=eEUREAAAQBAJ |title=Practical System Programming for Rust Developers: Build fast and secure software for Linux/Unix systems with the help of practical examples |date=2020-12-24 |publisher=Packt Publishing Ltd |isbn=978-1-80056-201-1 |language=en}}</ref><ref>{{Cite book |last1=Blandy |first1=Jim |url=https://books.google.com/books?id=h8c_DwAAQBAJ |title=Programming Rust: Fast, Safe Systems Development |last2=Orendorff |first2=Jason |date=2017-11-21 |publisher=O'Reilly Media, Inc. |isbn=978-1-4919-2725-0 |language=en}}</ref><ref>{{Cite journal |last1=Blanco-Cuaresma |first1=Sergi |last2=Bolmont |first2=Emeline |date=2017-05-30 |title=What can the programming language Rust do for astrophysics? |url=https://www.cambridge.org/core/journals/proceedings-of-the-international-astronomical-union/article/what-can-the-programming-language-rust-do-for-astrophysics/B51B6DF72B7641F2352C05A502F3D881 |journal=Proceedings of the International Astronomical Union |language=en |volume=12 |issue=S325 |pages=341\u2013344 |doi=10.1017/S1743921316013168 |arxiv=1702.02951 |bibcode=2017IAUS..325..341B |s2cid=7857871 |issn=1743-9213}}</ref>\n\nSoftware developer Graydon Hoare created Rust as a personal project while working at [[Mozilla]] Research in 2006. Mozilla officially sponsored the project in 2009. In the years following the first stable release in May 2015, Rust was adopted by companies including [[Amazon (company)|Amazon]], [[Discord]], [[Dropbox]], [[Google]] ([[Alphabet Inc.|Alphabet]]), [[Meta Platforms|Meta]], and [[Microsoft]]. In December 2022, it became the first language other than [[C (programming language)|C]] and [[Assembly language|assembly]] to be supported in the development of the [[Linux kernel]].\n\nRust has been noted for its rapid adoption,<ref name=\"Nature\">{{Cite journal |last=Perkel |first=Jeffrey M. |date=2020-12-01 |title=Why scientists are turning to Rust |url=https://www.nature.com/articles/d41586-020-03382-2 |journal=[[Nature (journal)|Nature]] |language=en |volume=588 |issue=7836 |pages=185\u2013186 |doi=10.1038/d41586-020-03382-2 |pmid=33262490 |bibcode=2020Natur.588..185P |s2cid=227251258 |access-date=May 15, 2022 |archive-date=May 6, 2022 |archive-url=https://web.archive.org/web/20220506040523/https://www.nature.com/articles/d41586-020-03382-2 |url-status=live}}</ref> and has been studied in [[programming language theory]] research.<ref>{{Cite web |title=Computer Scientist proves safety claims of the programming language Rust |url=https://www.eurekalert.org/news-releases/610682 |access-date=2022-05-15 |website=EurekAlert! |language=en |archive-date=February 24, 2022 |archive-url=https://web.archive.org/web/20220224160140/https://www.eurekalert.org/news-releases/610682 |url-status=live}}</ref><ref>{{Cite journal |last1=Jung |first1=Ralf |last2=Jourdan |first2=Jacques-Henri |last3=Krebbers |first3=Robbert |last4=Dreyer |first4=Derek |date=2017-12-27 |title=RustBelt: securing the foundations of the Rust programming language |url=https://doi.org/10.1145/3158154 |journal=Proceedings of the ACM on Programming Languages |volume=2 |issue=POPL |pages=66:1\u201366:34 |doi=10.1145/3158154 |s2cid=215791659 |access-date=May 15, 2022 |archive-date=June 11, 2022 |archive-url=https://web.archive.org/web/20220611034059/https://dl.acm.org/doi/10.1145/3158154 |url-status=live|doi-access=free |hdl=21.11116/0000-0003-34C6-3 |hdl-access=free }}</ref><ref>{{Cite thesis |last=Jung |first=Ralf |year=2020 |title=Understanding and evolving the Rust programming language |url=https://publikationen.sulb.uni-saarland.de/handle/20.500.11880/29647 |language=en |doi=10.22028/D291-31946 |access-date=May 15, 2022 |archive-date=March 8, 2022 |archive-url=https://web.archive.org/web/20220308050018/https://publikationen.sulb.uni-saarland.de/handle/20.500.11880/29647 |url-status=live |degree=PhD |publisher=[[Saarland University]]}}</ref>\n\n== History ==\n[[File:MozillaCaliforniaHeadquarters.JPG|thumb|right|Mozilla Foundation headquarters in [[Mountain View, California]]]]\n\n=== Origins (2006\u20132012) ===\nRust grew out of a personal project begun in 2006 by [[Mozilla]] Research employee Graydon Hoare.<ref name=\"MITTechReview\">{{cite web |url=https://www.technologyreview.com/2023/02/14/1067869/rust-worlds-fastest-growing-programming-language/ |title=How Rust went from a side project to the world's most-loved programming language |last=Thompson |first=Clive |date=2023-02-14 |website=MIT Technology Review |archive-url= |archive-date= |language=en |access-date=2023-02-23}}</ref> Mozilla began sponsoring the project in 2009 as a part of the ongoing development of an experimental [[browser engine]] called [[Servo (software)|Servo]],<ref name=\"infoq2012\">{{cite web |last=Avram |first=Abel |date=2012-08-03 |title=Interview on Rust, a Systems Programming Language Developed by Mozilla |url=http://www.infoq.com/news/2012/08/Interview-Rust |url-status=live |archive-url=https://web.archive.org/web/20130724045852/http://www.infoq.com/news/2012/08/Interview-Rust |archive-date=2013-07-24 |access-date=2013-08-17 |publisher=InfoQ}}</ref> which was officially announced by Mozilla in 2010.<ref name=\"MattAsay\">{{Cite web |last=Asay |first=Matt |date=2021-04-12 |title=Rust, not Firefox, is Mozilla's greatest industry contribution |url=https://www.techrepublic.com/article/rust-not-firefox-is-mozillas-greatest-industry-contribution/ |access-date=2022-07-07 |website=TechRepublic |language=en-US}}</ref><ref>{{cite conference |last=Hoare |first=Graydon |title=Project Servo |conference=Mozilla Annual Summit 2010 |date=7 July 2010 |location=Whistler, Canada |url=http://venge.net/graydon/talks/intro-talk-2.pdf |access-date=22 February 2017 |archive-date=11 July 2017 |archive-url=https://web.archive.org/web/20170711131514/http://venge.net/graydon/talks/intro-talk-2.pdf |url-status=live}}</ref> Rust's memory and ownership system was influenced by [[region-based memory management]] in languages such as [[Cyclone (programming language)|Cyclone]] and ML Kit.<ref name=\"influences\" />\n\nAround the same time, work shifted from the initial [[compiler]] written in [[OCaml]] to a [[Self-hosting (compilers)|self-hosting compiler]] based on [[LLVM]] written in Rust. The new Rust compiler successfully [[Bootstrapping (compilers)|compiled itself]] in 2011.<ref name=\"infoq2012\"/>{{Better source needed|date=March 2024}} In the fall of 2011, the Rust logo was developed based on a bicycle [[chainring]].<ref>{{cite web |title=Rust logo |url=https://bugzilla.mozilla.org/show_bug.cgi?id=680521 |website=bugzilla.mozilla.org |access-date=2 February 2024}}</ref> \n\n=== Evolution (2012\u20132020) ===\n\nRust's [[type system]] underwent significant changes between versions 0.2, 0.3, and 0.4. In version 0.2, which was released in March 2012, [[Class (computer programming)|classes]] were introduced for the first time.<ref>{{Cite web |last=Hoare |first=Graydon |date=2012-03-29 |title=[rust-dev] Rust 0.2 released |url=https://mail.mozilla.org/pipermail/rust-dev/2012-March/001511.html |access-date=2024-04-04 |archive-date=2022-11-06 |archive-url=https://web.archive.org/web/20221106041420/https://mail.mozilla.org/pipermail/rust-dev/2012-March/001511.html |website=mail.mozilla.org}}</ref> Four months later, version 0.3 added [[destructor (computer programming)|destructor]]s and [[Polymorphism (computer science)|polymorphism]], through the use of interfaces.<ref>{{Cite web |last=Hoare |first=Graydon |date=2012-07-12 |title=[rust-dev] Rust 0.3 released |url=https://mail.mozilla.org/pipermail/rust-dev/2012-July/002087.html |access-date=2022-06-12 |website=mail.mozilla.org |archive-date=2022-08-24  |archive-url=https://web.archive.org/web/20220824145952/https://mail.mozilla.org/pipermail/rust-dev/2012-July/002087.html |url-status=dead }}</ref> In October 2012, version 0.4 was released, which added [[Trait (computer programming)|traits]] as a means of [[Inheritance (object-oriented programming)|inheritance]]. Interfaces were combined with traits and removed as a separate feature; and classes were replaced by a combination of implementations and [[record (computer science)|structured types]].<ref>{{cite web |last=Hoare |first=Graydon |title=[rust-dev] Rust 0.4 released |url=https://mail.mozilla.org/pipermail/rust-dev/2012-October/002489.html |url-status=live |archive-url=https://web.archive.org/web/20211031130755/https://mail.mozilla.org/pipermail/rust-dev/2012-October/002489.html |archive-date=October 31, 2021 |access-date=2021-10-31 |website=mail.mozilla.org|date=October 15, 2012 }}</ref>\n\nThrough the early 2010s, memory management through the ownership system was gradually consolidated to prevent memory bugs. By 2013, Rust's [[garbage collection (computer science)|garbage collector]] was removed, with the ownership rules in place.<ref name=\"MITTechReview\"/>\n\nIn January 2014, the editor-in-chief of ''[[Dr. Dobb's Journal]]'', Andrew Binstock, commented on Rust's chances of becoming a competitor to [[C++]], along with [[D (programming language)|D]], [[Go (programming language)|Go]], and [[Nim (programming language)|Nim]] (then Nimrod). According to Binstock, while Rust was \"widely viewed as a remarkably elegant language\", adoption slowed because it radically changed from version to version.<ref>{{cite news |last=Binstock |first=Andrew |date=January 7, 2014 |title=The Rise And Fall of Languages in 2013 |website=[[Dr. Dobb's Journal]] |url=https://www.drdobbs.com/jvm/the-rise-and-fall-of-languages-in-2013/240165192 |url-status=live |archive-url=https://web.archive.org/web/20160807075745/http://www.drdobbs.com/jvm/the-rise-and-fall-of-languages-in-2013/240165192 |archive-date=2016-08-07 |access-date=2022-11-20}}</ref> The first [[stable release]], Rust 1.0, was announced on May 15, 2015.<ref name=\"Version history\">{{cite web |title=Version History |website=[[GitHub]] |url=https://github.com/rust-lang/rust/blob/master/RELEASES.md |access-date=2017-01-01 |archive-date=2015-05-15 |archive-url=https://web.archive.org/web/20150515221302/https://github.com/rust-lang/rust/blob/master/RELEASES.md |url-status=live}}</ref><ref>{{cite web |url=http://blog.rust-lang.org/2015/05/15/Rust-1.0.html |title=Announcing Rust 1.0 |website=Rust Blog |author=The Rust Core Team |date=May 15, 2015 |access-date=2015-12-11 |archive-date=2015-05-15 |archive-url=https://web.archive.org/web/20150515171337/http://blog.rust-lang.org/2015/05/15/Rust-1.0.html |url-status=live}}</ref>\n\nThe development of the Servo browser engine continued alongside Rust's own growth. In September 2017, Firefox 57 was released as the first version that incorporated components from Servo, in a project named \"[[Firefox Quantum]]\".<ref>{{Cite web |last=Lardinois |first=Frederic |date=2017-09-29 |title=It's time to give Firefox another chance |url=https://techcrunch.com/2017/09/29/its-time-to-give-firefox-another-chance/ |access-date=2023-08-15 |website=TechCrunch |language=en-US}}</ref>\n\n=== Mozilla layoffs and Rust Foundation (2020\u2013present) ===\nIn August 2020, Mozilla laid off 250 of its 1,000 employees worldwide, as part of a corporate restructuring caused by the [[COVID-19 pandemic]].<ref>{{cite web |url=https://www.zdnet.com/article/mozilla-lays-off-250-employees-while-it-refocuses-on-commercial-products/ |title=Mozilla lays off 250 employees while it refocuses on commercial products |last=Cimpanu |first=Catalin |publisher=[[ZDNet]] |access-date=2020-12-02 |date=2020-08-11 |archive-date=March 18, 2022 |archive-url=https://web.archive.org/web/20220318025804/https://www.zdnet.com/article/mozilla-lays-off-250-employees-while-it-refocuses-on-commercial-products/ |url-status=live}}</ref><ref>{{cite web |url=https://www.engadget.com/mozilla-firefox-250-employees-layoffs-151324924.html |title=Mozilla lays off 250 employees due to the pandemic |website=[[Engadget]] |last=Cooper |first=Daniel |access-date=2020-12-02 |date=2020-08-11 |archive-date=2020-12-13 |archive-url=https://web.archive.org/web/20201213020220/https://www.engadget.com/mozilla-firefox-250-employees-layoffs-151324924.html |url-status=live}}</ref> The team behind Servo was disbanded. The event raised concerns about the future of Rust, as some members of the team were active contributors to Rust.<ref>{{Cite web |last=Tung |first=Liam |title=Programming language Rust: Mozilla job cuts have hit us badly but here's how we'll survive |url=https://www.zdnet.com/article/programming-language-rust-mozilla-job-cuts-have-hit-us-badly-but-heres-how-well-survive/ |access-date=2022-04-21 |publisher=ZDNet |language=en |archive-date=April 21, 2022 |archive-url=https://web.archive.org/web/20220421083509/https://www.zdnet.com/article/programming-language-rust-mozilla-job-cuts-have-hit-us-badly-but-heres-how-well-survive/ |url-status=live}}</ref> In the following week, the Rust Core Team acknowledged the severe impact of the layoffs and announced that plans for a Rust foundation were underway. The first goal of the foundation would be to take ownership of all [[trademark]]s and [[domain name]]s, and take financial responsibility for their costs.<ref>{{cite web |url=https://blog.rust-lang.org/2020/08/18/laying-the-foundation-for-rusts-future.html |title=Laying the foundation for Rust's future |website=Rust Blog |access-date=2020-12-02 |date=2020-08-18 |archive-date=2020-12-02 |archive-url=https://web.archive.org/web/20201202022933/https://blog.rust-lang.org/2020/08/18/laying-the-foundation-for-rusts-future.html |url-status=live}}</ref>\n\nOn February 8, 2021, the formation of the [[#Rust Foundation|Rust Foundation]] was announced by its five founding companies ([[Amazon Web Services|AWS]], [[Huawei]], [[Google]], [[Microsoft]], and [[Mozilla]]).<ref>{{Cite web |date=2020-02-08 |title=Hello World! |url=https://foundation.rust-lang.org/news/2021-02-08-hello-world/ |access-date=2022-06-04 |website=Rust Foundation |language=en |archive-date=April 19, 2022 |archive-url=https://web.archive.org/web/20220419124635/https://foundation.rust-lang.org/news/2021-02-08-hello-world/ |url-status=live}}</ref><ref>{{Cite web|date=2021-02-09|title=Mozilla Welcomes the Rust Foundation |website=Mozilla Blog |url=https://blog.mozilla.org/blog/2021/02/08/mozilla-welcomes-the-rust-foundation |archive-url=https://web.archive.org/web/20210208212031/https://blog.mozilla.org/blog/2021/02/08/mozilla-welcomes-the-rust-foundation/|archive-date=2021-02-08|access-date=2021-02-09|url-status=live}}</ref> In a [[blog]] post published on April 6, 2021, Google announced support for Rust within the [[Android Open Source Project]] as an alternative to C/C++.<ref>{{Cite web|last=Amadeo|first=Ron|date=2021-04-07 |title=Google is now writing low-level Android code in Rust |url=https://arstechnica.com/gadgets/2021/04/google-is-now-writing-low-level-android-code-in-rust/ |access-date=2021-04-08|website=Ars Technica|language=en-us|archive-date=2021-04-08|archive-url=https://web.archive.org/web/20210408001446/https://arstechnica.com/gadgets/2021/04/google-is-now-writing-low-level-android-code-in-rust/|url-status=live}}</ref>\n\nOn November 22, 2021, the Moderation Team, which was responsible for enforcing community standards and the Code of Conduct, announced their resignation \"in protest of the Core Team placing themselves unaccountable to anyone but themselves\".<ref name=\"moderation\">{{Cite web |first=Tim |last=Anderson |title=Entire Rust moderation team resigns |url=https://www.theregister.com/2021/11/23/rust_moderation_team_quits/ |date=2021-11-23 |access-date=2022-08-04 |website=[[The Register]] |language=en}}</ref> In May 2022, the Rust Core Team, other lead programmers, and certain members of the Rust Foundation board implemented governance reforms in response to the incident.<ref>{{Cite web |title=Governance Update |url=https://blog.rust-lang.org/inside-rust/2022/05/19/governance-update.html |access-date=2022-10-27 |website=Inside Rust Blog |language=en}}</ref>\n\nThe Rust Foundation posted a draft for a new [[trademark]] policy on April 6, 2023, revising its rules on how the Rust logo and name can be used, which resulted in negative reactions from Rust users and contributors.<ref>{{Cite web |last=Claburn |first=Thomas |title=Rust Foundation apologizes for trademark policy confusion |date=2023-04-17 |url=https://www.theregister.com/2023/04/17/rust_foundation_apologizes_trademark_policy/ |access-date=2023-05-07 |website=The Register |language=en}}</ref>\n\n== Syntax and features ==\nRust's [[Syntax (programming languages)|syntax]] is similar to that of [[C (programming language)|C]] and C++,<ref>{{Cite web |last=Proven |first=Liam |date=2019-11-27 |title=Rebecca Rumbul named new CEO of The Rust Foundation |url=https://www.theregister.com/2021/11/19/rust_foundation_ceo/ |access-date=2022-07-14 |website=The Register |language=en |quote=\"Both are curly bracket languages, with C-like syntax that makes them unintimidating for C programmers.\"}}</ref><ref name=\":4\" /> although many of its features were influenced by [[functional programming]] languages.{{sfn|Klabnik|Nichols|2019|p=263}} Hoare described Rust as targeted at \"frustrated C++ developers\" and emphasized features such as safety, control of [[memory map|memory layout]], and [[Concurrency (computer science)|concurrency]].<ref name=\"infoq2012\"/> Safety in Rust includes the guarantees of memory safety, type safety, and lack of data races.\n\n=== Hello World program ===\nBelow is a [[\"Hello, World!\" program]] in Rust. The {{Rust|fn}} keyword denotes a [[Function (computer programming)|function]], and the <code>println!</code> [[Macro (computer science)|macro]] prints the message to [[standard output]].{{sfn|Klabnik|Nichols|2019|pp=5\u20136}} [[Statement (computer science)|Statements]] in Rust are [[Semicolon#Programming|separated]] by semicolons.\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    println!(\"Hello, World!\");\n}\n</syntaxhighlight>\n\n=== Keywords and control flow ===\nIn Rust, blocks of code are delimited by [[Bracket#Curly brackets|curly brackets]], and [[control flow]] is implemented by keywords including <code>[[Conditional (computer programming)|if]]</code>, <code>else</code>, <code>[[While loop|while]]</code>, and <code>[[For loop|for]]</code>.{{sfn|Klabnik|Nichols|2019|pp=49\u201357}} [[Pattern matching]] can be done using the {{Rust|match}} keyword.{{sfn|Klabnik|Nichols|2019|pp=104\u2013109}} In the examples below, explanations are given in [[comment (computer programming)|comment]]s, which start with {{code|//}}.{{sfn|Klabnik|Nichols|2019|p=49}}\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    // Defining a mutable variable with 'let mut'\n    // Using the macro vec! to create a vector\n    let mut values = vec![1, 2, 3, 4];\n\n    for value in &values {\n        println!(\"value = {}\", value);\n    }\n\n    if values.len() > 5 {\n        println!(\"List is longer than five items\");\n    }\n\n    // Pattern matching\n    match values.len() {\n        0 => println!(\"Empty\"),\n        1 => println!(\"One value\"),\n        // pattern matching can use ranges of integers\n        2..=10 => println!(\"Between two and ten values\"),\n        11 => println!(\"Eleven values\"),\n        // A `_` pattern is called a \"wildcard\", it matches any value\n        _ => println!(\"Many values\"),\n    };\n\n    // while loop with predicate and pattern matching using let\n    while let Some(value) = values.pop() {\n        println!(\"value = {value}\"); // using curly brackets to format a local variable\n    }\n}\n</syntaxhighlight>\n\n=== Expression blocks ===\nRust is [[Expression-oriented programming language|expression-oriented]], with nearly every part of a function body being an [[Expression (computer science)|expression]], including control-flow operators.{{sfn|Klabnik|Nichols|2019|pp=50\u201353}} The ordinary <code>if</code> expression is used instead of [[?:|C's ternary conditional]]. With returns being implicit, a function does not need to end with a <code>return</code> expression; if the semicolon is omitted, the value of the last expression in the function is used as the [[return value]],<ref>{{Cite web |last=Tyson |first=Matthew |date=2022-03-03 |title=Rust programming for Java developers |url=https://www.infoworld.com/article/3651362/rust-programming-for-java-developers.html |access-date=2022-07-14 |website=InfoWorld |language=en}}</ref> as seen in the following [[Recursion (computer science)|recursive]] implementation of the [[factorial]] function:\n\n<syntaxhighlight lang=\"rust\">\nfn factorial(i: u64) -> u64 {\n    if i == 0 {\n        1\n    } else {\n        i * factorial(i - 1)\n    }\n}\n</syntaxhighlight>\n\nThe following [[Iteration (computer science)|iterative]] implementation uses the <code>..=</code> operator to create an inclusive range:\n\n<syntaxhighlight lang=\"rust\">\nfn factorial(i: u64) -> u64 {\n    (2..=i).product()\n}\n</syntaxhighlight>\n\n==== Closures ====\n{{excerpt|Anonymous function|Rust|subsections=yes}}\n\n=== Types ===\nRust is [[strongly typed]] and [[statically typed]]. The types of all variables must be known at compilation time; assigning a value of a particular type to a differently typed variable causes a [[compilation error]]. Variables are declared with the [[Reserved word|keyword]] <code>let</code>, and type inference is used to determine their type.{{sfn|Klabnik|Nichols|2019|pp=24}} Variables assigned multiple times must be marked with the keyword <code>mut</code> (short for mutable).{{sfn|Klabnik|Nichols|2019|pp=32\u201333}}\n\nThe default integer type is {{rust|i32}}, and the default [[floating point]] type is {{rust|f64}}. If the type of a [[Literal (computer programming)|literal]] number is not explicitly provided, either it is [[type inference|inferred]] from the context or the default type is used.{{sfn|Klabnik|Nichols|2019|pp=36\u201338}}\n\n==== Primitive types ====\n{| class=\"wikitable\"\n|+Summary of Rust's [[Primitive data type|Primitive Types]]\n!Type\n!Description\n!Examples\n|-\n|{{rust|bool}}\n|[[Boolean value]]\n|{{plainlist|\n* {{rust|true}}\n* {{rust|false}}\n  }}\n|-\n|{{rust|u8}}\n|Unsigned [[8-bit integer]] (a [[byte]])\n|{{plainlist|\n* {{rust|255u8}}<ref group=\"note\" name=\"ExplicitSuffix\">This literal uses an explicit suffix, which is not needed when type can be inferred from the context</ref>\n* {{Rust|b'W'}} ([[ASCII]] encoded byte)\n  }}\n|-\n|{{plainlist|\n* {{rust|i8}}\n* {{rust|i16}}\n* {{rust|i32}}\n* {{rust|i64}}\n* {{rust|i128}}\n  }}\n|[[Signed integer]]s, up to [[128-bit computing|128 bits]]\n|{{plainlist|\n* {{rust|7}}<ref group=\"note\" name=\"Default\">Interpreted as {{rust|i32}} by default, or inferred from the context</ref>\n* {{rust|7i128}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n  }}\n|-\n|{{plainlist|\n* {{rust|u16}}\n* {{rust|u32}}\n* {{rust|u64}}\n* {{rust|u128}}\n  }}\n|[[Unsigned integer]]s, up to [[128-bit computing|128 bits]]\n|{{plainlist|\n* {{rust|14}}<ref group=\"note\" name=\"Inferred\">Type inferred from the context</ref>\n* {{rust|14u128}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n  }}\n|-\n|{{plainlist|\n* {{rust|usize}}\n* {{rust|isize}}\n  }}\n|[[Pointer (computer programming)|Pointer]]-sized integers (size depends on [[computing platform|platform]])\n|{{plainlist|\n* {{rust|14usize}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n* {{rust|-2isize}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n  }}\n|-\n|{{plainlist|\n* {{rust|f32}}\n* {{rust|f64}}\n  }}\n|[[Floating-point arithmetic|Floating-point number]]s\n|{{plainlist|\n* {{rust|-3f32}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n  }}\n|-\n|{{Rust|char}}\n|{{Plainlist|\n* [[UTF-32]] scalar value (occupies 4 bytes)\n* A [[Unicode codepoint]] that is not a [[Universal Character Set characters#Surrogates|surrogate]]{{sfn|Klabnik|Nichols|2019|pp=39\u201340}}\n  }}\n|{{plainlist|\n* {{Rust|'a'}}\n* {{Rust|'\u8bed'}}\n* {{Rust|'\ud83e\udd80'}} ([[Emoji]])\n* {{Rust|'\\u{200D}'}} (Unicode escape, [[zero-width joiner]])\n  }}\n|-\n|{{Rust|str}}\n|[[UTF-8]]-encoded string slice, the primitive string type. It is usually seen in its borrowed form, {{Rust|&str}}. It is also the type of string literals, {{Rust|&'static str}}<ref>{{Cite web |title=str \u2013 Rust |url=https://doc.rust-lang.org/beta/std/primitive.str.html |access-date=2023-06-23 |website=doc.rust-lang.org}}</ref>\n|{{plainlist|\n* {{Rust|\"Hello\"}}\n* {{Rust|\"3\"}}\n* {{Rust|\"\ud83e\udd80\ud83e\udd80\ud83e\udd80\"}}\n  }}\n|-\n|{{Rust|[T; N]}}\n|[[Array (data structure)|Array]] \u2013 collection of N objects of the same type T, stored in contiguous memory\n|{{plainlist|\n* {{Rust|[2, 4, 6]}}\n* {{Rust|[0; 100]}}\n* {{Rust|b\"Hello\"}}\n  }}\n|-\n|{{Rust|[T]}}\n|Slice \u2013 a dynamically-sized view into a contiguous sequence<ref>{{Cite web |title=slice \u2013 Rust |url=https://doc.rust-lang.org/beta/std/primitive.slice.html |access-date=2023-06-23 |website=doc.rust-lang.org}}</ref>\n|{{plainlist|\n* {{Rust|[1, 2, 3, 4, 5][..i]}}\n* {{Rust|\"Hello, world!\".as_bytes()}}\n* {{Rust|let v {{=}} vec![1, 2, 3]; v.as_slice()}}\n  }}\n|-\n|{{plainlist|{{Rust|(T, U, ..)}}}}\n|[[Tuple]] \u2013 a finite heterogeneous sequence\n|{{plainlist|\n* {{Rust|()}} (An empty tuple, the [[unit type]] in Rust)\n* {{Rust|(5,)}} ({{Rust|(5)}} is parsed as an integer)<ref>{{Cite web |title=Tuples |url=https://doc.rust-lang.org/rust-by-example/primitives/tuples.html |access-date=2023-10-01 |website=Rust By Example}}</ref>\n* {{Rust|(\"Age\", 10)}}\n* {{Rust|(1, true, \"Name\")}}\n  }}\n|-\n| {{Rust|!}}\n| [[Bottom type|Never type]] (unreachable value)\n| {{Rust|let x {{=}} { return 123 };}}\n|}\n\n==== Standard library ====\n{| class=\"wikitable\"\n|+Summary of Rust's types in the [[standard library]]\n!Type\n!Description\n!Examples\n|-\n|{{Rust|String}}\n|UTF-8-encoded strings (dynamic)\n|{{plainlist|\n* {{Rust|String::new()}}\n* {{Rust|String::from(\"Hello\")}}\n* {{Rust|\"\ud83e\udd80\ud83e\udd80\ud83e\udd80\".to_string()}}\n  }}\n|-\n|{{plainlist|\n* {{Rust|OsStr}}\n* {{Rust|OsString}}\n  }}\n|Platform-native strings<ref group=\"note\" name=\"OsString\">On Unix systems, this is often UTF-8 strings without an internal 0 byte. On Windows, this is [[UTF-16]] strings without an internal 0 byte. Unlike these, {{Rust|str}} and {{Rust|String}} are always valid UTF-8 and can contain internal zeros.</ref> (borrowed<ref>{{Cite web |title=OsStr in std::ffi \u2013 Rust |url=https://doc.rust-lang.org/beta/std/ffi/struct.OsStr.html |access-date=2023-10-02 |website=doc.rust-lang.org}}</ref> and dynamic<ref>{{Cite web |title=OsString in std::ffi \u2013 Rust |url=https://doc.rust-lang.org/beta/std/ffi/struct.OsString.html |access-date=2023-10-02 |website=doc.rust-lang.org}}</ref>)\n|{{plainlist|\n* {{Rust|OsStr::new(\"Hello\")}}\n* {{Rust|OsString::from(\"world\")}}\n  }}\n|-\n|{{plainlist|\n* {{Rust|Path}}\n* {{Rust|PathBuf}}\n  }}\n|[[Path (computing)|Paths]] (borrowed<ref>{{Cite web |title=Path in std::path \u2013 Rust |url=https://doc.rust-lang.org/beta/std/path/struct.Path.html |access-date=2023-10-02 |website=doc.rust-lang.org}}</ref> and dynamic<ref>{{Cite web |title=PathBuf in std::path \u2013 Rust |url=https://doc.rust-lang.org/beta/std/path/struct.PathBuf.html |access-date=2023-10-02 |website=doc.rust-lang.org}}</ref>)\n|{{plainlist|\n* {{Rust|Path::new(\"./path/to\")}}\n* {{Rust|PathBuf::from(r\"C:.\\path\\to\")}}\n  }}\n|-\n|{{plainlist|\n* {{Rust|CStr}}\n* {{Rust|CString}}\n  }}\n|[[C (programming language)|C]]-compatible, [[null-terminated string]]s (borrowed<ref name=\"std::boxed \u2013 Rust\">{{Cite web |title=std::boxed \u2013 Rust |url=https://doc.rust-lang.org/std/boxed/index.html |access-date=2023-06-23 |website=doc.rust-lang.org}}</ref> and dynamic<ref name=\"std::boxed \u2013 Rust\"/>)\n|{{plainlist|\n* {{Rust|CStr::from_bytes_with_nul(b\"Hello\\0\").unwrap()}}\n* {{Rust|CString::new(\"world\").unwrap()}}\n  }}\n|-\n|{{Rust|Vec<T>}}\n|[[Dynamic array]]s\n|{{plainlist|\n* {{Rust|Vec::new()}}\n* {{Rust|vec![1, 2, 3, 4, 5]}}\n  }}\n|-\n|{{Rust|Option<T>}}\n|[[Option type]]\n|{{plainlist|\n* {{Rust|None}}\n* {{Rust|Some(3)}}\n* {{Rust|Some(\"hello\")}}\n  }}\n|-\n|{{Rust|Result<T, E>}}\n|[[Exception handling|Error handling]] using a [[result type]]\n|{{plainlist|\n* {{Rust|Ok(3)}}\n* {{Rust|Err(\"something went wrong\")}}\n  }}\n|-\n|{{Rust|Box<T>}}\n|A pointer to a [[Heap (programming)|heap]]-allocated value<ref>{{Cite web |title=std::boxed \u2013 Rust |url=https://doc.rust-lang.org/std/boxed/index.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>. Similar to C++'s [https://en.cppreference.com/w/cpp/memory/unique_ptr std::unique_ptr].\n| <syntaxhighlight lang=\"rust\">\nlet boxed: Box<u8> = Box::new(5);\nlet val: u8 = *boxed;\n</syntaxhighlight>\n|-\n|{{Rust|Rc<T>}}\n|[[Reference counting]] pointer<ref>{{Cite web |title=Rc in std::rc \u2013 Rust |url=https://doc.rust-lang.org/beta/std/rc/struct.Rc.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet five = Rc::new(5);\nlet also_five = five.clone();\n</syntaxhighlight>\n|-\n|{{Rust|Arc<T>}}\n|[[Linearizability|Atomic]], [[Thread safety|thread-safe]] reference counting pointer<ref>{{Cite web |title=Arc in std::sync \u2013 Rust |url=https://doc.rust-lang.org/beta/std/sync/struct.Arc.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet foo = Arc::new(vec![1.0, 2.0]);\nlet a = foo.clone(); // a can be sent to another thread\n</syntaxhighlight>\n|-\n|{{Rust|Cell<T>}}\n|A mutable memory location<ref>{{Cite web |title=Cell in std::cell \u2013 Rust |url=https://doc.rust-lang.org/beta/std/cell/struct.Cell.html# |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet c = Cell::new(5);\nc.set(10);\n</syntaxhighlight>\n|-\n|<code>Mutex<T></code>\n|A [[Lock (computer science)|mutex lock]] for shared data contained within.<ref>{{Cite web |title=Mutex in std::sync \u2013 Rust |url=https://doc.rust-lang.org/beta/std/sync/struct.Mutex.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet mutex = Mutex::new(0_u32);\nlet _guard = mutex.lock();\n</syntaxhighlight>\n|-\n|{{Rust|RwLock<T>}}\n|[[Readers\u2013writer lock]]<ref>{{Cite web |title=RwLock in std::sync \u2013 Rust |url=https://doc.rust-lang.org/beta/std/sync/struct.RwLock.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet lock = RwLock::new(5);\nlet r1 = lock.read().unwrap();\n</syntaxhighlight>\n|-\n|{{Rust|Condvar}}\n|A [[Monitor (synchronization)|conditional monitor]] for shared data<ref>{{Cite web |title=Condvar in std::sync \u2013 Rust |url=https://doc.rust-lang.org/beta/std/sync/struct.Condvar.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\n let (lock, cvar) = (Mutex::new(true), Condvar::new());\n// As long as the value inside the `Mutex<bool>` is `true`, we wait.\nlet _guard = cvar.wait_while(lock.lock().unwrap(), |pending| { *pending }).unwrap();\n\n</syntaxhighlight>\n|-\n|{{Rust|Duration}}\n|Type that represents a span of time<ref>{{Cite web |title=Duration in std::time \u2013 Rust |url=https://doc.rust-lang.org/beta/std/time/struct.Duration.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nDuration::from_millis(1) // 1ms\n</syntaxhighlight>\n|-\n|{{Rust|1=HashMap<K, V>}}\n|[[Hash table]]<ref>{{Cite web |title=HashMap in std::collections \u2013 Rust |url=https://doc.rust-lang.org/beta/std/collections/struct.HashMap.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet mut player_stats = HashMap::new();\nplayer_stats.insert(\"damage\", 1);\nplayer_stats.entry(\"health\").or_insert(100);\n</syntaxhighlight>\n|-\n|{{Rust|1=BTreeMap<K, V>}}\n|[[B-tree]]<ref>{{Cite web |title=BTreeMap in std::collections \u2013 Rust |url=https://doc.rust-lang.org/beta/std/collections/struct.BTreeMap.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet mut solar_distance = BTreeMap::from([\n    (\"Mercury\", 0.4),\n    (\"Venus\", 0.7),\n]);\nsolar_distance.entry(\"Earth\").or_insert(1.0);\n\n</syntaxhighlight>\n|}\n\n[[Option type|<code>Option</code>]] values are handled using [[syntactic sugar]], such as the <code>if let</code> construction, to access the inner value (in this case, a string):{{sfn|McNamara|2021}}\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    let name1: Option<&str> = None;\n    // In this case, nothing will be printed out\n    if let Some(name) = name1 {\n        println!(\"{name}\");\n    }\n\n    let name2: Option<&str> = Some(\"Matthew\");\n    // In this case, the word \"Matthew\" will be printed out\n    if let Some(name) = name2 {\n        println!(\"{name}\");\n    }\n}\n</syntaxhighlight>\n\n==== Pointers ====\n{| class=\"wikitable\"\n|+Summary of Rust's [[Pointer (computer programming)|pointer]] and [[Reference (computer science)|reference]] primitive types\n!Type\n!Description\n!Examples\n|-\n|{{plainlist|\n* {{Rust|&T}}\n* {{Rust|&mut T}}\n  }}\n|[[Reference (computer science)|References]] (immutable and mutable)\n|{{plainlist|\n* {{Rust|let x_ref {{=}} {{not a typo|&x;}}}}\n* {{Rust|let x_ref {{=}} &mut x;}}\n  }}\n|-\n|{{plainlist|\n* {{Rust|Option<&T>}}\n* {{Rust|Option<&mut T>}}\n  }}\n|{{plainlist|\n* Option wrapped reference\n* Possibly null reference\n  }}\n|{{plainlist|\n* {{Rust|None}}\n* {{Rust|let x_ref {{=}} Some(&x);}}\n* {{Rust|let x_ref {{=}} Some(&mut x);}}\n  }}\n|-\n|{{Plain list|* {{Rust|Box<T>}}\n* {{Rust|Option<Box<T>>}}}}\n|A pointer to heap-allocated value\n(or possibly null pointer if wrapped in option)<ref name=\"std::boxed \u2013 Rust\"/>\n|{{Plain list|* {{Rust|let boxed {{=}} Box::new(0);}}\n* {{Rust|let boxed {{=}} Some(Box::new(\"Hello World\"));}}}}\n|-\n|{{Plainlist|\n* {{Rust|*const T}}\n* {{Rust|*mut T}}\n  }}\n|{{Plainlist|\n* Raw pointers (immutable and mutable)\n* Possibly [[Null pointer|null]]; {{Rust|unsafe}} to [[dereference]]\n  }}\n|{{Plainlist|\n* {{Rust|let x_ptr {{=}} &x as *const T;}}\n* {{Rust|let x_ptr {{=}} &mut x as *mut T;}}\n  }}\n|}\n\nRust does not use [[null pointer]]s to indicate a lack of data, as doing so can lead to [[Null pointer#Null dereferencing|null dereferencing]]. Accordingly, the basic <code>&</code> and <code>&mut</code> references are guaranteed to not be null. Rust instead uses <code>Option</code> for this purpose: <code>Some(T)</code> indicates that a value is present, and <code>None</code> is analogous to the null pointer.{{sfn|Klabnik|Nichols|2019|pp=101\u2013104}} <code>Option</code> implements a \"null pointer optimization\", avoiding any spatial overhead for types that cannot have a null value (references or the <code>NonZero</code> types, for example).<ref>{{Cite web |title=std::option - Rust |url=https://doc.rust-lang.org/std/option/index.html#representation |access-date=2023-11-12 |website=doc.rust-lang.org}}</ref>\n\nUnlike references, the raw pointer types <code>*const</code> and <code>*mut</code> may be null; however, it is impossible to dereference them unless the code is explicitly declared unsafe through the use of an <code>unsafe</code> block. Unlike dereferencing, the creation of raw pointers is allowed inside of safe Rust code.{{sfn|Klabnik|Nichols|2019|pp=418\u2013427}}\n\n==== User-defined types ====\nUser-defined types are created with the <code>struct</code> or <code>enum</code> keywords. The <code>struct</code> keyword is used to denote a [[Record (computer science)|record type]] that groups multiple related values.{{sfn|Klabnik|Nichols|2019|p=83}} <code>enum</code>s can take on different variants at runtime, with its capabilities similar to [[algebraic data types]] found in functional programming languages.{{sfn|Klabnik|Nichols|2019|p=97}} Both structs and enums can contain [[Field (computer science)|fields]] with different types.{{sfn|Klabnik|Nichols|2019|pp=98\u2013101}} Alternative names for the same type can be defined with the <code>type</code> keyword.{{sfn|Klabnik|Nichols|2019|pp=438\u2013440}}\n\nThe <code>impl</code> keyword can define methods for a user-defined type (data and functions are defined separately). Implementations fulfill a role similar to that of classes within other languages.{{sfn|Klabnik|Nichols|2019|pp=93}}\n\n==== Type conversion ====\n{{excerpt|Type conversion|Rust}}\n\n=== Ownership and lifetimes ===\nRust's ownership system consists of rules that ensure memory safety without using a garbage collector. At compile time, each value must be attached to a variable called the ''owner'' of that value, and every value must have exactly one owner.{{sfn|Klabnik|Nichols|2019|pp=59\u201361}} Values are moved between different owners through assignment or passing a value as a function parameter.  Values can also be ''borrowed,'' meaning they are temporarily passed to a different function before being returned to the owner.{{sfn|Klabnik|Nichols|2019|pp=63\u201368}} With these rules, Rust can prevent the creation and use of [[dangling pointers]]:{{sfn|Klabnik|Nichols|2019|pp=63\u201368}}{{sfn|Klabnik|Nichols|2019|pp=74\u201375}}\n\n<syntaxhighlight lang=\"rust\">\nfn print_string(s: String) {\n    println!(\"{}\", s);\n}\n\nfn main() {\n    let s = String::from(\"Hello, World\");\n    print_string(s); // s consumed by print_string\n    // s has been moved, so cannot be used any more\n    // another print_string(s); would result in a compile error\n}\n</syntaxhighlight>\n\nBecause of these ownership rules, Rust types are known as ''[[linear types|linear]]'' or ''affine'' types, meaning each value can be used exactly once. This enforces a form of [[software fault isolation]] as the owner of a value is solely responsible for its correctness and deallocation.<ref name=\"BeyondSafety\">{{Cite book |last1=Balasubramanian |first1=Abhiram |last2=Baranowski |first2=Marek S. |last3=Burtsev |first3=Anton |last4=Panda |first4=Aurojit |last5=Rakamari\u0107 |first5=Zvonimir |last6=Ryzhyk |first6=Leonid |title=Proceedings of the 16th Workshop on Hot Topics in Operating Systems |chapter=System Programming in Rust |date=2017-05-07 |chapter-url=https://doi.org/10.1145/3102980.3103006 |series=HotOS '17 |location=New York, NY, US |publisher=Association for Computing Machinery |pages=156\u2013161 |doi=10.1145/3102980.3103006 |isbn=978-1-4503-5068-6 |s2cid=24100599 |access-date=June 1, 2022 |archive-date=June 11, 2022 |archive-url=https://web.archive.org/web/20220611034046/https://dl.acm.org/doi/10.1145/3102980.3103006 |url-status=live}}</ref>\n\nWhen a value goes out of scope, it is ''dropped'' by running its [[Destructor (computer programming)|destructor]]. The destructor may be programmatically defined through implementing the {{code|Drop}} [[#Traits|trait]]. This helps manage resources such as file handles, network sockets, and [[Lock (computer science)|locks]], since when objects are dropped, the resources associated with them are closed or released automatically.{{sfn|Klabnik|Nichols|2023|pp=327-30}}\n\n''Lifetimes'' are usually an implicit part of all [[Reference (computer science)|reference types]] in Rust. Each lifetime encompasses a set of locations in the code for which a variable is valid. For example, a reference to a local variable has a lifetime corresponding to the block it is defined in:{{sfn|Klabnik|Nichols|2019|p=194}}\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    let x = 5;                              // ------------------+- Lifetime 'b\n                                            //                   |\n    let r = &x;                             // -+-- Lifetime 'a  |\n                                            //  |                |\n    println!(\"r: {}\", r);                   //  |                |\n                                            //  |                |\n                                            // -+                |\n}                                           // ------------------+\n</syntaxhighlight>\n\nThe borrow checker in the Rust compiler uses lifetimes to ensure that the values a reference points to remain valid.{{sfn|Klabnik|Nichols|2019|pp=75,134}}<ref>{{Cite web |last=Shamrell-Harrington |first=Nell |title=The Rust Borrow Checker \u2013 a Deep Dive |url=https://www.infoq.com/presentations/rust-borrow-checker/ |access-date=2022-06-25 |website=InfoQ |language=en}}</ref> In the example above, storing a reference to variable {{code|x}} to {{code|r}} is valid, as variable {{code|x}} has a longer lifetime ({{code|'b}}) than variable {{code|r}} ({{code|'a}}). However, when {{code|x}} has a shorter lifetime, the borrow checker would reject the program:\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    let r;                                  // ------------------+- Lifetime 'a\n                                            //                   |\n    {                                       //                   |\n        let x = 5;                          // -+-- Lifetime 'b  |\n        r = x;                              //  |                |\n    }                                       //  |                |\n                                            //                   |\n    println!(\"r: {}\", r);                   //                   |\n}                                           // ------------------+\n</syntaxhighlight>\n\nSince the lifetime of the referenced variable ({{code|'b}}) is shorter than the lifetime of the variable holding the reference ({{code|'a}}), the borrow checker errors, preventing {{code|x}} from being used from outside its scope.{{sfn|Klabnik|Nichols|2019|pp=194-195}}\n\nRust defines the relationship between the lifetimes of the objects created and used by functions, using ''lifetime parameters'', as a signature feature.{{sfn|Klabnik|Nichols|2019|pp=192\u2013204}}\n\nThe example below parses some configuration options from a string and creates a struct containing the options. The struct only contains references to the data; so, for the struct to remain valid, the data referred to by the struct must be valid as well. The function signature for <code>parse_config</code> specifies this relationship explicitly. In this example, the explicit lifetimes are unnecessary in newer Rust versions, due to lifetime elision, which is an algorithm that automatically assigns lifetimes to functions if they are trivial.{{sfn|Klabnik|Nichols|2019|pp=201\u2013203}}\n\n<syntaxhighlight lang=\"rust\">\nuse std::collections::HashMap;\n\n// This struct has one lifetime parameter, 'src. The name is only used within the struct's definition.\n#[derive(Debug)]\nstruct Config<'src> {\n    hostname: &'src str,\n    username: &'src str,\n}\n\n// This function also has a lifetime parameter, 'cfg. 'cfg is attached to the \"config\" parameter, which\n// establishes that the data in \"config\" lives at least as long as the 'cfg lifetime.\n// The returned struct also uses 'cfg for its lifetime, so it can live at most as long as 'cfg.\nfn parse_config<'cfg>(config: &'cfg str) -> Config<'cfg> {\n    let key_values: HashMap<_, _> = config\n        .lines()\n        .filter(|line| !line.starts_with('#'))\n        .filter_map(|line| line.split_once('='))\n        .map(|(key, value)| (key.trim(), value.trim()))\n        .collect();\n    Config {\n        hostname: key_values[\"hostname\"],\n        username: key_values[\"username\"],\n    }\n}\n\nfn main() {\n    let config = parse_config(\n        r#\"hostname = foobar\nusername=barfoo\"#,\n    );\n    println!(\"Parsed config: {:#?}\", config);\n}\n</syntaxhighlight>\n\n[[File:Rust 101.webm|thumb|A presentation on Rust by Emily Dunham from [[Mozilla]]'s Rust team ([[linux.conf.au]] conference, Hobart, 2017)]]\n\n=== Memory safety ===\nRust is designed to be [[memory safe]]. It does not permit null pointers, [[dangling pointer]]s, or [[data race]]s.<ref name=\"cnet\">{{cite web |url=http://reviews.cnet.com/8301-3514_7-57577639/samsung-joins-mozillas-quest-for-rust/ |title=Samsung joins Mozilla's quest for Rust |last=Rosenblatt |first=Seth |date=2013-04-03 |publisher=[[CNET]] |access-date=2013-04-05 |archive-date=2013-04-04 |archive-url=https://web.archive.org/web/20130404142333/http://reviews.cnet.com/8301-3514_7-57577639/samsung-joins-mozillas-quest-for-rust/ |url-status=live}}</ref><ref name=\"lwn\">{{cite web |url=https://lwn.net/Articles/547145/ |title=A taste of Rust |last=Brown |first=Neil |date=2013-04-17 |access-date=2013-04-25 |archive-date=2013-04-26 |archive-url=https://web.archive.org/web/20130426010754/http://lwn.net/Articles/547145/ |url-status=live}}</ref><ref name=\"The Rustonomicon\">{{Cite web|url=https://doc.rust-lang.org/nomicon/races.html|title=Races \u2013 The Rustonomicon|website=doc.rust-lang.org|access-date=2017-07-03|archive-date=2017-07-10|archive-url=https://web.archive.org/web/20170710194643/https://doc.rust-lang.org/nomicon/races.html|url-status=live}}</ref> Data values can be initialized only through a fixed set of forms, all of which require their inputs to be already initialized.<ref name=\"lang-faq\">{{cite web  |title=The Rust Language FAQ |website=static.rust-lang.org |url=http://static.rust-lang.org/doc/master/complement-lang-faq.html |url-status=dead |archive-url=https://web.archive.org/web/20150420104147/http://static.rust-lang.org/doc/master/complement-lang-faq.html |archive-date=2015-04-20 |year=2015 |access-date=2017-04-24}}</ref>\n\nUnsafe code can subvert some of these restrictions, using the <code>unsafe</code> keyword.{{sfn|Klabnik|Nichols|2019|pp=418\u2013427}} Unsafe code may also be used for low-level functionality, such as [[Volatile (computer programming)|volatile memory access]], architecture-specific intrinsics, [[type punning]], and inline assembly.{{sfn|McNamara|2021|p=139, 376\u2013379, 395}}\n\n=== Memory management ===\nRust does not use [[garbage collection (computer science)|garbage collection]]. Memory and other resources are instead managed through the \"resource acquisition is initialization\" convention,<ref>{{Cite web|title=RAII \u2013 Rust By Example|url=https://doc.rust-lang.org/rust-by-example/scope/raii.html|access-date=2020-11-22|website=doc.rust-lang.org|archive-date=2019-04-21|archive-url=https://web.archive.org/web/20190421131142/https://doc.rust-lang.org/rust-by-example/scope/raii.html|url-status=live}}</ref> with optional [[reference counting]]. Rust provides deterministic management of resources, with very low [[Overhead (computing)|overhead]].<ref>{{Cite web|url=https://blog.rust-lang.org/2015/05/11/traits.html|title=Abstraction without overhead: traits in Rust|website=Rust Blog|access-date=October 19, 2021|archive-date=September 23, 2021|archive-url=https://web.archive.org/web/20210923101530/https://blog.rust-lang.org/2015/05/11/traits.html|url-status=live}}</ref> Values are [[Stack-based memory allocation|allocated on the stack]] by default, and all [[dynamic allocation]]s must be explicit.<ref>{{Cite web |title=Box, stack and heap |url=https://doc.rust-lang.org/stable/rust-by-example/std/box.html |access-date=2022-06-13 |website=Rust By Example}}</ref>\n\nThe built-in reference types using the <code>&</code> symbol do not involve run-time reference counting. The safety and validity of the underlying pointers is verified at compile time, preventing [[dangling pointers]] and other forms of [[undefined behavior]].{{sfn|Klabnik|Nichols|2019|pp=70\u201375}} Rust's type system separates shared, [[Immutable object|immutable]] references of the form <code>&T</code> from unique, mutable references of the form <code>&mut T</code>. A mutable reference can be coerced to an immutable reference, but not vice versa.{{sfn|Klabnik|Nichols|2019|p=323}}\n\n=== Polymorphism ===\n==== Generics ====\nRust's more advanced features include the use of [[generic function]]s. A generic function is given [[Generic programming|generic]] [[Parameter (computer programming)|parameters]], which allow the same function to be applied to different variable types. This capability reduces [[duplicate code]]{{sfn|Klabnik|Nichols|2019|pp=171\u2013172}} and is known as [[parametric polymorphism]].\n\nThe following program calculates the sum of two things, for which addition is implemented using a generic function:\n\n<syntaxhighlight lang=\"rust\">\nuse std::ops::Add;\n\n// sum is a generic function with one type parameter, T\nfn sum<T>(num1: T, num2: T) -> T\nwhere  \n    T: Add<Output = T>,  // T must implement the Add trait where addition returns another T\n{\n    num1 + num2  // num1 + num2 is syntactic sugar for num1.add(num2) provided by the Add trait\n}\n\nfn main() {\n    let result1 = sum(10, 20);\n    println!(\"Sum is: {}\", result1); // Sum is: 30\n\n    let result2 = sum(10.23, 20.45);\n    println!(\"Sum is: {}\", result2); // Sum is: 30.68\n}\n</syntaxhighlight>\n\nAt compile time, polymorphic functions like <code>sum</code> are [[Instance (computer science)|instantiated]] with the specific types the code requires; in this case, sum of integers and sum of floats.\n\nGenerics can be used in functions to allow implementing a behavior for different types without repeating the same code. Generic functions can be written in relation to other generics, without knowing the actual type.{{sfn|Klabnik|Nichols|2019|pp=171\u2013172,205}}\n\n==== Traits ====\nRust's type system supports a mechanism called traits, inspired by [[type class]]es in the [[Haskell]] language,<ref name=\"influences\"/> to define shared behavior between different types. For example, the <code>Add</code> trait can be implemented for floats and integers, which can be added; and the <code>Display</code> or <code>Debug</code> traits can be implemented for any type that can be converted to a string. Traits can be used to provide a set of common behavior for different types without knowing the actual type. This facility is known as [[ad hoc polymorphism]].\n\nGeneric functions can constrain the generic type to implement a particular trait or traits; for example, an <code>add_one</code> function might require the type to implement <code>Add</code>. This means that a generic function can be type-checked as soon as it is defined. The implementation of generics is similar to the typical implementation of C++ templates: a separate copy of the code is generated for each instantiation. This is called [[monomorphization]] and contrasts with the [[type erasure]] scheme typically used in Java and Haskell. Type erasure is also available via the keyword <code>dyn</code> (short for dynamic).{{sfn|Klabnik|Nichols|2019|pp=181,182}} Because monomorphization duplicates the code for each type used, it can result in more optimized code for specific-use cases, but compile time and size of the output binary are also increased.{{sfn|Gjengset|2021|p=25}}\n\nIn addition to defining methods for a user-defined type, the <code>impl</code> keyword can be used to implement a trait for a type.{{sfn|Klabnik|Nichols|2019|pp=93}} Traits can provide additional derived methods when implemented.{{sfn|Klabnik|Nichols|2019|pp=182\u2013184}} For example, the trait <code>Iterator</code> requires that the <code>next</code> method be defined for the type. Once the <code>next</code> method is defined, the trait can provide common functional helper methods over the iterator, such as <code>map</code> or <code>filter</code>.{{sfn|Klabnik|Nichols|2019|pp=281\u2013283}}\n\n==== Trait objects ====\nRust traits are implemented using [[static dispatch]], meaning that the type of all values is known at compile time; however, Rust also uses a feature known as ''trait objects'' to accomplish [[dynamic dispatch]] (also known as [[duck typing]]).<ref name=TraitObjectsBook>{{Cite web |title=Using Trait Objects That Allow for Values of Different Types \u2013 The Rust Programming Language |url=https://doc.rust-lang.org/book/ch17-02-trait-objects.html |access-date=2022-07-11 |website=doc.rust-lang.org}}</ref> Dynamically dispatched trait objects are declared using the syntax <code>dyn Tr</code> where <code>Tr</code> is a trait. Trait objects are dynamically sized, therefore they must be put behind a pointer, such as <code>Box</code>.{{sfn|Klabnik|Nichols|2019|pp=441\u2013442}} The following example creates a list of objects where each object can be printed out using the <code>Display</code> trait:\n\n<syntaxhighlight lang=\"Rust\">\nuse std::fmt::Display;\n\nlet v: Vec<Box<dyn Display>> = vec![\n    Box::new(3),\n    Box::new(5.0),\n    Box::new(\"hi\"),\n];\n\nfor x in v {\n    println!(\"{x}\");\n}\n</syntaxhighlight>\n\nIf an element in the list does not implement the <code>Display</code> trait, it will cause a compile-time error.{{sfn|Klabnik|Nichols|2019|pp=379\u2013380}}\n\n=== Iterators ===\n[[For loop]]s in Rust work in a functional style as operations over an [[iterator]] type. For example, in the loop\n\n<syntaxhighlight lang=\"rust\">\nfor x in 0..100 {\n   f(x);\n}\n</syntaxhighlight>\n\n<code>0..100</code> is a value of type <code>Range</code> which implements the <code>Iterator</code> trait; the code applies the function <code>f</code> to each element returned by the iterator. Iterators can be combined with functions over iterators like <code>map</code>, <code>filter</code>, and <code>sum</code>. For example, the following adds up all numbers between 1 and 100 that are multiples of 3:\n\n<syntaxhighlight lang=\"rust\">\n(1..=100).filter(|&x| x % 3 == 0).sum()\n</syntaxhighlight>\n\n=== Macros ===\nIt is possible to extend the Rust language using macros.\n\n==== Declarative macros ====\nA declarative macro (also called a \"macro by example\") is a macro that uses pattern matching to determine its expansion.<ref name=\"Rust Ref. \u2013 Macros By Example\">{{cite web |title=Macros By Example |url=https://doc.rust-lang.org/reference/macros-by-example.html |archive-url= |archive-date= |url-status= |website=The Rust Reference |access-date=21 April 2023}}</ref>{{sfn|Klabnik|Nichols|2019|pp=446\u2013448}}\n\n==== Procedural macros ====\nProcedural macros are Rust functions that run and modify the compiler's input [[Token (parser)|token]] stream, before any other components are compiled. They are generally more flexible than declarative macros, but are more difficult to maintain due to their complexity.<ref name=\"rust-procedural-macros\">{{cite web |url=https://doc.rust-lang.org/reference/procedural-macros.html |title=Procedural Macros |website=The Rust Programming Language Reference |access-date=23 Mar 2021 |archive-date=7 November 2020 |archive-url=https://web.archive.org/web/20201107233444/https://doc.rust-lang.org/reference/procedural-macros.html |url-status=live}}</ref>{{sfn|Klabnik|Nichols|2019|pp=449\u2013455}}\n\nProcedural macros come in three flavors:\n* Function-like macros <code>custom!(...)</code>\n* Derive macros <code>#[derive(CustomDerive)]</code>\n* Attribute macros <code>#[custom_attribute]</code>\n\nThe <code>println!</code> macro is an example of a function-like macro. The<code>serde_derive</code> macro<ref>{{cite web|url=https://serde.rs/derive.html|title=Serde Derive|website=Serde Derive documentation|access-date=23 Mar 2021|archive-date=17 April 2021|archive-url=https://web.archive.org/web/20210417114849/https://serde.rs/derive.html|url-status=live}}</ref> provides a commonly used library for generating code\nfor reading and writing data in many formats, such as [[JSON]]. Attribute macros are commonly used for language bindings, such as the <code>extendr</code> library for Rust bindings to [[R (programming language)|R]].<ref>{{cite web|url=https://extendr.github.io/extendr/extendr_api/index.html|title=extendr_api \u2013 Rust|website=Extendr Api Documentation|access-date=23 Mar 2021|archive-date=May 25, 2021|archive-url=https://web.archive.org/web/20210525082129/https://extendr.github.io/extendr/extendr_api/index.html|url-status=live}}</ref>\n\nThe following code shows the use of the <code>Serialize</code>, <code>Deserialize</code>, and <code>Debug</code>-derived procedural macros\nto implement JSON reading and writing, as well as the ability to format a structure for debugging.\n[[File:Rust serde UML diagram.svg|thumb|A [[UML diagram]] depicting a Rust struct named Point.]]\n<syntaxhighlight lang=\"rust\">\nuse serde_json::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let point = Point { x: 1, y: 2 };\n\n    let serialized = serde_json::to_string(&point).unwrap();\n    println!(\"serialized = {}\", serialized);\n\n    let deserialized: Point = serde_json::from_str(&serialized).unwrap();\n    println!(\"deserialized = {:?}\", deserialized);\n}\n</syntaxhighlight>\n\n==== Variadic macros ====\n{{excerpt|Variadic function|In Rust|subsections=yes}}\n\n=== Interface with C and C++ ===\nRust has a [[foreign function interface]] (FFI) that can be used both to call code written in languages such as [[C (programming language)|C]] from Rust and to call Rust code from those languages. As of 2023, an external library called CXX exists for calling to or from C++.<ref>{{Cite web|title=Safe Interoperability between Rust and C++ with CXX|url=https://www.infoq.com/news/2020/12/cpp-rust-interop-cxx/|date=2020-12-06|access-date=2021-01-03|website=InfoQ|language=en|archive-date=January 22, 2021|archive-url=https://web.archive.org/web/20210122142035/https://www.infoq.com/news/2020/12/cpp-rust-interop-cxx/|url-status=live}}</ref> Rust and C differ in how they lay out structs in memory, so Rust structs may be given a <code>#[repr(C)]</code> attribute, forcing the same layout as the equivalent C struct.<ref>{{cite web |title=Type layout \u2013 The Rust Reference |url=https://doc.rust-lang.org/reference/type-layout.html#the-c-representation |website=doc.rust-lang.org |access-date=15 July 2022}}</ref>\n\n== Ecosystem ==\n[[File:Rustc building paru with cargo screenshot.png|thumb|right|Compiling a Rust program with Cargo]]\n\nThe Rust ecosystem includes its compiler, its [[standard library]], and additional components for software development. Component installation is typically managed by {{code|rustup}}, a Rust [[toolchain]] installer developed by the Rust project.{{sfn|Blandy|Orendorff|Tindall|2021|pp=6-8}}\n<!-- Add Miri Compiler? -->\n\n=== Compiler ===\nThe Rust compiler is named <code>rustc</code>, and translates Rust code into a low level language called LLVM intermediate representation (LLVM IR). LLVM is then invoked as a subcomponent to translate IR code into [[machine code]]. A [[Linker (computing)|linker]] is then used to combine multiple crates together as a single executable or binary file.{{sfn|McNamara|2021|pp=411-412}}<ref>{{Cite web |title=Overview of the compiler |url=https://rustc-dev-guide.rust-lang.org/overview.html |access-date=2023-06-02 |website=Rust Compiler Development Guide}}</ref>\n\nOther than LLVM, the compiler also supports using alternative backends such as [[GNU Compiler Collection|GCC]] and [[Cranelift]] for code generation.<ref>{{cite web |title=Code Generation - Rust Compiler Development Guide |url=https://rustc-dev-guide.rust-lang.org/backend/codegen.html |website=rustc-dev-guide.rust-lang.org |access-date=3 March 2024}}</ref> The intention of those alternative backends is to increase platform coverage of Rust or to improve compilation times.<ref>{{cite web |title=rust-lang/rustc_codegen_gcc |url=https://github.com/rust-lang/rustc_codegen_gcc#Motivation |website=GitHub |publisher=The Rust Programming Language |access-date=3 March 2024 |date=2 March 2024}}</ref><ref>{{cite web |title=rust-lang/rustc_codegen_cranelift |url=https://github.com/rust-lang/rustc_codegen_cranelift |website=GitHub |publisher=The Rust Programming Language |access-date=3 March 2024 |date=2 March 2024}}</ref>\n\n=== Standard library ===\nThe Rust standard library defines and implements many widely used custom data types, including core data structures such as {{code|Vec}}, {{code|Option}}, and {{code|HashMap}}, as well as [[smart pointer]] types. Rust also provides a way to exclude most of the standard library using the attribute {{rust|#![no_std]}}; this enables applications, such as embedded devices, which want to remove dependency code or provide their own core data structures. Internally, the standard library is divided into three parts, {{code|core}}, {{code|alloc}}, and {{code|std}}, where {{code|std}} and {{Code|alloc}} are excluded by {{rust|#![no_std]}}.{{sfn|Gjengset|2021|p=213-215}}\n\n[[File:Crates.io website.png|thumb|right|Screenshot of crates.io in June 2022]]\n\n=== Cargo ===\nCargo is Rust's [[Build automation|build system]] and [[package manager]]. It downloads, compiles, distributes, and uploads packages\u2014called ''crates''\u2014that are maintained in an official registry. It also acts as a front-end for Clippy and other Rust components.<ref name=\"Nature\" />\n\nBy default, Cargo sources its dependencies from the user-contributed registry ''crates.io'', but [[Git]] repositories and crates in the local filesystem, and other external sources can also be specified as dependencies.<ref>{{Cite web |last=Simone |first=Sergio De |date=2019-04-18 |title=Rust 1.34 Introduces Alternative Registries for Non-Public Crates |url=https://www.infoq.com/news/2019/04/rust-1.34-additional-registries |access-date=2022-07-14 |website=InfoQ |language=en}}</ref>\n\n=== Rustfmt ===\nRustfmt is a [[code formatter]] for Rust. It formats whitespace and [[Indentation style|indentation]] to produce code in accordance with a common [[Programming style|style]], unless otherwise specified. It can be invoked as a standalone program, or from a Rust project through Cargo.{{sfn|Klabnik|Nichols|2019|pp=511\u2013512}}\n\n[[File:Cargo clippy hello world example.png|thumb|right|Example output of Clippy on a hello world Rust program]]\n\n=== Clippy ===\nClippy is Rust's built-in [[linting]] tool to improve the correctness, performance, and readability of Rust code. {{as of|2024}}, it has more than 700 rules.<ref>{{Citation |title=Clippy |date=2023-11-30 |url=https://github.com/rust-lang/rust-clippy |access-date=2023-11-30 |publisher=The Rust Programming Language}}</ref><ref>{{Cite web |title=Clippy Lints |url=https://rust-lang.github.io/rust-clippy/master/index.html |access-date=2023-11-30 |website=The Rust Programming Language}}</ref>\n\n=== Versioning system ===\nFollowing Rust 1.0, new features are developed in ''nightly'' versions which are released daily. During each six-week release cycle, changes to nightly versions are released to beta, while changes from the previous beta version are released to a new stable version.<ref name=\"Rust Book G\">{{harvnb|Klabnik|Nichols|2019|loc=Appendix G \u2013 How Rust is Made and \"Nightly Rust\"}}</ref>\n\nEvery two or three years, a new \"edition\" is produced. Editions are released to allow making limited [[breaking changes]], such as promoting {{code|await}} to a keyword to support [[async/await]] features. Crates targeting different editions can interoperate with each other, so a crate can upgrade to a new edition even if its callers or its dependencies still target older editions. Migration to a new edition can be assisted with automated tooling.{{sfn|Blandy|Orendorff|Tindall|2021|pp=176\u2013177}}\n\n=== IDE support ===\nThe most popular [[Language Server Protocol|language server]] for Rust is ''Rust Analyzer'', which officially replaced the original language server, ''RLS'', in July 2022.<ref>{{Cite web |first=Tim |last=Anderson |date=2022-07-05 |title=Rust team releases 1.62, sets end date for deprecated language server |url=https://devclass.com/2022/07/05/rust-team-releases-1-62-sets-end-date-for-deprecated-language-server/ |access-date=2022-07-14 |website=DEVCLASS |language=en-GB}}</ref> Rust Analyzer provides [[Integrated development environment|IDE]]s and [[text editor]]s with information about a Rust project; basic features including [[autocompletion]], and the display of compilation errors while editing.{{sfn|Klabnik|Nichols|2023|p=623}}\n\n== Performance ==\nIn general, Rust's memory safety guarantees do not impose a runtime overhead.{{sfn|McNamara|2021|p=11}} A notable exception is [[Array (data structure)|array indexing]] which is checked at runtime, though this often does not impact performance.<ref>{{Cite journal |last1=Popescu |first1=Natalie |last2=Xu |first2=Ziyang |last3=Apostolakis |first3=Sotiris |last4=August |first4=David I. |last5=Levy |first5=Amit |date=2021-10-15 |title=Safer at any speed: automatic context-aware safety enhancement for Rust |url=https://doi.org/10.1145/3485480 |journal=Proceedings of the ACM on Programming Languages |volume=5 |issue=OOPSLA | quote=\"We observe a large variance in the overheads of checked indexing: 23.6% of benchmarks do report significant performance hits from checked indexing, but 64.5% report little-to-no impact and, surprisingly, 11.8% report improved performance ... Ultimately, while unchecked indexing can improve performance, most of the time it does not.\" |quote-page=5 |at=Section 2 |doi=10.1145/3485480|s2cid=238212612|doi-access=free }}</ref> Since it does not perform garbage collection, Rust is often faster than other memory-safe languages.<ref>{{Cite web |last=Anderson |first=Tim |title=Can Rust save the planet? Why, and why not |url=https://www.theregister.com/2021/11/30/aws_reinvent_rust/ |access-date=2022-07-11 |website=The Register |language=en}}</ref><ref>{{Cite book |last1=Balasubramanian |first1=Abhiram |last2=Baranowski |first2=Marek S. |last3=Burtsev |first3=Anton |last4=Panda |first4=Aurojit |last5=Rakamari\u0107 |first5=Zvonimir |last6=Ryzhyk |first6=Leonid |title=Proceedings of the 16th Workshop on Hot Topics in Operating Systems |chapter=System Programming in Rust |date=2017-05-07 |chapter-url=https://dl.acm.org/doi/10.1145/3102980.3103006 |language=en |location=Whistler BC Canada |publisher=ACM |pages=156\u2013161 |doi=10.1145/3102980.3103006 |isbn=978-1-4503-5068-6|s2cid=24100599 }}</ref><ref>{{Cite web |last=Yegulalp |first=Serdar |date=2021-10-06 |title=What is the Rust language? Safe, fast, and easy software development |url=https://www.infoworld.com/article/3218074/what-is-rust-safe-fast-and-easy-software-development.html |access-date=2022-06-25 |website=InfoWorld |language=en}}</ref>\n\nRust provides two \"modes\": safe and unsafe. Safe mode is the \"normal\" one, in which most Rust is written. In unsafe mode, the developer is responsible for the code's memory safety, which is useful for cases where the compiler is too restrictive.<ref>{{Cite web |last=Wr\u00f3bel |first=Krzysztof |date=April 11, 2022 |title=Rust projects \u2013 why large IT companies use Rust? |url=https://codilime.com/blog/rust-projects-why-large-it-companies-use-rust/ |url-status=live |archive-url=https://web.archive.org/web/20221227212821/https://codilime.com/blog/rust-projects-why-large-it-companies-use-rust/ |archive-date=2022-12-27}}</ref>\n\nMany of Rust's features are so-called ''zero-cost abstractions'', meaning they are optimized away at compile time and incur no runtime penalty.{{sfn|McNamara|2021|p=19, 27}} The ownership and borrowing system permits [[zero-copy]] implementations for some performance-sensitive tasks, such as [[parsing]].<ref>{{Cite book |last=Couprie |first=Geoffroy |title=2015 IEEE Security and Privacy Workshops |chapter=Nom, A Byte oriented, streaming, Zero copy, Parser Combinators Library in Rust |date=2015 |chapter-url=https://ieeexplore.ieee.org/document/7163218 |pages=142\u2013148 |doi=10.1109/SPW.2015.31|isbn=978-1-4799-9933-0 |s2cid=16608844 }}</ref> Static dispatch is used by default to eliminate [[method call]]s, with the exception of methods called on dynamic trait objects.{{sfn|McNamara|2021|p=20}} The compiler also uses [[inline expansion]] to eliminate [[function call]]s and statically-dispatched method invocations.<ref>{{Cite web |title=Code generation \u2013 The Rust Reference |url=https://doc.rust-lang.org/reference/attributes/codegen.html |access-date=2022-10-09 |website=doc.rust-lang.org}}</ref>\n\nSince Rust utilizes [[LLVM]], any performance improvements in LLVM also carry over to Rust.<ref name=\"how-fast-is-rust\">{{cite web |url=https://doc.rust-lang.org/1.0.0/complement-lang-faq.html#how-fast-is-rust? |title=How Fast Is Rust? |website=The Rust Programming Language FAQ |access-date=11 April 2019 |archive-date=28 October 2020 |archive-url=https://web.archive.org/web/20201028102013/https://doc.rust-lang.org/1.0.0/complement-lang-faq.html#how-fast-is-rust? |url-status=live}}</ref> Unlike C and C++, Rust allows for reordering struct and enum elements<ref>{{Cite book |url=https://dlnext.acm.org/doi/abs/10.1145/3445814.3446724 |access-date=2022-07-12 |year=2021 |language=en |doi=10.1145/3445814.3446724|quote=... While some compilers (e.g., Rust) support structure reordering [82], C & C++ compilers are forbidden to reorder data structures (e.g., struct or class) [74] ...|last1=Farshin |first1=Alireza |last2=Barbette |first2=Tom |last3=Roozbeh |first3=Amir |last4=Maguire Jr |first4=Gerald Q. |last5=Kosti\u0107 |first5=Dejan |title=Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems |chapter=PacketMill: Toward per-Core 100-GBPS networking |pages=1\u201317 |isbn=9781450383172 |s2cid=231949599}}</ref> to reduce the sizes of structures in memory, for better memory alignment, and to improve [[CPU cache|cache]] access efficiency.<ref>{{Cite web |title=Type layout |url=https://doc.rust-lang.org/reference/type-layout.html |access-date=2022-07-14 |website=The Rust Reference}}</ref>\n\n== Adoption ==\n{{See also|Category:Rust (programming language) software}}\n<!--\nIMPORTANT:\nPlease add entries only with independent published sources, e.g., news articles, not GitHub projects with no secondary source(s). For specific guidelines, see: Wikipedia:Identifying reliable sources\n-->\n[[File:Home page servo v0.01.png|thumb|right|Early homepage of Mozilla's Servo browser engine]]\nRust has been used in software across different domains. Rust was initially funded by Mozilla as part of developing Servo, an experimental [[parallel computing|parallel]] browser engine, in collaboration with [[Samsung]].<ref>{{cite news|last=Lardinois|first=Frederic|date=2015-04-03|title=Mozilla And Samsung Team Up To Develop Servo, Mozilla's Next-Gen Browser Engine For Multicore Processors|work=TechCrunch|url=https://techcrunch.com/2013/04/03/mozilla-and-samsung-collaborate-on-servo-mozillas-next-gen-browser-engine-for-tomorrows-multicore-processors/|access-date=2017-06-25|archive-date=2016-09-10|archive-url=https://web.archive.org/web/20160910211537/https://techcrunch.com/2013/04/03/mozilla-and-samsung-collaborate-on-servo-mozillas-next-gen-browser-engine-for-tomorrows-multicore-processors/|url-status=live}}</ref> Components from the Servo engine were later incorporated in the [[Gecko (software)|Gecko]] browser engine underlying Firefox.<ref>{{Cite web |last=Keizer |first=Gregg |date=2016-10-31 |title=Mozilla plans to rejuvenate Firefox in 2017 |url=https://www.computerworld.com/article/3137050/mozilla-plans-to-rejuvenate-firefox-in-2017.html |access-date=2023-05-13 |website=Computerworld |language=en}}</ref> In January 2023, Google ([[Alphabet Inc.|Alphabet]]) announced support for third party Rust libraries in [[Chromium (web browser)|Chromium]] and consequently in the [[ChromeOS]] code base.<ref>{{Cite web |title=Supporting the Use of Rust in the Chromium Project |url=https://security.googleblog.com/2023/01/supporting-use-of-rust-in-chromium.html |access-date=2023-11-12 |website=Google Online Security Blog |language=en}}</ref>\n\nRust is used in several [[Frontend and backend|backend]] software projects of large [[web service]]s. [[OpenDNS]], a [[Domain Name System|DNS]] resolution service owned by [[Cisco]], uses Rust internally.<ref>{{Cite web |last=Shankland |first=Stephen |date=2016-07-12 |title=Firefox will get overhaul in bid to get you interested again |url=https://www.cnet.com/tech/services-and-software/firefox-mozilla-gets-overhaul-in-a-bid-to-get-you-interested-again/ |access-date=2022-07-14 |publisher=CNET |language=en}}</ref><ref>{{Cite web |author=Security Research Team |date=2013-10-04 |title=ZeroMQ: Helping us Block Malicious Domains in Real Time |url=https://umbrella.cisco.com/blog/zeromq-helping-us-block-malicious-domains |access-date=2023-05-13 |website=Cisco Umbrella |language=en-US}}</ref> Amazon Web Services began developing projects in Rust as early as 2017,<ref name=\":2\">{{Cite web|date=2021-03-03|title=How our AWS Rust team will contribute to Rust's future successes|url=https://aws.amazon.com/blogs/opensource/how-our-aws-rust-team-will-contribute-to-rusts-future-successes/|access-date=2022-01-02|website=Amazon Web Services|language=en-US|archive-date=January 2, 2022|archive-url=https://web.archive.org/web/20220102233211/https://aws.amazon.com/blogs/opensource/how-our-aws-rust-team-will-contribute-to-rusts-future-successes/|url-status=live}}</ref> including [[Firecracker (software)|Firecracker]], a virtualization solution;<ref>{{Cite web|date=2018-11-26|title=Firecracker \u2013 Lightweight Virtualization for Serverless Computing|url=https://aws.amazon.com/blogs/aws/firecracker-lightweight-virtualization-for-serverless-computing/|access-date=2022-01-02|website=Amazon Web Services|language=en-US|archive-date=December 8, 2021|archive-url=https://web.archive.org/web/20211208100629/https://aws.amazon.com/blogs/aws/firecracker-lightweight-virtualization-for-serverless-computing/|url-status=live}}</ref> Bottlerocket, a [[Linux distribution]] and [[Containerization (computing)|containerization]] solution;<ref>{{Cite web |date=2020-08-31 |title=Announcing the General Availability of Bottlerocket, an open source Linux distribution built to run containers |url=https://aws.amazon.com/blogs/opensource/announcing-the-general-availability-of-bottlerocket-an-open-source-linux-distribution-purpose-built-to-run-containers/ |url-status=live |archive-url=https://web.archive.org/web/20220102233213/https://aws.amazon.com/blogs/opensource/announcing-the-general-availability-of-bottlerocket-an-open-source-linux-distribution-purpose-built-to-run-containers/ |archive-date=January 2, 2022 |access-date=2022-01-02 |website=Amazon Web Services |language=en-US}}</ref> and [[Tokio (software)|Tokio]], an asynchronous networking stack.<ref>{{Cite web |date=2020-11-24 |title=Why AWS loves Rust, and how we'd like to help |url=https://aws.amazon.com/blogs/opensource/why-aws-loves-rust-and-how-wed-like-to-help/ |access-date=2022-04-21 |website=Amazon Web Services |language=en-US |archive-date=December 3, 2020 |archive-url=https://web.archive.org/web/20201203170127/https://aws.amazon.com/blogs/opensource/why-aws-loves-rust-and-how-wed-like-to-help/ |url-status=live}}</ref> [[Microsoft Azure]] IoT Edge, a platform used to run Azure services on [[Internet of things|IoT]] devices, has components implemented in Rust.<ref>{{Cite web|url=https://www.theregister.co.uk/2018/06/27/microsofts_next_cloud_trick_kicking_things_out_of_the_cloud_to_azure_iot_edge/|title=Microsoft's next trick? Kicking things out of the cloud to Azure IoT Edge|last=Nichols|first=Shaun|date=27 June 2018|website=The Register|language=en|access-date=2019-09-27|archive-date=2019-09-27|archive-url=https://web.archive.org/web/20190927092433/https://www.theregister.co.uk/2018/06/27/microsofts_next_cloud_trick_kicking_things_out_of_the_cloud_to_azure_iot_edge/|url-status=live}}</ref> Microsoft also uses Rust to run containerized modules with [[WebAssembly]] and [[Kubernetes]].<ref>{{Cite web |last=Tung |first=Liam |title=Microsoft: Why we used programming language Rust over Go for WebAssembly on Kubernetes app |url=https://www.zdnet.com/article/microsoft-why-we-used-programming-language-rust-over-go-for-webassembly-on-kubernetes-app/ |access-date=2022-04-21 |publisher=ZDNet |language=en |archive-date=April 21, 2022 |archive-url=https://web.archive.org/web/20220421043549/https://www.zdnet.com/article/microsoft-why-we-used-programming-language-rust-over-go-for-webassembly-on-kubernetes-app/ |url-status=live}}</ref> [[Cloudflare]], a company providing [[content delivery network]] services uses Rust for its [[Firewall (computing)|firewall]] pattern matching engine and the [[Pingora]] web server.<ref>{{Cite web |date=2019-03-04 |title=How we made Firewall Rules |url=http://blog.cloudflare.com/how-we-made-firewall-rules/ |access-date=2022-06-11 |website=The Cloudflare Blog |language=en}}</ref><ref>{{Cite web |date=2019-01-22 |title=Enjoy a slice of QUIC, and Rust! |url=http://blog.cloudflare.com/enjoy-a-slice-of-quic-and-rust/ |access-date=2022-06-11 |website=The Cloudflare Blog |language=en}}</ref>\n\nIn operating systems, Rust support has been added to [[Rust for Linux|Linux]]<ref>{{Cite web |first=Tim |last=Anderson |date=2021-12-07 |title=Rusty Linux kernel draws closer with new patch |url=https://www.theregister.com/2021/12/07/rusty_linux_kernel_draws_closer/ |access-date=2022-07-14 |website=The Register |language=en}}</ref><ref>{{Cite web |title=A first look at Rust in the 6.1 kernel [LWN.net] |url=https://lwn.net/Articles/910762/ |access-date=2023-11-11 |website=lwn.net}}</ref> and [[Android (operating system)|Android]].<ref name=\":1\">{{Cite web |title=Rust in the Android platform |url=https://security.googleblog.com/2021/04/rust-in-android-platform.html |access-date=2022-04-21 |website=Google Online Security Blog |language=en |archive-date=April 3, 2022 |archive-url=https://web.archive.org/web/20220403015852/https://security.googleblog.com/2021/04/rust-in-android-platform.html |url-status=live}}</ref><ref>{{Cite web |last=Amadeo |first=Ron |date=2021-04-07 |title=Google is now writing low-level Android code in Rust |url=https://arstechnica.com/gadgets/2021/04/google-is-now-writing-low-level-android-code-in-rust/ |access-date=2022-04-21 |website=Ars Technica |language=en-us |archive-date=April 8, 2021 |archive-url=https://web.archive.org/web/20210408001446/https://arstechnica.com/gadgets/2021/04/google-is-now-writing-low-level-android-code-in-rust/ |url-status=live}}</ref> [[Microsoft]] is rewriting parts of [[Windows]] in Rust.<ref>{{Cite web |last=Claburn |first=Thomas |title=Microsoft is rewriting core Windows libraries in Rust |url=https://www.theregister.com/2023/04/27/microsoft_windows_rust/ |date=2023-04-27 |access-date=2023-05-13 |website=[[The Register]] |language=en}}</ref> The r9 project aims to re-implement [[Plan 9 from Bell Labs]] in Rust.<ref>{{cite web |last1=Proven |first1=Liam |title=Small but mighty, 9Front's 'Humanbiologics' is here for the truly curious |url=https://www.theregister.com/2023/12/01/9front_humanbiologics/ |website=The Register |publisher=The Register |access-date=7 March 2024}}</ref> Rust has been used in the development of new operating systems such as [[Redox (operating system)|Redox]], a \"Unix-like\" operating system and [[microkernel]],<ref>{{cite news |last=Yegulalp |first=Serdar |title=Rust's Redox OS could show Linux a few new tricks |url=http://www.infoworld.com/article/3046100/open-source-tools/rusts-redox-os-could-show-linux-a-few-new-tricks.html |access-date=21 March 2016 |work=InfoWorld |archive-date=21 March 2016 |archive-url=https://web.archive.org/web/20160321192838/http://www.infoworld.com/article/3046100/open-source-tools/rusts-redox-os-could-show-linux-a-few-new-tricks.html |url-status=live}}</ref> Theseus, an experimental operating system with modular state management,<ref>{{Cite web |first=Tim |last=Anderson |date=2021-01-14 |title=Another Rust-y OS: Theseus joins Redox in pursuit of safer, more resilient systems |url=https://www.theregister.com/2021/01/14/rust_os_theseus/ |access-date=2022-07-14 |website=The Register |language=en}}</ref><ref>{{Cite book |last1=Boos |first1=Kevin |last2=Liyanage |first2=Namitha |last3=Ijaz |first3=Ramla |last4=Zhong |first4=Lin |date=2020 |title=Theseus: an Experiment in Operating System Structure and State Management |url=https://www.usenix.org/conference/osdi20/presentation/boos |language=en |pages=1\u201319 |isbn=978-1-939133-19-9}}</ref> and most of [[Fuchsia (operating system)|Fuchsia]].<ref name=\"rustmag-1\">{{cite web |first1=HanDong (Alex)|last1=Zhang |title=2022 Review {{!}} The adoption of Rust in Business |url=https://rustmagazine.org/issue-1/2022-review-the-adoption-of-rust-in-business/ |date=2023-01-31 |website=Rust Magazine |access-date=February 7, 2023 |language=en}}</ref> Rust is also used for command-line tools and operating system components, including [[Stratis (configuration daemon)|stratisd]], a [[file system]] manager<ref>{{cite web |url=https://www.marksei.com/fedora-29-new-features-startis/ |title=Fedora 29 new features: Startis now officially in Fedora |last=Sei |first=Mark |date=10 October 2018 |website=Marksei, Weekly sysadmin pills |access-date=2019-05-13 |archive-date=2019-04-13 |archive-url=https://web.archive.org/web/20190413075055/https://www.marksei.com/fedora-29-new-features-startis/ |url-status=live}}</ref><ref>{{Cite web |last=Proven |first=Liam |date=2022-07-12 |title=Oracle Linux 9 released, with some interesting additions |url=https://www.theregister.com/2022/07/12/oracle_linux_9/ |access-date=2022-07-14 |website=The Register |language=en}}</ref> and COSMIC, a [[desktop environment]] by [[System76]].<ref name=\"FOSSN_()\">{{cite web |last1=Patel |first1=Pratham |title=I Tried System76's New Rust-based COSMIC Desktop! |url=https://news.itsfoss.com/system76-rust-cosmic-desktop/ |website=It's FOSS News \u2013 Development Updates |date=January 14, 2022 |publisher=It's FOSS News |access-date=10 January 2023}}</ref><ref name=\"S76_(2023)\">{{cite web |title=Pop!_OS by System76 |url=https://pop.system76.com/ |website=pop.system76.com |publisher=System76, Inc. |access-date=10 January 2023 |language=en}}</ref>\n\n[[File:Ruffle.rs demo (1).png|thumb|Ruffle, a web emulator for [[Adobe Flash]] [[SWF]] files]]\n\nIn web development, the [[npm|npm package manager]] started using Rust in production in 2019.<ref>{{Cite web |last=Simone |first=Sergio De |title=NPM Adopted Rust to Remove Performance Bottlenecks |url=https://www.infoq.com/news/2019/03/rust-npm-performance/ |access-date=2023-11-20 |website=InfoQ |language=en}}</ref><ref>{{Citation |last=Lyu |first=Shing |title=Welcome to the World of Rust |date=2020 |url=https://doi.org/10.1007/978-1-4842-5599-5_1 |work=Practical Rust Projects: Building Game, Physical Computing, and Machine Learning Applications |pages=1\u20138 |editor-last=Lyu |editor-first=Shing |access-date=2023-11-29 |place=Berkeley, CA |publisher=Apress |language=en |doi=10.1007/978-1-4842-5599-5_1 |isbn=978-1-4842-5599-5}}</ref><ref>{{Citation |last=Lyu |first=Shing |title=Rust in the Web World |date=2021 |url=https://doi.org/10.1007/978-1-4842-6589-5_1 |work=Practical Rust Web Projects: Building Cloud and Web-Based Applications |pages=1\u20137 |editor-last=Lyu |editor-first=Shing |access-date=2023-11-29 |place=Berkeley, CA |publisher=Apress |language=en |doi=10.1007/978-1-4842-6589-5_1 |isbn=978-1-4842-6589-5}}</ref> [[Deno (software)|Deno]], a secure runtime for [[JavaScript]] and [[TypeScript]], is built with [[V8 (JavaScript engine)|V8]], Rust, and Tokio.<ref>{{Cite web |first=Vivian |last=Hu |date=2020-06-12 |title=Deno Is Ready for Production |url=https://www.infoq.com/news/2020/06/deno-1-ready-production/ |access-date=2022-07-14 |website=InfoQ |language=en}}</ref> Other notable adoptions in this space include [[Ruffle (software)|Ruffle]], an open-source [[SWF]] emulator,<ref>{{Cite web |last=Abrams|first=Lawrence|date=2021-02-06|title=This Flash Player emulator lets you securely play your old games|url=https://www.bleepingcomputer.com/news/software/this-flash-player-emulator-lets-you-securely-play-your-old-games/|access-date=2021-12-25|website=BleepingComputer|language=en-us}}</ref> and [[Polkadot (cryptocurrency)|Polkadot]], an open source [[blockchain]] and [[cryptocurrency]] platform.<ref>{{Cite web |last=Kharif |first=Olga |date=October 17, 2020 |title=Ethereum Blockchain Killer Goes By Unassuming Name of Polkadot |url=https://www.bloomberg.com/news/articles/2020-10-17/ethereum-blockchain-killer-goes-by-unassuming-name-of-polkadot |url-access=subscription |access-date=July 14, 2021 |publisher=Bloomberg L.P.}}</ref>\n\n[[Discord]], an [[instant messaging]] social platform uses Rust for portions of its backend, as well as client-side [[video encoding]].<ref name=\":3\">{{cite web |last=Howarth |first=Jesse |date=2020-02-04 |title=Why Discord is switching from Go to Rust |url=https://discord.com/blog/why-discord-is-switching-from-go-to-rust |url-status=live |archive-url=https://web.archive.org/web/20200630181517/https://blog.discord.com/why-discord-is-switching-from-go-to-rust-a190bbca2b1f |archive-date=2020-06-30 |access-date=2020-04-14}}</ref> In 2021, [[Dropbox]] announced their use of Rust for a screen, video, and image capturing service.<ref>{{Cite web |last=The Dropbox Capture Team |title=Why we built a custom Rust library for Capture |url=https://dropbox.tech/application/why-we-built-a-custom-rust-library-for-capture |access-date=2022-04-21 |website=Dropbox.Tech |language=en |archive-date=April 6, 2022 |archive-url=https://web.archive.org/web/20220406142301/https://dropbox.tech/application/why-we-built-a-custom-rust-library-for-capture |url-status=live}}</ref> [[Facebook]] ([[Meta Platforms|Meta]]) used Rust for Mononoke, a server for the [[Mercurial]] version control system.<ref>{{Cite web |date=2021-04-29 |title=A brief history of Rust at Facebook |url=https://engineering.fb.com/2021/04/29/developer-tools/rust/ |access-date=2022-04-21 |website=Engineering at Meta |language=en-US |archive-date=January 19, 2022 |archive-url=https://web.archive.org/web/20220119012056/https://engineering.fb.com/2021/04/29/developer-tools/rust/ |url-status=live}}</ref>\n\nIn the 2023 [[Stack Overflow]] Developer Survey, 13% of respondents had recently done extensive development in Rust.<ref name=\"SO-2023-survey\">{{Cite web |title=Stack Overflow Developer Survey 2023 |url=https://survey.stackoverflow.co/2023/ |access-date=2023-06-25 |website=Stack Overflow}}</ref> The survey also named Rust the \"most loved programming language\" every year from 2016 to 2023 (inclusive), based on the number of developers interested in continuing to work in the same language.<ref>{{Cite web |last=Claburn |first=Thomas |date=2022-06-23 |title=Linus Torvalds says Rust is coming to the Linux kernel |url=https://www.theregister.com/2022/06/23/linus_torvalds_rust_linux_kernel/ |access-date=2022-07-15 |website=The Register |language=en}}</ref>{{refn|group=note|That is, among respondents who have done \"extensive development work [with Rust] in over the past year\" (13.05%), Rust had the largest percentage who also expressed interest to \"work in [Rust] over the next year\" (84.66%).<ref name=\"SO-2023-survey\"/>}} In 2023, Rust was the 6th \"most wanted technology\", with 31% of developers not currently working in Rust expressing an interest in doing so.<ref name=\"SO-2023-survey\" />\n\n== Community ==\n[[File:Rustacean-orig-noshadow.svg|alt=A bright orange crab icon|thumb|Some Rust users refer to themselves as Rustaceans (similar to the word [[crustacean]]) and have adopted an orange crab, Ferris, as their unofficial mascot.{{sfn|Klabnik|Nichols|2019|p=4}}<ref>{{cite web |title=Getting Started |url=https://www.rust-lang.org/learn/get-started#ferris |website=rust-lang.org |access-date=11 October 2020 |archive-date=1 November 2020 |archive-url=https://web.archive.org/web/20201101145703/https://www.rust-lang.org/learn/get-started#ferris |url-status=live}}</ref>]]\n\n=== Rust Foundation ===\n{{Infobox organization\n| name = Rust Foundation\n| logo = Rust Foundation logo.png\n| formation = {{Start date and age|2021|02|08}}\n| founders = {{unbulleted list|[[Amazon Web Services]]|[[Google]]|[[Huawei]]|[[Microsoft]]|[[Mozilla Foundation]]}}\n| type = [[Nonprofit organization]]\n| location_country = [[United States]]\n| leader_title = [[Chairperson]]\n| leader_name = Shane Miller\n| leader_title2 = [[Executive Director]]\n| leader_name2 = Rebecca Rumbul\n| website = {{URL|https://foundation.rust-lang.org}}\n}}\n\nThe '''Rust Foundation''' is a [[Nonprofit organization|non-profit]] [[membership organization]] incorporated in [[United States]], with the primary purposes of backing the technical project as a [[legal entity]] and helping to manage the trademark and infrastructure assets.<ref>{{Cite web |first=Liam |last=Tung |date=2021-02-08 |title=The Rust programming language just took a huge step forwards |url=https://www.zdnet.com/article/the-rust-programming-language-just-took-a-huge-step-forwards/ |access-date=2022-07-14 |publisher=ZDNet |language=en}}</ref><ref name=\":4\">{{Cite web |last=Brandon Vigliarolo |date=2021-02-10 |title=The Rust programming language now has its own independent foundation |url=https://www.techrepublic.com/article/the-rust-programming-language-now-has-its-own-independent-foundation/ |access-date=2022-07-14 |website=TechRepublic |language=en-US}}</ref>\n\nIt was established on February 8, 2021, with five founding corporate members (Amazon Web Services, Huawei, Google, Microsoft, and Mozilla).<ref>{{cite news|first=Paul|last=Krill|title=Rust language moves to independent foundation|url=https://www.infoworld.com/article/3606774/rust-language-moves-to-independent-foundation.html|work=[[InfoWorld]]|access-date=10 April 2021|archive-date=10 April 2021|archive-url=https://web.archive.org/web/20210410161528/https://www.infoworld.com/article/3606774/rust-language-moves-to-independent-foundation.html|url-status=live}}</ref> The foundation's board is chaired by Shane Miller.<ref>{{cite news|first=Steven J.|last=Vaughan-Nichols|date=9 April 2021|title=AWS's Shane Miller to head the newly created Rust Foundation|url=https://www.zdnet.com/article/awss-shane-miller-to-head-the-newly-created-rust-foundation/|publisher=[[ZDNet]]|access-date=10 April 2021|archive-date=10 April 2021|archive-url=https://web.archive.org/web/20210410031305/https://www.zdnet.com/article/awss-shane-miller-to-head-the-newly-created-rust-foundation/|url-status=live}}</ref> Starting in late 2021, its Executive Director and CEO is Rebecca Rumbul.<!--Q109621019--><ref>{{Cite news|url=https://www.zdnet.com/article/rust-foundation-appoints-rebecca-rumbul-as-executive-director/|title=Rust Foundation appoints Rebecca Rumbul as executive director|publisher=[[ZDNet]]|first=Steven J.|last=Vaughan-Nichols|date=17 November 2021|access-date=18 November 2021|archive-date=November 18, 2021|archive-url=https://web.archive.org/web/20211118062346/https://www.zdnet.com/article/rust-foundation-appoints-rebecca-rumbul-as-executive-director/|url-status=live}}</ref> Prior to this, Ashley Williams was interim executive director.<ref>{{Cite news|title=The Rust programming language now has its own independent foundation|url=https://www.techrepublic.com/article/the-rust-programming-language-now-has-its-own-independent-foundation/|date=February 10, 2021|access-date=2021-11-18|website=TechRepublic|language=en|archive-date=November 18, 2021|archive-url=https://web.archive.org/web/20211118143514/https://www.techrepublic.com/article/the-rust-programming-language-now-has-its-own-independent-foundation/|url-status=live}}</ref>\n\n=== Governance teams ===\nThe Rust project is composed of ''teams'' that are responsible for different subareas of the development. The compiler team develops, manages, and optimizes compiler internals; and the language team designs new language features and helps implement them. The Rust project website lists 9 top-level teams {{as of|January 2024|lc=y}}.<ref>{{Cite web |title=Governance |url=https://www.rust-lang.org/governance |access-date=2022-05-07 |website=The Rust Programming Language |language=en-US |archive-date=May 10, 2022 |archive-url=https://web.archive.org/web/20220510225505/https://www.rust-lang.org/governance |url-status=live}}</ref> Representatives among teams form the Leadership council, which oversees the Rust project as a whole.<ref>{{Cite web |title=Introducing the Rust Leadership Council |url=https://blog.rust-lang.org/2023/06/20/introducing-leadership-council.html |access-date=2024-01-12 |website=Rust Blog |language=en}}</ref><!--<ref>{{Cite web |first=Tim |last=Anderson |date=2021-11-23 |title=Entire Rust moderation team resigns |url=https://www.theregister.com/2021/11/23/rust_moderation_team_quits/ |access-date=2024-01-12 |website=The Register |language=en}}</ref>-->\n\n== See also ==\n* [[Comparison of programming languages]]\n* [[History of programming languages]]\n* [[List of programming languages]]\n* [[List of programming languages by type]]\n\n== Notes ==\n{{Reflist|group=note}}\n\n== References ==\n=== Book sources ===\n{{refbegin}}\n* {{Cite book |last=Gjengset |first=Jon |url=https://www.worldcat.org/oclc/1277511986 |title=Rust for Rustaceans |date=2021 |publisher=No Starch Press |isbn=9781718501850 |edition=1st |oclc=1277511986 |language=en}}\n* {{Cite book|last1=Klabnik|first1=Steve|url=https://books.google.com/books?id=0Vv6DwAAQBAJ|title=The Rust Programming Language (Covers Rust 2018)|last2=Nichols|first2=Carol|date=2019-08-12|publisher=No Starch Press|isbn=978-1-7185-0044-0|language=en}}\n* {{Cite book|last1=Blandy|first1=Jim|last2=Orendorff|first2=Jason|last3=Tindall|first3=Leonora F. S.|url=https://www.worldcat.org/oclc/1289839504|date=2021|edition=2nd|title=Programming Rust: Fast, Safe Systems Development|publisher=O'Reilly Media|isbn=978-1-4920-5254-8 |language=en|oclc=1289839504}}\n* {{Cite book|last1=McNamara|first1=Tim|url=https://www.worldcat.org/oclc/1153044639|title=Rust in Action|oclc=1153044639|date=2021|publisher=Manning Publications|isbn=978-1-6172-9455-6|language=en}}\n* {{Cite book |last1=Klabnik |first1=Steve |last2=Nichols |first2=Carol |url=https://www.worldcat.org/oclc/1363816350 |title=The Rust programming language |date=2023 |publisher=No Starch Press |isbn=978-1-7185-0310-6 |edition=2nd |oclc=1363816350}}\n{{refend}}\n\n=== Others ===\n{{reflist|refs=\n<ref name=\"legal\">{{cite web |url=https://www.rust-lang.org/policies/licenses |title=Rust Legal Policies |access-date=2018-04-03 |website=Rust-lang.org |archive-date=2018-04-04 |archive-url=https://web.archive.org/web/20180404073350/https://www.rust-lang.org/en-US/legal.html |url-status=live}}</ref>\n<ref name=\"influences\">{{cite web |title=Influences - The Rust Reference |url=https://doc.rust-lang.org/reference/influences.html |website=The Rust Reference |access-date=December 31, 2023 |archive-date=November 26, 2023 |archive-url=https://web.archive.org/web/20231126231034/https://doc.rust-lang.org/reference/influences.html |url-status=live}}</ref>\n<ref name=\"Jaloyan\">{{Cite arXiv|last=Jaloyan |first=Georges-Axel |date=19 October 2017 |title=Safe Pointers in SPARK 2014 |class=cs.PL |eprint=1710.07047}}</ref>\n<ref name=\"Lattner\">{{cite web |url=http://nondot.org/sabre/ |title=Chris Lattner's Homepage |last=Lattner |first=Chris |date=<!--Undated--> |website=Nondot.org |access-date=2019-05-14 |archive-date=2018-12-25 |archive-url=https://web.archive.org/web/20181225175312/http://nondot.org/sabre/ |url-status=live}}</ref>\n<ref name=\"Project Verona\">{{cite web|url=https://www.zdnet.com/article/microsoft-opens-up-rust-inspired-project-verona-programming-language-on-github/|title=Microsoft opens up Rust-inspired Project Verona programming language on GitHub|publisher=[[ZDNet]]|access-date=2020-01-17|archive-date=2020-01-17|archive-url=https://web.archive.org/web/20200117143852/https://www.zdnet.com/article/microsoft-opens-up-rust-inspired-project-verona-programming-language-on-github/|url-status=live}}</ref>\n}}\n\n==Further reading==\n* {{Cite book|last1=Blandy|first1=Jim|last2=Orendorff|first2=Jason|last3=Tindall|first3=Leonora F. S.|date=2021-07-06|title=Programming Rust: Fast, Safe Systems Development|publisher=O'Reilly Media|isbn=978-1-4920-5259-3 |language=en|ref=none}}\n\n== External links ==\n{{Sister project links|display=Rust |wikt=no |commons=Category:Rust (programming language) |b=no |n=no |q=no |s=no |v=Rust |voy=no |species=no |d=Q575650}}\n* {{Official website}}\n\n{{Programming languages}}\n{{Mozilla}}\n{{Portal bar|Computer programming}}\n{{Authority control}}\n\n[[Category:Rust (programming language)| ]]\n[[Category:Articles with example Rust code]]\n[[Category:Concurrent programming languages]]\n[[Category:Free compilers and interpreters]]\n[[Category:Free software projects]]\n[[Category:Functional languages]]\n[[Category:High-level programming languages]]\n[[Category:Mozilla]]\n[[Category:Multi-paradigm programming languages]]\n[[Category:Pattern matching programming languages]]\n[[Category:Procedural programming languages]]\n[[Category:Programming languages created in 2015]]\n[[Category:Software using the Apache license]]\n[[Category:Software using the MIT license]]\n[[Category:Statically typed programming languages]]\n[[Category:Systems programming languages]]", "sections": [{"title": null, "content": "{{Short description|General-purpose programming language}}\n{{Good article}}\n{{Use American English|date=July 2022}}\n{{Use mdy dates|date=July 2022|cs1-dates=y}}\n{{Infobox programming language\n| name = Rust\n| logo = Rust programming language black logo.svg\n| logo alt = Rust logo; a capital letter R set into a sprocket\n| paradigms = {{cslist|\n  [[Concurrent computing|Concurrent]]|\n  [[Functional programming|functional]]|\n  [[Generic programming|generic]]|\n  [[Imperative programming|imperative]]|\n  [[Structured programming|structured]]|\n}}\n| released = {{Start date and age|2015|05|15}}\n| developer = [[Rust Foundation]]\n| latest release version = {{wikidata|property|edit|reference|P548=Q2804309|P348}}\n| latest release date = {{start date and age|{{wikidata|qualifier|mdy|P548=Q2804309|P348|P577}}}}\n| typing = {{cslist|\n  [[Affine type system|Affine]]|\n  [[Type inference|inferred]]|\n  [[Nominal type system|nominal]]|\n  [[Static typing|static]]|\n  [[Strong and weak typing|strong]]|\n}}\n| programming language = Rust\n| platform = [[Cross-platform software|Cross-platform]]{{refn|group=note|Including build tools, host tools, and standard library support for [[x86-64]], [[ARM architecture family|ARM]], [[MIPS architecture|MIPS]], [[RISC-V]], [[WebAssembly]], [[P6 (microarchitecture)|i686]], [[AArch64]], [[PowerPC]], and [[Linux on IBM Z|s390x]].<ref name=CrossPlatform>{{Cite web |title=Platform Support |website=The rustc book |url=https://doc.rust-lang.org/rustc/platform-support.html |access-date=2022-06-27}}</ref>}}\n| operating system = [[Cross-platform software|Cross-platform]]{{refn|group=note|Including [[Windows]], [[Linux]], [[macOS]], [[FreeBSD]], [[NetBSD]], and [[Illumos]]. Host build tools on [[Android (operating system)|Android]], [[iOS]], [[Haiku (operating system)|Haiku]], [[Redox (operating system)|Redox]], and [[Fuchsia (operating system)|Fuchsia]] are not officially shipped; these operating systems are supported as targets.<ref name=\"CrossPlatform\" />}}\n| license = [[MIT License|MIT]] and [[Apache License|Apache 2.0]]{{refn|group=note|Third-party dependencies, e.g., [[LLVM]] or [[MSVC]], are subject to their own licenses.<ref>{{cite web |title=The Rust Programming Language |url=https://github.com/rust-lang/rust/blob/master/COPYRIGHT |publisher=The Rust Programming Language |date=19 October 2022}}</ref><ref name=\"legal\" />}}\n| file ext = <code>.rs</code>, <code>.rlib</code>\n| influenced by = {{cslist|\n  [[Alef (programming language)|Alef]]<ref name=\"influences\" />|\n  [[C Sharp (programming language)|C#]]<ref name=\"influences\" />|\n  [[C++]]<ref name=\"influences\" />|\n  [[Cyclone (programming language)|Cyclone]]<ref name=\"influences\" />|\n  [[Elm (programming language)|Elm]]<ref>{{Cite web |title=Uniqueness Types |url=https://blog.rust-lang.org/2016/08/10/Shape-of-errors-to-come.html |access-date=2016-10-08 |website= Rust Blog |quote=\"Those of you familiar with the Elm style may recognize that the updated {{mono|--explain}} messages draw heavy inspiration from the Elm approach.\"}}</ref>|\n  [[Erlang (programming language)|Erlang]]<ref name=\"influences\" />|\n  [[Haskell]]<ref name=\"influences\" />|\n  [[Limbo (programming language)|Limbo]]<ref name=\"influences\" />|\n  [[Newsqueak]]<ref name=\"influences\" />|\n  [[OCaml]]<ref name=\"influences\" />|\n  [[Ruby (programming language)|Ruby]]<ref name=\"influences\" />|\n  [[Scheme (programming language)|Scheme]]<ref name=\"influences\" />|\n  [[Standard ML]]<ref name=\"influences\" />|\n  [[Swift (programming language)|Swift]]<ref name=\"influences\" />\n}}\n| influenced = {{cslist|\n  [[Idris (programming language)|Idris]]<ref>{{Cite web |title=Uniqueness Types |url=http://docs.idris-lang.org/en/latest/reference/uniqueness-types.html |access-date=2022-07-14 |website=Idris 1.3.3 documentation |quote=\"They are inspired by ... ownership types and borrowed pointers in the Rust programming language.\"}}</ref>|\n  <!-- The article was deleted -- can be reinstated in the future if the article topic is deemed notable\n  [[Mojo (programming language)|Mojo]]<ref>{{Cite web |last=Claburn |first=Thomas |title=Modular reveals Mojo, Python superset with C-level speed |url=https://www.theregister.com/2023/05/05/modular_struts_its_mojo_a/ |access-date=2023-05-13 |website=The Register |language=en}}</ref>|\n  -->\n  [[Project Verona]]<ref name=\"Project Verona\" />|\n  [[SPARK (programming language)|Spark]]<ref name=\"Jaloyan\" />|\n  [[Swift (programming language)|Swift]]<ref name=\"Lattner\" />|\n  [[V (programming language)|V]]<ref>{{Cite web |title=V documentation (Introduction) |url=https://github.com/vlang/v/blob/master/doc/docs.md#introduction |access-date=2023-11-04|website=GitHub |language=en}}</ref>|\n  [[Zig (programming language)|Zig]]<ref>{{Cite web |last=Yegulalp |first=Serdar |date=2016-08-29 |title=New challenger joins Rust to topple C language |url=https://www.infoworld.com/article/3113083/new-challenger-joins-rust-to-upend-c-language.html |access-date=2022-10-19 |website=InfoWorld |language=en}}</ref>|\n}}\n}}\n\n'''Rust''' is a [[Programming paradigm|multi-paradigm]], [[general-purpose programming language]] that emphasizes [[computer performance|performance]], [[type safety]], and [[Concurrency (computer science)|concurrency]]. It enforces [[memory safety]]\u2014meaning that all [[reference (computer science)|references]] point to valid memory\u2014without a [[garbage collection (computer science)|garbage collector]]. To simultaneously enforce memory safety and prevent [[data race]]s, its \"borrow checker\" tracks the [[object lifetime]] of all references in a program during [[Compilation (computing)|compilation]]. Rust was influenced by ideas from [[functional programming]], including [[Immutable object|immutability]], [[higher-order function]]s, and [[algebraic data type]]s. It is popular for [[systems programming]].<ref>{{Cite book |last=Eshwarla |first=Prabhu |url=https://books.google.com/books?id=eEUREAAAQBAJ |title=Practical System Programming for Rust Developers: Build fast and secure software for Linux/Unix systems with the help of practical examples |date=2020-12-24 |publisher=Packt Publishing Ltd |isbn=978-1-80056-201-1 |language=en}}</ref><ref>{{Cite book |last1=Blandy |first1=Jim |url=https://books.google.com/books?id=h8c_DwAAQBAJ |title=Programming Rust: Fast, Safe Systems Development |last2=Orendorff |first2=Jason |date=2017-11-21 |publisher=O'Reilly Media, Inc. |isbn=978-1-4919-2725-0 |language=en}}</ref><ref>{{Cite journal |last1=Blanco-Cuaresma |first1=Sergi |last2=Bolmont |first2=Emeline |date=2017-05-30 |title=What can the programming language Rust do for astrophysics? |url=https://www.cambridge.org/core/journals/proceedings-of-the-international-astronomical-union/article/what-can-the-programming-language-rust-do-for-astrophysics/B51B6DF72B7641F2352C05A502F3D881 |journal=Proceedings of the International Astronomical Union |language=en |volume=12 |issue=S325 |pages=341\u2013344 |doi=10.1017/S1743921316013168 |arxiv=1702.02951 |bibcode=2017IAUS..325..341B |s2cid=7857871 |issn=1743-9213}}</ref>\n\nSoftware developer Graydon Hoare created Rust as a personal project while working at [[Mozilla]] Research in 2006. Mozilla officially sponsored the project in 2009. In the years following the first stable release in May 2015, Rust was adopted by companies including [[Amazon (company)|Amazon]], [[Discord]], [[Dropbox]], [[Google]] ([[Alphabet Inc.|Alphabet]]), [[Meta Platforms|Meta]], and [[Microsoft]]. In December 2022, it became the first language other than [[C (programming language)|C]] and [[Assembly language|assembly]] to be supported in the development of the [[Linux kernel]].\n\nRust has been noted for its rapid adoption,<ref name=\"Nature\">{{Cite journal |last=Perkel |first=Jeffrey M. |date=2020-12-01 |title=Why scientists are turning to Rust |url=https://www.nature.com/articles/d41586-020-03382-2 |journal=[[Nature (journal)|Nature]] |language=en |volume=588 |issue=7836 |pages=185\u2013186 |doi=10.1038/d41586-020-03382-2 |pmid=33262490 |bibcode=2020Natur.588..185P |s2cid=227251258 |access-date=May 15, 2022 |archive-date=May 6, 2022 |archive-url=https://web.archive.org/web/20220506040523/https://www.nature.com/articles/d41586-020-03382-2 |url-status=live}}</ref> and has been studied in [[programming language theory]] research.<ref>{{Cite web |title=Computer Scientist proves safety claims of the programming language Rust |url=https://www.eurekalert.org/news-releases/610682 |access-date=2022-05-15 |website=EurekAlert! |language=en |archive-date=February 24, 2022 |archive-url=https://web.archive.org/web/20220224160140/https://www.eurekalert.org/news-releases/610682 |url-status=live}}</ref><ref>{{Cite journal |last1=Jung |first1=Ralf |last2=Jourdan |first2=Jacques-Henri |last3=Krebbers |first3=Robbert |last4=Dreyer |first4=Derek |date=2017-12-27 |title=RustBelt: securing the foundations of the Rust programming language |url=https://doi.org/10.1145/3158154 |journal=Proceedings of the ACM on Programming Languages |volume=2 |issue=POPL |pages=66:1\u201366:34 |doi=10.1145/3158154 |s2cid=215791659 |access-date=May 15, 2022 |archive-date=June 11, 2022 |archive-url=https://web.archive.org/web/20220611034059/https://dl.acm.org/doi/10.1145/3158154 |url-status=live|doi-access=free |hdl=21.11116/0000-0003-34C6-3 |hdl-access=free }}</ref><ref>{{Cite thesis |last=Jung |first=Ralf |year=2020 |title=Understanding and evolving the Rust programming language |url=https://publikationen.sulb.uni-saarland.de/handle/20.500.11880/29647 |language=en |doi=10.22028/D291-31946 |access-date=May 15, 2022 |archive-date=March 8, 2022 |archive-url=https://web.archive.org/web/20220308050018/https://publikationen.sulb.uni-saarland.de/handle/20.500.11880/29647 |url-status=live |degree=PhD |publisher=[[Saarland University]]}}</ref>\n\n"}, {"title": " History ", "content": "[[File:MozillaCaliforniaHeadquarters.JPG|thumb|right|Mozilla Foundation headquarters in [[Mountain View, California]]]]\n\n=== Origins (2006\u20132012) ===\nRust grew out of a personal project begun in 2006 by [[Mozilla]] Research employee Graydon Hoare.<ref name=\"MITTechReview\">{{cite web |url=https://www.technologyreview.com/2023/02/14/1067869/rust-worlds-fastest-growing-programming-language/ |title=How Rust went from a side project to the world's most-loved programming language |last=Thompson |first=Clive |date=2023-02-14 |website=MIT Technology Review |archive-url= |archive-date= |language=en |access-date=2023-02-23}}</ref> Mozilla began sponsoring the project in 2009 as a part of the ongoing development of an experimental [[browser engine]] called [[Servo (software)|Servo]],<ref name=\"infoq2012\">{{cite web |last=Avram |first=Abel |date=2012-08-03 |title=Interview on Rust, a Systems Programming Language Developed by Mozilla |url=http://www.infoq.com/news/2012/08/Interview-Rust |url-status=live |archive-url=https://web.archive.org/web/20130724045852/http://www.infoq.com/news/2012/08/Interview-Rust |archive-date=2013-07-24 |access-date=2013-08-17 |publisher=InfoQ}}</ref> which was officially announced by Mozilla in 2010.<ref name=\"MattAsay\">{{Cite web |last=Asay |first=Matt |date=2021-04-12 |title=Rust, not Firefox, is Mozilla's greatest industry contribution |url=https://www.techrepublic.com/article/rust-not-firefox-is-mozillas-greatest-industry-contribution/ |access-date=2022-07-07 |website=TechRepublic |language=en-US}}</ref><ref>{{cite conference |last=Hoare |first=Graydon |title=Project Servo |conference=Mozilla Annual Summit 2010 |date=7 July 2010 |location=Whistler, Canada |url=http://venge.net/graydon/talks/intro-talk-2.pdf |access-date=22 February 2017 |archive-date=11 July 2017 |archive-url=https://web.archive.org/web/20170711131514/http://venge.net/graydon/talks/intro-talk-2.pdf |url-status=live}}</ref> Rust's memory and ownership system was influenced by [[region-based memory management]] in languages such as [[Cyclone (programming language)|Cyclone]] and ML Kit.<ref name=\"influences\" />\n\nAround the same time, work shifted from the initial [[compiler]] written in [[OCaml]] to a [[Self-hosting (compilers)|self-hosting compiler]] based on [[LLVM]] written in Rust. The new Rust compiler successfully [[Bootstrapping (compilers)|compiled itself]] in 2011.<ref name=\"infoq2012\"/>{{Better source needed|date=March 2024}} In the fall of 2011, the Rust logo was developed based on a bicycle [[chainring]].<ref>{{cite web |title=Rust logo |url=https://bugzilla.mozilla.org/show_bug.cgi?id=680521 |website=bugzilla.mozilla.org |access-date=2 February 2024}}</ref> \n\n=== Evolution (2012\u20132020) ===\n\nRust's [[type system]] underwent significant changes between versions 0.2, 0.3, and 0.4. In version 0.2, which was released in March 2012, [[Class (computer programming)|classes]] were introduced for the first time.<ref>{{Cite web |last=Hoare |first=Graydon |date=2012-03-29 |title=[rust-dev] Rust 0.2 released |url=https://mail.mozilla.org/pipermail/rust-dev/2012-March/001511.html |access-date=2024-04-04 |archive-date=2022-11-06 |archive-url=https://web.archive.org/web/20221106041420/https://mail.mozilla.org/pipermail/rust-dev/2012-March/001511.html |website=mail.mozilla.org}}</ref> Four months later, version 0.3 added [[destructor (computer programming)|destructor]]s and [[Polymorphism (computer science)|polymorphism]], through the use of interfaces.<ref>{{Cite web |last=Hoare |first=Graydon |date=2012-07-12 |title=[rust-dev] Rust 0.3 released |url=https://mail.mozilla.org/pipermail/rust-dev/2012-July/002087.html |access-date=2022-06-12 |website=mail.mozilla.org |archive-date=2022-08-24  |archive-url=https://web.archive.org/web/20220824145952/https://mail.mozilla.org/pipermail/rust-dev/2012-July/002087.html |url-status=dead }}</ref> In October 2012, version 0.4 was released, which added [[Trait (computer programming)|traits]] as a means of [[Inheritance (object-oriented programming)|inheritance]]. Interfaces were combined with traits and removed as a separate feature; and classes were replaced by a combination of implementations and [[record (computer science)|structured types]].<ref>{{cite web |last=Hoare |first=Graydon |title=[rust-dev] Rust 0.4 released |url=https://mail.mozilla.org/pipermail/rust-dev/2012-October/002489.html |url-status=live |archive-url=https://web.archive.org/web/20211031130755/https://mail.mozilla.org/pipermail/rust-dev/2012-October/002489.html |archive-date=October 31, 2021 |access-date=2021-10-31 |website=mail.mozilla.org|date=October 15, 2012 }}</ref>\n\nThrough the early 2010s, memory management through the ownership system was gradually consolidated to prevent memory bugs. By 2013, Rust's [[garbage collection (computer science)|garbage collector]] was removed, with the ownership rules in place.<ref name=\"MITTechReview\"/>\n\nIn January 2014, the editor-in-chief of ''[[Dr. Dobb's Journal]]'', Andrew Binstock, commented on Rust's chances of becoming a competitor to [[C++]], along with [[D (programming language)|D]], [[Go (programming language)|Go]], and [[Nim (programming language)|Nim]] (then Nimrod). According to Binstock, while Rust was \"widely viewed as a remarkably elegant language\", adoption slowed because it radically changed from version to version.<ref>{{cite news |last=Binstock |first=Andrew |date=January 7, 2014 |title=The Rise And Fall of Languages in 2013 |website=[[Dr. Dobb's Journal]] |url=https://www.drdobbs.com/jvm/the-rise-and-fall-of-languages-in-2013/240165192 |url-status=live |archive-url=https://web.archive.org/web/20160807075745/http://www.drdobbs.com/jvm/the-rise-and-fall-of-languages-in-2013/240165192 |archive-date=2016-08-07 |access-date=2022-11-20}}</ref> The first [[stable release]], Rust 1.0, was announced on May 15, 2015.<ref name=\"Version history\">{{cite web |title=Version History |website=[[GitHub]] |url=https://github.com/rust-lang/rust/blob/master/RELEASES.md |access-date=2017-01-01 |archive-date=2015-05-15 |archive-url=https://web.archive.org/web/20150515221302/https://github.com/rust-lang/rust/blob/master/RELEASES.md |url-status=live}}</ref><ref>{{cite web |url=http://blog.rust-lang.org/2015/05/15/Rust-1.0.html |title=Announcing Rust 1.0 |website=Rust Blog |author=The Rust Core Team |date=May 15, 2015 |access-date=2015-12-11 |archive-date=2015-05-15 |archive-url=https://web.archive.org/web/20150515171337/http://blog.rust-lang.org/2015/05/15/Rust-1.0.html |url-status=live}}</ref>\n\nThe development of the Servo browser engine continued alongside Rust's own growth. In September 2017, Firefox 57 was released as the first version that incorporated components from Servo, in a project named \"[[Firefox Quantum]]\".<ref>{{Cite web |last=Lardinois |first=Frederic |date=2017-09-29 |title=It's time to give Firefox another chance |url=https://techcrunch.com/2017/09/29/its-time-to-give-firefox-another-chance/ |access-date=2023-08-15 |website=TechCrunch |language=en-US}}</ref>\n\n=== Mozilla layoffs and Rust Foundation (2020\u2013present) ===\nIn August 2020, Mozilla laid off 250 of its 1,000 employees worldwide, as part of a corporate restructuring caused by the [[COVID-19 pandemic]].<ref>{{cite web |url=https://www.zdnet.com/article/mozilla-lays-off-250-employees-while-it-refocuses-on-commercial-products/ |title=Mozilla lays off 250 employees while it refocuses on commercial products |last=Cimpanu |first=Catalin |publisher=[[ZDNet]] |access-date=2020-12-02 |date=2020-08-11 |archive-date=March 18, 2022 |archive-url=https://web.archive.org/web/20220318025804/https://www.zdnet.com/article/mozilla-lays-off-250-employees-while-it-refocuses-on-commercial-products/ |url-status=live}}</ref><ref>{{cite web |url=https://www.engadget.com/mozilla-firefox-250-employees-layoffs-151324924.html |title=Mozilla lays off 250 employees due to the pandemic |website=[[Engadget]] |last=Cooper |first=Daniel |access-date=2020-12-02 |date=2020-08-11 |archive-date=2020-12-13 |archive-url=https://web.archive.org/web/20201213020220/https://www.engadget.com/mozilla-firefox-250-employees-layoffs-151324924.html |url-status=live}}</ref> The team behind Servo was disbanded. The event raised concerns about the future of Rust, as some members of the team were active contributors to Rust.<ref>{{Cite web |last=Tung |first=Liam |title=Programming language Rust: Mozilla job cuts have hit us badly but here's how we'll survive |url=https://www.zdnet.com/article/programming-language-rust-mozilla-job-cuts-have-hit-us-badly-but-heres-how-well-survive/ |access-date=2022-04-21 |publisher=ZDNet |language=en |archive-date=April 21, 2022 |archive-url=https://web.archive.org/web/20220421083509/https://www.zdnet.com/article/programming-language-rust-mozilla-job-cuts-have-hit-us-badly-but-heres-how-well-survive/ |url-status=live}}</ref> In the following week, the Rust Core Team acknowledged the severe impact of the layoffs and announced that plans for a Rust foundation were underway. The first goal of the foundation would be to take ownership of all [[trademark]]s and [[domain name]]s, and take financial responsibility for their costs.<ref>{{cite web |url=https://blog.rust-lang.org/2020/08/18/laying-the-foundation-for-rusts-future.html |title=Laying the foundation for Rust's future |website=Rust Blog |access-date=2020-12-02 |date=2020-08-18 |archive-date=2020-12-02 |archive-url=https://web.archive.org/web/20201202022933/https://blog.rust-lang.org/2020/08/18/laying-the-foundation-for-rusts-future.html |url-status=live}}</ref>\n\nOn February 8, 2021, the formation of the [[#Rust Foundation|Rust Foundation]] was announced by its five founding companies ([[Amazon Web Services|AWS]], [[Huawei]], [[Google]], [[Microsoft]], and [[Mozilla]]).<ref>{{Cite web |date=2020-02-08 |title=Hello World! |url=https://foundation.rust-lang.org/news/2021-02-08-hello-world/ |access-date=2022-06-04 |website=Rust Foundation |language=en |archive-date=April 19, 2022 |archive-url=https://web.archive.org/web/20220419124635/https://foundation.rust-lang.org/news/2021-02-08-hello-world/ |url-status=live}}</ref><ref>{{Cite web|date=2021-02-09|title=Mozilla Welcomes the Rust Foundation |website=Mozilla Blog |url=https://blog.mozilla.org/blog/2021/02/08/mozilla-welcomes-the-rust-foundation |archive-url=https://web.archive.org/web/20210208212031/https://blog.mozilla.org/blog/2021/02/08/mozilla-welcomes-the-rust-foundation/|archive-date=2021-02-08|access-date=2021-02-09|url-status=live}}</ref> In a [[blog]] post published on April 6, 2021, Google announced support for Rust within the [[Android Open Source Project]] as an alternative to C/C++.<ref>{{Cite web|last=Amadeo|first=Ron|date=2021-04-07 |title=Google is now writing low-level Android code in Rust |url=https://arstechnica.com/gadgets/2021/04/google-is-now-writing-low-level-android-code-in-rust/ |access-date=2021-04-08|website=Ars Technica|language=en-us|archive-date=2021-04-08|archive-url=https://web.archive.org/web/20210408001446/https://arstechnica.com/gadgets/2021/04/google-is-now-writing-low-level-android-code-in-rust/|url-status=live}}</ref>\n\nOn November 22, 2021, the Moderation Team, which was responsible for enforcing community standards and the Code of Conduct, announced their resignation \"in protest of the Core Team placing themselves unaccountable to anyone but themselves\".<ref name=\"moderation\">{{Cite web |first=Tim |last=Anderson |title=Entire Rust moderation team resigns |url=https://www.theregister.com/2021/11/23/rust_moderation_team_quits/ |date=2021-11-23 |access-date=2022-08-04 |website=[[The Register]] |language=en}}</ref> In May 2022, the Rust Core Team, other lead programmers, and certain members of the Rust Foundation board implemented governance reforms in response to the incident.<ref>{{Cite web |title=Governance Update |url=https://blog.rust-lang.org/inside-rust/2022/05/19/governance-update.html |access-date=2022-10-27 |website=Inside Rust Blog |language=en}}</ref>\n\nThe Rust Foundation posted a draft for a new [[trademark]] policy on April 6, 2023, revising its rules on how the Rust logo and name can be used, which resulted in negative reactions from Rust users and contributors.<ref>{{Cite web |last=Claburn |first=Thomas |title=Rust Foundation apologizes for trademark policy confusion |date=2023-04-17 |url=https://www.theregister.com/2023/04/17/rust_foundation_apologizes_trademark_policy/ |access-date=2023-05-07 |website=The Register |language=en}}</ref>\n\n"}, {"title": " Origins (2006\u20132012) ", "content": "Rust grew out of a personal project begun in 2006 by [[Mozilla]] Research employee Graydon Hoare.<ref name=\"MITTechReview\">{{cite web |url=https://www.technologyreview.com/2023/02/14/1067869/rust-worlds-fastest-growing-programming-language/ |title=How Rust went from a side project to the world's most-loved programming language |last=Thompson |first=Clive |date=2023-02-14 |website=MIT Technology Review |archive-url= |archive-date= |language=en |access-date=2023-02-23}}</ref> Mozilla began sponsoring the project in 2009 as a part of the ongoing development of an experimental [[browser engine]] called [[Servo (software)|Servo]],<ref name=\"infoq2012\">{{cite web |last=Avram |first=Abel |date=2012-08-03 |title=Interview on Rust, a Systems Programming Language Developed by Mozilla |url=http://www.infoq.com/news/2012/08/Interview-Rust |url-status=live |archive-url=https://web.archive.org/web/20130724045852/http://www.infoq.com/news/2012/08/Interview-Rust |archive-date=2013-07-24 |access-date=2013-08-17 |publisher=InfoQ}}</ref> which was officially announced by Mozilla in 2010.<ref name=\"MattAsay\">{{Cite web |last=Asay |first=Matt |date=2021-04-12 |title=Rust, not Firefox, is Mozilla's greatest industry contribution |url=https://www.techrepublic.com/article/rust-not-firefox-is-mozillas-greatest-industry-contribution/ |access-date=2022-07-07 |website=TechRepublic |language=en-US}}</ref><ref>{{cite conference |last=Hoare |first=Graydon |title=Project Servo |conference=Mozilla Annual Summit 2010 |date=7 July 2010 |location=Whistler, Canada |url=http://venge.net/graydon/talks/intro-talk-2.pdf |access-date=22 February 2017 |archive-date=11 July 2017 |archive-url=https://web.archive.org/web/20170711131514/http://venge.net/graydon/talks/intro-talk-2.pdf |url-status=live}}</ref> Rust's memory and ownership system was influenced by [[region-based memory management]] in languages such as [[Cyclone (programming language)|Cyclone]] and ML Kit.<ref name=\"influences\" />\n\nAround the same time, work shifted from the initial [[compiler]] written in [[OCaml]] to a [[Self-hosting (compilers)|self-hosting compiler]] based on [[LLVM]] written in Rust. The new Rust compiler successfully [[Bootstrapping (compilers)|compiled itself]] in 2011.<ref name=\"infoq2012\"/>{{Better source needed|date=March 2024}} In the fall of 2011, the Rust logo was developed based on a bicycle [[chainring]].<ref>{{cite web |title=Rust logo |url=https://bugzilla.mozilla.org/show_bug.cgi?id=680521 |website=bugzilla.mozilla.org |access-date=2 February 2024}}</ref> \n\n"}, {"title": " Evolution (2012\u20132020) ", "content": "\nRust's [[type system]] underwent significant changes between versions 0.2, 0.3, and 0.4. In version 0.2, which was released in March 2012, [[Class (computer programming)|classes]] were introduced for the first time.<ref>{{Cite web |last=Hoare |first=Graydon |date=2012-03-29 |title=[rust-dev] Rust 0.2 released |url=https://mail.mozilla.org/pipermail/rust-dev/2012-March/001511.html |access-date=2024-04-04 |archive-date=2022-11-06 |archive-url=https://web.archive.org/web/20221106041420/https://mail.mozilla.org/pipermail/rust-dev/2012-March/001511.html |website=mail.mozilla.org}}</ref> Four months later, version 0.3 added [[destructor (computer programming)|destructor]]s and [[Polymorphism (computer science)|polymorphism]], through the use of interfaces.<ref>{{Cite web |last=Hoare |first=Graydon |date=2012-07-12 |title=[rust-dev] Rust 0.3 released |url=https://mail.mozilla.org/pipermail/rust-dev/2012-July/002087.html |access-date=2022-06-12 |website=mail.mozilla.org |archive-date=2022-08-24  |archive-url=https://web.archive.org/web/20220824145952/https://mail.mozilla.org/pipermail/rust-dev/2012-July/002087.html |url-status=dead }}</ref> In October 2012, version 0.4 was released, which added [[Trait (computer programming)|traits]] as a means of [[Inheritance (object-oriented programming)|inheritance]]. Interfaces were combined with traits and removed as a separate feature; and classes were replaced by a combination of implementations and [[record (computer science)|structured types]].<ref>{{cite web |last=Hoare |first=Graydon |title=[rust-dev] Rust 0.4 released |url=https://mail.mozilla.org/pipermail/rust-dev/2012-October/002489.html |url-status=live |archive-url=https://web.archive.org/web/20211031130755/https://mail.mozilla.org/pipermail/rust-dev/2012-October/002489.html |archive-date=October 31, 2021 |access-date=2021-10-31 |website=mail.mozilla.org|date=October 15, 2012 }}</ref>\n\nThrough the early 2010s, memory management through the ownership system was gradually consolidated to prevent memory bugs. By 2013, Rust's [[garbage collection (computer science)|garbage collector]] was removed, with the ownership rules in place.<ref name=\"MITTechReview\"/>\n\nIn January 2014, the editor-in-chief of ''[[Dr. Dobb's Journal]]'', Andrew Binstock, commented on Rust's chances of becoming a competitor to [[C++]], along with [[D (programming language)|D]], [[Go (programming language)|Go]], and [[Nim (programming language)|Nim]] (then Nimrod). According to Binstock, while Rust was \"widely viewed as a remarkably elegant language\", adoption slowed because it radically changed from version to version.<ref>{{cite news |last=Binstock |first=Andrew |date=January 7, 2014 |title=The Rise And Fall of Languages in 2013 |website=[[Dr. Dobb's Journal]] |url=https://www.drdobbs.com/jvm/the-rise-and-fall-of-languages-in-2013/240165192 |url-status=live |archive-url=https://web.archive.org/web/20160807075745/http://www.drdobbs.com/jvm/the-rise-and-fall-of-languages-in-2013/240165192 |archive-date=2016-08-07 |access-date=2022-11-20}}</ref> The first [[stable release]], Rust 1.0, was announced on May 15, 2015.<ref name=\"Version history\">{{cite web |title=Version History |website=[[GitHub]] |url=https://github.com/rust-lang/rust/blob/master/RELEASES.md |access-date=2017-01-01 |archive-date=2015-05-15 |archive-url=https://web.archive.org/web/20150515221302/https://github.com/rust-lang/rust/blob/master/RELEASES.md |url-status=live}}</ref><ref>{{cite web |url=http://blog.rust-lang.org/2015/05/15/Rust-1.0.html |title=Announcing Rust 1.0 |website=Rust Blog |author=The Rust Core Team |date=May 15, 2015 |access-date=2015-12-11 |archive-date=2015-05-15 |archive-url=https://web.archive.org/web/20150515171337/http://blog.rust-lang.org/2015/05/15/Rust-1.0.html |url-status=live}}</ref>\n\nThe development of the Servo browser engine continued alongside Rust's own growth. In September 2017, Firefox 57 was released as the first version that incorporated components from Servo, in a project named \"[[Firefox Quantum]]\".<ref>{{Cite web |last=Lardinois |first=Frederic |date=2017-09-29 |title=It's time to give Firefox another chance |url=https://techcrunch.com/2017/09/29/its-time-to-give-firefox-another-chance/ |access-date=2023-08-15 |website=TechCrunch |language=en-US}}</ref>\n\n"}, {"title": " Mozilla layoffs and Rust Foundation (2020\u2013present) ", "content": "In August 2020, Mozilla laid off 250 of its 1,000 employees worldwide, as part of a corporate restructuring caused by the [[COVID-19 pandemic]].<ref>{{cite web |url=https://www.zdnet.com/article/mozilla-lays-off-250-employees-while-it-refocuses-on-commercial-products/ |title=Mozilla lays off 250 employees while it refocuses on commercial products |last=Cimpanu |first=Catalin |publisher=[[ZDNet]] |access-date=2020-12-02 |date=2020-08-11 |archive-date=March 18, 2022 |archive-url=https://web.archive.org/web/20220318025804/https://www.zdnet.com/article/mozilla-lays-off-250-employees-while-it-refocuses-on-commercial-products/ |url-status=live}}</ref><ref>{{cite web |url=https://www.engadget.com/mozilla-firefox-250-employees-layoffs-151324924.html |title=Mozilla lays off 250 employees due to the pandemic |website=[[Engadget]] |last=Cooper |first=Daniel |access-date=2020-12-02 |date=2020-08-11 |archive-date=2020-12-13 |archive-url=https://web.archive.org/web/20201213020220/https://www.engadget.com/mozilla-firefox-250-employees-layoffs-151324924.html |url-status=live}}</ref> The team behind Servo was disbanded. The event raised concerns about the future of Rust, as some members of the team were active contributors to Rust.<ref>{{Cite web |last=Tung |first=Liam |title=Programming language Rust: Mozilla job cuts have hit us badly but here's how we'll survive |url=https://www.zdnet.com/article/programming-language-rust-mozilla-job-cuts-have-hit-us-badly-but-heres-how-well-survive/ |access-date=2022-04-21 |publisher=ZDNet |language=en |archive-date=April 21, 2022 |archive-url=https://web.archive.org/web/20220421083509/https://www.zdnet.com/article/programming-language-rust-mozilla-job-cuts-have-hit-us-badly-but-heres-how-well-survive/ |url-status=live}}</ref> In the following week, the Rust Core Team acknowledged the severe impact of the layoffs and announced that plans for a Rust foundation were underway. The first goal of the foundation would be to take ownership of all [[trademark]]s and [[domain name]]s, and take financial responsibility for their costs.<ref>{{cite web |url=https://blog.rust-lang.org/2020/08/18/laying-the-foundation-for-rusts-future.html |title=Laying the foundation for Rust's future |website=Rust Blog |access-date=2020-12-02 |date=2020-08-18 |archive-date=2020-12-02 |archive-url=https://web.archive.org/web/20201202022933/https://blog.rust-lang.org/2020/08/18/laying-the-foundation-for-rusts-future.html |url-status=live}}</ref>\n\nOn February 8, 2021, the formation of the [[#Rust Foundation|Rust Foundation]] was announced by its five founding companies ([[Amazon Web Services|AWS]], [[Huawei]], [[Google]], [[Microsoft]], and [[Mozilla]]).<ref>{{Cite web |date=2020-02-08 |title=Hello World! |url=https://foundation.rust-lang.org/news/2021-02-08-hello-world/ |access-date=2022-06-04 |website=Rust Foundation |language=en |archive-date=April 19, 2022 |archive-url=https://web.archive.org/web/20220419124635/https://foundation.rust-lang.org/news/2021-02-08-hello-world/ |url-status=live}}</ref><ref>{{Cite web|date=2021-02-09|title=Mozilla Welcomes the Rust Foundation |website=Mozilla Blog |url=https://blog.mozilla.org/blog/2021/02/08/mozilla-welcomes-the-rust-foundation |archive-url=https://web.archive.org/web/20210208212031/https://blog.mozilla.org/blog/2021/02/08/mozilla-welcomes-the-rust-foundation/|archive-date=2021-02-08|access-date=2021-02-09|url-status=live}}</ref> In a [[blog]] post published on April 6, 2021, Google announced support for Rust within the [[Android Open Source Project]] as an alternative to C/C++.<ref>{{Cite web|last=Amadeo|first=Ron|date=2021-04-07 |title=Google is now writing low-level Android code in Rust |url=https://arstechnica.com/gadgets/2021/04/google-is-now-writing-low-level-android-code-in-rust/ |access-date=2021-04-08|website=Ars Technica|language=en-us|archive-date=2021-04-08|archive-url=https://web.archive.org/web/20210408001446/https://arstechnica.com/gadgets/2021/04/google-is-now-writing-low-level-android-code-in-rust/|url-status=live}}</ref>\n\nOn November 22, 2021, the Moderation Team, which was responsible for enforcing community standards and the Code of Conduct, announced their resignation \"in protest of the Core Team placing themselves unaccountable to anyone but themselves\".<ref name=\"moderation\">{{Cite web |first=Tim |last=Anderson |title=Entire Rust moderation team resigns |url=https://www.theregister.com/2021/11/23/rust_moderation_team_quits/ |date=2021-11-23 |access-date=2022-08-04 |website=[[The Register]] |language=en}}</ref> In May 2022, the Rust Core Team, other lead programmers, and certain members of the Rust Foundation board implemented governance reforms in response to the incident.<ref>{{Cite web |title=Governance Update |url=https://blog.rust-lang.org/inside-rust/2022/05/19/governance-update.html |access-date=2022-10-27 |website=Inside Rust Blog |language=en}}</ref>\n\nThe Rust Foundation posted a draft for a new [[trademark]] policy on April 6, 2023, revising its rules on how the Rust logo and name can be used, which resulted in negative reactions from Rust users and contributors.<ref>{{Cite web |last=Claburn |first=Thomas |title=Rust Foundation apologizes for trademark policy confusion |date=2023-04-17 |url=https://www.theregister.com/2023/04/17/rust_foundation_apologizes_trademark_policy/ |access-date=2023-05-07 |website=The Register |language=en}}</ref>\n\n"}, {"title": " Syntax and features ", "content": "Rust's [[Syntax (programming languages)|syntax]] is similar to that of [[C (programming language)|C]] and C++,<ref>{{Cite web |last=Proven |first=Liam |date=2019-11-27 |title=Rebecca Rumbul named new CEO of The Rust Foundation |url=https://www.theregister.com/2021/11/19/rust_foundation_ceo/ |access-date=2022-07-14 |website=The Register |language=en |quote=\"Both are curly bracket languages, with C-like syntax that makes them unintimidating for C programmers.\"}}</ref><ref name=\":4\" /> although many of its features were influenced by [[functional programming]] languages.{{sfn|Klabnik|Nichols|2019|p=263}} Hoare described Rust as targeted at \"frustrated C++ developers\" and emphasized features such as safety, control of [[memory map|memory layout]], and [[Concurrency (computer science)|concurrency]].<ref name=\"infoq2012\"/> Safety in Rust includes the guarantees of memory safety, type safety, and lack of data races.\n\n=== Hello World program ===\nBelow is a [[\"Hello, World!\" program]] in Rust. The {{Rust|fn}} keyword denotes a [[Function (computer programming)|function]], and the <code>println!</code> [[Macro (computer science)|macro]] prints the message to [[standard output]].{{sfn|Klabnik|Nichols|2019|pp=5\u20136}} [[Statement (computer science)|Statements]] in Rust are [[Semicolon#Programming|separated]] by semicolons.\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    println!(\"Hello, World!\");\n}\n</syntaxhighlight>\n\n=== Keywords and control flow ===\nIn Rust, blocks of code are delimited by [[Bracket#Curly brackets|curly brackets]], and [[control flow]] is implemented by keywords including <code>[[Conditional (computer programming)|if]]</code>, <code>else</code>, <code>[[While loop|while]]</code>, and <code>[[For loop|for]]</code>.{{sfn|Klabnik|Nichols|2019|pp=49\u201357}} [[Pattern matching]] can be done using the {{Rust|match}} keyword.{{sfn|Klabnik|Nichols|2019|pp=104\u2013109}} In the examples below, explanations are given in [[comment (computer programming)|comment]]s, which start with {{code|//}}.{{sfn|Klabnik|Nichols|2019|p=49}}\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    // Defining a mutable variable with 'let mut'\n    // Using the macro vec! to create a vector\n    let mut values = vec![1, 2, 3, 4];\n\n    for value in &values {\n        println!(\"value = {}\", value);\n    }\n\n    if values.len() > 5 {\n        println!(\"List is longer than five items\");\n    }\n\n    // Pattern matching\n    match values.len() {\n        0 => println!(\"Empty\"),\n        1 => println!(\"One value\"),\n        // pattern matching can use ranges of integers\n        2..=10 => println!(\"Between two and ten values\"),\n        11 => println!(\"Eleven values\"),\n        // A `_` pattern is called a \"wildcard\", it matches any value\n        _ => println!(\"Many values\"),\n    };\n\n    // while loop with predicate and pattern matching using let\n    while let Some(value) = values.pop() {\n        println!(\"value = {value}\"); // using curly brackets to format a local variable\n    }\n}\n</syntaxhighlight>\n\n=== Expression blocks ===\nRust is [[Expression-oriented programming language|expression-oriented]], with nearly every part of a function body being an [[Expression (computer science)|expression]], including control-flow operators.{{sfn|Klabnik|Nichols|2019|pp=50\u201353}} The ordinary <code>if</code> expression is used instead of [[?:|C's ternary conditional]]. With returns being implicit, a function does not need to end with a <code>return</code> expression; if the semicolon is omitted, the value of the last expression in the function is used as the [[return value]],<ref>{{Cite web |last=Tyson |first=Matthew |date=2022-03-03 |title=Rust programming for Java developers |url=https://www.infoworld.com/article/3651362/rust-programming-for-java-developers.html |access-date=2022-07-14 |website=InfoWorld |language=en}}</ref> as seen in the following [[Recursion (computer science)|recursive]] implementation of the [[factorial]] function:\n\n<syntaxhighlight lang=\"rust\">\nfn factorial(i: u64) -> u64 {\n    if i == 0 {\n        1\n    } else {\n        i * factorial(i - 1)\n    }\n}\n</syntaxhighlight>\n\nThe following [[Iteration (computer science)|iterative]] implementation uses the <code>..=</code> operator to create an inclusive range:\n\n<syntaxhighlight lang=\"rust\">\nfn factorial(i: u64) -> u64 {\n    (2..=i).product()\n}\n</syntaxhighlight>\n\n==== Closures ====\n{{excerpt|Anonymous function|Rust|subsections=yes}}\n\n=== Types ===\nRust is [[strongly typed]] and [[statically typed]]. The types of all variables must be known at compilation time; assigning a value of a particular type to a differently typed variable causes a [[compilation error]]. Variables are declared with the [[Reserved word|keyword]] <code>let</code>, and type inference is used to determine their type.{{sfn|Klabnik|Nichols|2019|pp=24}} Variables assigned multiple times must be marked with the keyword <code>mut</code> (short for mutable).{{sfn|Klabnik|Nichols|2019|pp=32\u201333}}\n\nThe default integer type is {{rust|i32}}, and the default [[floating point]] type is {{rust|f64}}. If the type of a [[Literal (computer programming)|literal]] number is not explicitly provided, either it is [[type inference|inferred]] from the context or the default type is used.{{sfn|Klabnik|Nichols|2019|pp=36\u201338}}\n\n==== Primitive types ====\n{| class=\"wikitable\"\n|+Summary of Rust's [[Primitive data type|Primitive Types]]\n!Type\n!Description\n!Examples\n|-\n|{{rust|bool}}\n|[[Boolean value]]\n|{{plainlist|\n* {{rust|true}}\n* {{rust|false}}\n  }}\n|-\n|{{rust|u8}}\n|Unsigned [[8-bit integer]] (a [[byte]])\n|{{plainlist|\n* {{rust|255u8}}<ref group=\"note\" name=\"ExplicitSuffix\">This literal uses an explicit suffix, which is not needed when type can be inferred from the context</ref>\n* {{Rust|b'W'}} ([[ASCII]] encoded byte)\n  }}\n|-\n|{{plainlist|\n* {{rust|i8}}\n* {{rust|i16}}\n* {{rust|i32}}\n* {{rust|i64}}\n* {{rust|i128}}\n  }}\n|[[Signed integer]]s, up to [[128-bit computing|128 bits]]\n|{{plainlist|\n* {{rust|7}}<ref group=\"note\" name=\"Default\">Interpreted as {{rust|i32}} by default, or inferred from the context</ref>\n* {{rust|7i128}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n  }}\n|-\n|{{plainlist|\n* {{rust|u16}}\n* {{rust|u32}}\n* {{rust|u64}}\n* {{rust|u128}}\n  }}\n|[[Unsigned integer]]s, up to [[128-bit computing|128 bits]]\n|{{plainlist|\n* {{rust|14}}<ref group=\"note\" name=\"Inferred\">Type inferred from the context</ref>\n* {{rust|14u128}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n  }}\n|-\n|{{plainlist|\n* {{rust|usize}}\n* {{rust|isize}}\n  }}\n|[[Pointer (computer programming)|Pointer]]-sized integers (size depends on [[computing platform|platform]])\n|{{plainlist|\n* {{rust|14usize}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n* {{rust|-2isize}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n  }}\n|-\n|{{plainlist|\n* {{rust|f32}}\n* {{rust|f64}}\n  }}\n|[[Floating-point arithmetic|Floating-point number]]s\n|{{plainlist|\n* {{rust|-3f32}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n  }}\n|-\n|{{Rust|char}}\n|{{Plainlist|\n* [[UTF-32]] scalar value (occupies 4 bytes)\n* A [[Unicode codepoint]] that is not a [[Universal Character Set characters#Surrogates|surrogate]]{{sfn|Klabnik|Nichols|2019|pp=39\u201340}}\n  }}\n|{{plainlist|\n* {{Rust|'a'}}\n* {{Rust|'\u8bed'}}\n* {{Rust|'\ud83e\udd80'}} ([[Emoji]])\n* {{Rust|'\\u{200D}'}} (Unicode escape, [[zero-width joiner]])\n  }}\n|-\n|{{Rust|str}}\n|[[UTF-8]]-encoded string slice, the primitive string type. It is usually seen in its borrowed form, {{Rust|&str}}. It is also the type of string literals, {{Rust|&'static str}}<ref>{{Cite web |title=str \u2013 Rust |url=https://doc.rust-lang.org/beta/std/primitive.str.html |access-date=2023-06-23 |website=doc.rust-lang.org}}</ref>\n|{{plainlist|\n* {{Rust|\"Hello\"}}\n* {{Rust|\"3\"}}\n* {{Rust|\"\ud83e\udd80\ud83e\udd80\ud83e\udd80\"}}\n  }}\n|-\n|{{Rust|[T; N]}}\n|[[Array (data structure)|Array]] \u2013 collection of N objects of the same type T, stored in contiguous memory\n|{{plainlist|\n* {{Rust|[2, 4, 6]}}\n* {{Rust|[0; 100]}}\n* {{Rust|b\"Hello\"}}\n  }}\n|-\n|{{Rust|[T]}}\n|Slice \u2013 a dynamically-sized view into a contiguous sequence<ref>{{Cite web |title=slice \u2013 Rust |url=https://doc.rust-lang.org/beta/std/primitive.slice.html |access-date=2023-06-23 |website=doc.rust-lang.org}}</ref>\n|{{plainlist|\n* {{Rust|[1, 2, 3, 4, 5][..i]}}\n* {{Rust|\"Hello, world!\".as_bytes()}}\n* {{Rust|let v {{=}} vec![1, 2, 3]; v.as_slice()}}\n  }}\n|-\n|{{plainlist|{{Rust|(T, U, ..)}}}}\n|[[Tuple]] \u2013 a finite heterogeneous sequence\n|{{plainlist|\n* {{Rust|()}} (An empty tuple, the [[unit type]] in Rust)\n* {{Rust|(5,)}} ({{Rust|(5)}} is parsed as an integer)<ref>{{Cite web |title=Tuples |url=https://doc.rust-lang.org/rust-by-example/primitives/tuples.html |access-date=2023-10-01 |website=Rust By Example}}</ref>\n* {{Rust|(\"Age\", 10)}}\n* {{Rust|(1, true, \"Name\")}}\n  }}\n|-\n| {{Rust|!}}\n| [[Bottom type|Never type]] (unreachable value)\n| {{Rust|let x {{=}} { return 123 };}}\n|}\n\n==== Standard library ====\n{| class=\"wikitable\"\n|+Summary of Rust's types in the [[standard library]]\n!Type\n!Description\n!Examples\n|-\n|{{Rust|String}}\n|UTF-8-encoded strings (dynamic)\n|{{plainlist|\n* {{Rust|String::new()}}\n* {{Rust|String::from(\"Hello\")}}\n* {{Rust|\"\ud83e\udd80\ud83e\udd80\ud83e\udd80\".to_string()}}\n  }}\n|-\n|{{plainlist|\n* {{Rust|OsStr}}\n* {{Rust|OsString}}\n  }}\n|Platform-native strings<ref group=\"note\" name=\"OsString\">On Unix systems, this is often UTF-8 strings without an internal 0 byte. On Windows, this is [[UTF-16]] strings without an internal 0 byte. Unlike these, {{Rust|str}} and {{Rust|String}} are always valid UTF-8 and can contain internal zeros.</ref> (borrowed<ref>{{Cite web |title=OsStr in std::ffi \u2013 Rust |url=https://doc.rust-lang.org/beta/std/ffi/struct.OsStr.html |access-date=2023-10-02 |website=doc.rust-lang.org}}</ref> and dynamic<ref>{{Cite web |title=OsString in std::ffi \u2013 Rust |url=https://doc.rust-lang.org/beta/std/ffi/struct.OsString.html |access-date=2023-10-02 |website=doc.rust-lang.org}}</ref>)\n|{{plainlist|\n* {{Rust|OsStr::new(\"Hello\")}}\n* {{Rust|OsString::from(\"world\")}}\n  }}\n|-\n|{{plainlist|\n* {{Rust|Path}}\n* {{Rust|PathBuf}}\n  }}\n|[[Path (computing)|Paths]] (borrowed<ref>{{Cite web |title=Path in std::path \u2013 Rust |url=https://doc.rust-lang.org/beta/std/path/struct.Path.html |access-date=2023-10-02 |website=doc.rust-lang.org}}</ref> and dynamic<ref>{{Cite web |title=PathBuf in std::path \u2013 Rust |url=https://doc.rust-lang.org/beta/std/path/struct.PathBuf.html |access-date=2023-10-02 |website=doc.rust-lang.org}}</ref>)\n|{{plainlist|\n* {{Rust|Path::new(\"./path/to\")}}\n* {{Rust|PathBuf::from(r\"C:.\\path\\to\")}}\n  }}\n|-\n|{{plainlist|\n* {{Rust|CStr}}\n* {{Rust|CString}}\n  }}\n|[[C (programming language)|C]]-compatible, [[null-terminated string]]s (borrowed<ref name=\"std::boxed \u2013 Rust\">{{Cite web |title=std::boxed \u2013 Rust |url=https://doc.rust-lang.org/std/boxed/index.html |access-date=2023-06-23 |website=doc.rust-lang.org}}</ref> and dynamic<ref name=\"std::boxed \u2013 Rust\"/>)\n|{{plainlist|\n* {{Rust|CStr::from_bytes_with_nul(b\"Hello\\0\").unwrap()}}\n* {{Rust|CString::new(\"world\").unwrap()}}\n  }}\n|-\n|{{Rust|Vec<T>}}\n|[[Dynamic array]]s\n|{{plainlist|\n* {{Rust|Vec::new()}}\n* {{Rust|vec![1, 2, 3, 4, 5]}}\n  }}\n|-\n|{{Rust|Option<T>}}\n|[[Option type]]\n|{{plainlist|\n* {{Rust|None}}\n* {{Rust|Some(3)}}\n* {{Rust|Some(\"hello\")}}\n  }}\n|-\n|{{Rust|Result<T, E>}}\n|[[Exception handling|Error handling]] using a [[result type]]\n|{{plainlist|\n* {{Rust|Ok(3)}}\n* {{Rust|Err(\"something went wrong\")}}\n  }}\n|-\n|{{Rust|Box<T>}}\n|A pointer to a [[Heap (programming)|heap]]-allocated value<ref>{{Cite web |title=std::boxed \u2013 Rust |url=https://doc.rust-lang.org/std/boxed/index.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>. Similar to C++'s [https://en.cppreference.com/w/cpp/memory/unique_ptr std::unique_ptr].\n| <syntaxhighlight lang=\"rust\">\nlet boxed: Box<u8> = Box::new(5);\nlet val: u8 = *boxed;\n</syntaxhighlight>\n|-\n|{{Rust|Rc<T>}}\n|[[Reference counting]] pointer<ref>{{Cite web |title=Rc in std::rc \u2013 Rust |url=https://doc.rust-lang.org/beta/std/rc/struct.Rc.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet five = Rc::new(5);\nlet also_five = five.clone();\n</syntaxhighlight>\n|-\n|{{Rust|Arc<T>}}\n|[[Linearizability|Atomic]], [[Thread safety|thread-safe]] reference counting pointer<ref>{{Cite web |title=Arc in std::sync \u2013 Rust |url=https://doc.rust-lang.org/beta/std/sync/struct.Arc.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet foo = Arc::new(vec![1.0, 2.0]);\nlet a = foo.clone(); // a can be sent to another thread\n</syntaxhighlight>\n|-\n|{{Rust|Cell<T>}}\n|A mutable memory location<ref>{{Cite web |title=Cell in std::cell \u2013 Rust |url=https://doc.rust-lang.org/beta/std/cell/struct.Cell.html# |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet c = Cell::new(5);\nc.set(10);\n</syntaxhighlight>\n|-\n|<code>Mutex<T></code>\n|A [[Lock (computer science)|mutex lock]] for shared data contained within.<ref>{{Cite web |title=Mutex in std::sync \u2013 Rust |url=https://doc.rust-lang.org/beta/std/sync/struct.Mutex.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet mutex = Mutex::new(0_u32);\nlet _guard = mutex.lock();\n</syntaxhighlight>\n|-\n|{{Rust|RwLock<T>}}\n|[[Readers\u2013writer lock]]<ref>{{Cite web |title=RwLock in std::sync \u2013 Rust |url=https://doc.rust-lang.org/beta/std/sync/struct.RwLock.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet lock = RwLock::new(5);\nlet r1 = lock.read().unwrap();\n</syntaxhighlight>\n|-\n|{{Rust|Condvar}}\n|A [[Monitor (synchronization)|conditional monitor]] for shared data<ref>{{Cite web |title=Condvar in std::sync \u2013 Rust |url=https://doc.rust-lang.org/beta/std/sync/struct.Condvar.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\n let (lock, cvar) = (Mutex::new(true), Condvar::new());\n// As long as the value inside the `Mutex<bool>` is `true`, we wait.\nlet _guard = cvar.wait_while(lock.lock().unwrap(), |pending| { *pending }).unwrap();\n\n</syntaxhighlight>\n|-\n|{{Rust|Duration}}\n|Type that represents a span of time<ref>{{Cite web |title=Duration in std::time \u2013 Rust |url=https://doc.rust-lang.org/beta/std/time/struct.Duration.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nDuration::from_millis(1) // 1ms\n</syntaxhighlight>\n|-\n|{{Rust|1=HashMap<K, V>}}\n|[[Hash table]]<ref>{{Cite web |title=HashMap in std::collections \u2013 Rust |url=https://doc.rust-lang.org/beta/std/collections/struct.HashMap.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet mut player_stats = HashMap::new();\nplayer_stats.insert(\"damage\", 1);\nplayer_stats.entry(\"health\").or_insert(100);\n</syntaxhighlight>\n|-\n|{{Rust|1=BTreeMap<K, V>}}\n|[[B-tree]]<ref>{{Cite web |title=BTreeMap in std::collections \u2013 Rust |url=https://doc.rust-lang.org/beta/std/collections/struct.BTreeMap.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet mut solar_distance = BTreeMap::from([\n    (\"Mercury\", 0.4),\n    (\"Venus\", 0.7),\n]);\nsolar_distance.entry(\"Earth\").or_insert(1.0);\n\n</syntaxhighlight>\n|}\n\n[[Option type|<code>Option</code>]] values are handled using [[syntactic sugar]], such as the <code>if let</code> construction, to access the inner value (in this case, a string):{{sfn|McNamara|2021}}\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    let name1: Option<&str> = None;\n    // In this case, nothing will be printed out\n    if let Some(name) = name1 {\n        println!(\"{name}\");\n    }\n\n    let name2: Option<&str> = Some(\"Matthew\");\n    // In this case, the word \"Matthew\" will be printed out\n    if let Some(name) = name2 {\n        println!(\"{name}\");\n    }\n}\n</syntaxhighlight>\n\n==== Pointers ====\n{| class=\"wikitable\"\n|+Summary of Rust's [[Pointer (computer programming)|pointer]] and [[Reference (computer science)|reference]] primitive types\n!Type\n!Description\n!Examples\n|-\n|{{plainlist|\n* {{Rust|&T}}\n* {{Rust|&mut T}}\n  }}\n|[[Reference (computer science)|References]] (immutable and mutable)\n|{{plainlist|\n* {{Rust|let x_ref {{=}} {{not a typo|&x;}}}}\n* {{Rust|let x_ref {{=}} &mut x;}}\n  }}\n|-\n|{{plainlist|\n* {{Rust|Option<&T>}}\n* {{Rust|Option<&mut T>}}\n  }}\n|{{plainlist|\n* Option wrapped reference\n* Possibly null reference\n  }}\n|{{plainlist|\n* {{Rust|None}}\n* {{Rust|let x_ref {{=}} Some(&x);}}\n* {{Rust|let x_ref {{=}} Some(&mut x);}}\n  }}\n|-\n|{{Plain list|* {{Rust|Box<T>}}\n* {{Rust|Option<Box<T>>}}}}\n|A pointer to heap-allocated value\n(or possibly null pointer if wrapped in option)<ref name=\"std::boxed \u2013 Rust\"/>\n|{{Plain list|* {{Rust|let boxed {{=}} Box::new(0);}}\n* {{Rust|let boxed {{=}} Some(Box::new(\"Hello World\"));}}}}\n|-\n|{{Plainlist|\n* {{Rust|*const T}}\n* {{Rust|*mut T}}\n  }}\n|{{Plainlist|\n* Raw pointers (immutable and mutable)\n* Possibly [[Null pointer|null]]; {{Rust|unsafe}} to [[dereference]]\n  }}\n|{{Plainlist|\n* {{Rust|let x_ptr {{=}} &x as *const T;}}\n* {{Rust|let x_ptr {{=}} &mut x as *mut T;}}\n  }}\n|}\n\nRust does not use [[null pointer]]s to indicate a lack of data, as doing so can lead to [[Null pointer#Null dereferencing|null dereferencing]]. Accordingly, the basic <code>&</code> and <code>&mut</code> references are guaranteed to not be null. Rust instead uses <code>Option</code> for this purpose: <code>Some(T)</code> indicates that a value is present, and <code>None</code> is analogous to the null pointer.{{sfn|Klabnik|Nichols|2019|pp=101\u2013104}} <code>Option</code> implements a \"null pointer optimization\", avoiding any spatial overhead for types that cannot have a null value (references or the <code>NonZero</code> types, for example).<ref>{{Cite web |title=std::option - Rust |url=https://doc.rust-lang.org/std/option/index.html#representation |access-date=2023-11-12 |website=doc.rust-lang.org}}</ref>\n\nUnlike references, the raw pointer types <code>*const</code> and <code>*mut</code> may be null; however, it is impossible to dereference them unless the code is explicitly declared unsafe through the use of an <code>unsafe</code> block. Unlike dereferencing, the creation of raw pointers is allowed inside of safe Rust code.{{sfn|Klabnik|Nichols|2019|pp=418\u2013427}}\n\n==== User-defined types ====\nUser-defined types are created with the <code>struct</code> or <code>enum</code> keywords. The <code>struct</code> keyword is used to denote a [[Record (computer science)|record type]] that groups multiple related values.{{sfn|Klabnik|Nichols|2019|p=83}} <code>enum</code>s can take on different variants at runtime, with its capabilities similar to [[algebraic data types]] found in functional programming languages.{{sfn|Klabnik|Nichols|2019|p=97}} Both structs and enums can contain [[Field (computer science)|fields]] with different types.{{sfn|Klabnik|Nichols|2019|pp=98\u2013101}} Alternative names for the same type can be defined with the <code>type</code> keyword.{{sfn|Klabnik|Nichols|2019|pp=438\u2013440}}\n\nThe <code>impl</code> keyword can define methods for a user-defined type (data and functions are defined separately). Implementations fulfill a role similar to that of classes within other languages.{{sfn|Klabnik|Nichols|2019|pp=93}}\n\n==== Type conversion ====\n{{excerpt|Type conversion|Rust}}\n\n=== Ownership and lifetimes ===\nRust's ownership system consists of rules that ensure memory safety without using a garbage collector. At compile time, each value must be attached to a variable called the ''owner'' of that value, and every value must have exactly one owner.{{sfn|Klabnik|Nichols|2019|pp=59\u201361}} Values are moved between different owners through assignment or passing a value as a function parameter.  Values can also be ''borrowed,'' meaning they are temporarily passed to a different function before being returned to the owner.{{sfn|Klabnik|Nichols|2019|pp=63\u201368}} With these rules, Rust can prevent the creation and use of [[dangling pointers]]:{{sfn|Klabnik|Nichols|2019|pp=63\u201368}}{{sfn|Klabnik|Nichols|2019|pp=74\u201375}}\n\n<syntaxhighlight lang=\"rust\">\nfn print_string(s: String) {\n    println!(\"{}\", s);\n}\n\nfn main() {\n    let s = String::from(\"Hello, World\");\n    print_string(s); // s consumed by print_string\n    // s has been moved, so cannot be used any more\n    // another print_string(s); would result in a compile error\n}\n</syntaxhighlight>\n\nBecause of these ownership rules, Rust types are known as ''[[linear types|linear]]'' or ''affine'' types, meaning each value can be used exactly once. This enforces a form of [[software fault isolation]] as the owner of a value is solely responsible for its correctness and deallocation.<ref name=\"BeyondSafety\">{{Cite book |last1=Balasubramanian |first1=Abhiram |last2=Baranowski |first2=Marek S. |last3=Burtsev |first3=Anton |last4=Panda |first4=Aurojit |last5=Rakamari\u0107 |first5=Zvonimir |last6=Ryzhyk |first6=Leonid |title=Proceedings of the 16th Workshop on Hot Topics in Operating Systems |chapter=System Programming in Rust |date=2017-05-07 |chapter-url=https://doi.org/10.1145/3102980.3103006 |series=HotOS '17 |location=New York, NY, US |publisher=Association for Computing Machinery |pages=156\u2013161 |doi=10.1145/3102980.3103006 |isbn=978-1-4503-5068-6 |s2cid=24100599 |access-date=June 1, 2022 |archive-date=June 11, 2022 |archive-url=https://web.archive.org/web/20220611034046/https://dl.acm.org/doi/10.1145/3102980.3103006 |url-status=live}}</ref>\n\nWhen a value goes out of scope, it is ''dropped'' by running its [[Destructor (computer programming)|destructor]]. The destructor may be programmatically defined through implementing the {{code|Drop}} [[#Traits|trait]]. This helps manage resources such as file handles, network sockets, and [[Lock (computer science)|locks]], since when objects are dropped, the resources associated with them are closed or released automatically.{{sfn|Klabnik|Nichols|2023|pp=327-30}}\n\n''Lifetimes'' are usually an implicit part of all [[Reference (computer science)|reference types]] in Rust. Each lifetime encompasses a set of locations in the code for which a variable is valid. For example, a reference to a local variable has a lifetime corresponding to the block it is defined in:{{sfn|Klabnik|Nichols|2019|p=194}}\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    let x = 5;                              // ------------------+- Lifetime 'b\n                                            //                   |\n    let r = &x;                             // -+-- Lifetime 'a  |\n                                            //  |                |\n    println!(\"r: {}\", r);                   //  |                |\n                                            //  |                |\n                                            // -+                |\n}                                           // ------------------+\n</syntaxhighlight>\n\nThe borrow checker in the Rust compiler uses lifetimes to ensure that the values a reference points to remain valid.{{sfn|Klabnik|Nichols|2019|pp=75,134}}<ref>{{Cite web |last=Shamrell-Harrington |first=Nell |title=The Rust Borrow Checker \u2013 a Deep Dive |url=https://www.infoq.com/presentations/rust-borrow-checker/ |access-date=2022-06-25 |website=InfoQ |language=en}}</ref> In the example above, storing a reference to variable {{code|x}} to {{code|r}} is valid, as variable {{code|x}} has a longer lifetime ({{code|'b}}) than variable {{code|r}} ({{code|'a}}). However, when {{code|x}} has a shorter lifetime, the borrow checker would reject the program:\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    let r;                                  // ------------------+- Lifetime 'a\n                                            //                   |\n    {                                       //                   |\n        let x = 5;                          // -+-- Lifetime 'b  |\n        r = x;                              //  |                |\n    }                                       //  |                |\n                                            //                   |\n    println!(\"r: {}\", r);                   //                   |\n}                                           // ------------------+\n</syntaxhighlight>\n\nSince the lifetime of the referenced variable ({{code|'b}}) is shorter than the lifetime of the variable holding the reference ({{code|'a}}), the borrow checker errors, preventing {{code|x}} from being used from outside its scope.{{sfn|Klabnik|Nichols|2019|pp=194-195}}\n\nRust defines the relationship between the lifetimes of the objects created and used by functions, using ''lifetime parameters'', as a signature feature.{{sfn|Klabnik|Nichols|2019|pp=192\u2013204}}\n\nThe example below parses some configuration options from a string and creates a struct containing the options. The struct only contains references to the data; so, for the struct to remain valid, the data referred to by the struct must be valid as well. The function signature for <code>parse_config</code> specifies this relationship explicitly. In this example, the explicit lifetimes are unnecessary in newer Rust versions, due to lifetime elision, which is an algorithm that automatically assigns lifetimes to functions if they are trivial.{{sfn|Klabnik|Nichols|2019|pp=201\u2013203}}\n\n<syntaxhighlight lang=\"rust\">\nuse std::collections::HashMap;\n\n// This struct has one lifetime parameter, 'src. The name is only used within the struct's definition.\n#[derive(Debug)]\nstruct Config<'src> {\n    hostname: &'src str,\n    username: &'src str,\n}\n\n// This function also has a lifetime parameter, 'cfg. 'cfg is attached to the \"config\" parameter, which\n// establishes that the data in \"config\" lives at least as long as the 'cfg lifetime.\n// The returned struct also uses 'cfg for its lifetime, so it can live at most as long as 'cfg.\nfn parse_config<'cfg>(config: &'cfg str) -> Config<'cfg> {\n    let key_values: HashMap<_, _> = config\n        .lines()\n        .filter(|line| !line.starts_with('#'))\n        .filter_map(|line| line.split_once('='))\n        .map(|(key, value)| (key.trim(), value.trim()))\n        .collect();\n    Config {\n        hostname: key_values[\"hostname\"],\n        username: key_values[\"username\"],\n    }\n}\n\nfn main() {\n    let config = parse_config(\n        r#\"hostname = foobar\nusername=barfoo\"#,\n    );\n    println!(\"Parsed config: {:#?}\", config);\n}\n</syntaxhighlight>\n\n[[File:Rust 101.webm|thumb|A presentation on Rust by Emily Dunham from [[Mozilla]]'s Rust team ([[linux.conf.au]] conference, Hobart, 2017)]]\n\n=== Memory safety ===\nRust is designed to be [[memory safe]]. It does not permit null pointers, [[dangling pointer]]s, or [[data race]]s.<ref name=\"cnet\">{{cite web |url=http://reviews.cnet.com/8301-3514_7-57577639/samsung-joins-mozillas-quest-for-rust/ |title=Samsung joins Mozilla's quest for Rust |last=Rosenblatt |first=Seth |date=2013-04-03 |publisher=[[CNET]] |access-date=2013-04-05 |archive-date=2013-04-04 |archive-url=https://web.archive.org/web/20130404142333/http://reviews.cnet.com/8301-3514_7-57577639/samsung-joins-mozillas-quest-for-rust/ |url-status=live}}</ref><ref name=\"lwn\">{{cite web |url=https://lwn.net/Articles/547145/ |title=A taste of Rust |last=Brown |first=Neil |date=2013-04-17 |access-date=2013-04-25 |archive-date=2013-04-26 |archive-url=https://web.archive.org/web/20130426010754/http://lwn.net/Articles/547145/ |url-status=live}}</ref><ref name=\"The Rustonomicon\">{{Cite web|url=https://doc.rust-lang.org/nomicon/races.html|title=Races \u2013 The Rustonomicon|website=doc.rust-lang.org|access-date=2017-07-03|archive-date=2017-07-10|archive-url=https://web.archive.org/web/20170710194643/https://doc.rust-lang.org/nomicon/races.html|url-status=live}}</ref> Data values can be initialized only through a fixed set of forms, all of which require their inputs to be already initialized.<ref name=\"lang-faq\">{{cite web  |title=The Rust Language FAQ |website=static.rust-lang.org |url=http://static.rust-lang.org/doc/master/complement-lang-faq.html |url-status=dead |archive-url=https://web.archive.org/web/20150420104147/http://static.rust-lang.org/doc/master/complement-lang-faq.html |archive-date=2015-04-20 |year=2015 |access-date=2017-04-24}}</ref>\n\nUnsafe code can subvert some of these restrictions, using the <code>unsafe</code> keyword.{{sfn|Klabnik|Nichols|2019|pp=418\u2013427}} Unsafe code may also be used for low-level functionality, such as [[Volatile (computer programming)|volatile memory access]], architecture-specific intrinsics, [[type punning]], and inline assembly.{{sfn|McNamara|2021|p=139, 376\u2013379, 395}}\n\n=== Memory management ===\nRust does not use [[garbage collection (computer science)|garbage collection]]. Memory and other resources are instead managed through the \"resource acquisition is initialization\" convention,<ref>{{Cite web|title=RAII \u2013 Rust By Example|url=https://doc.rust-lang.org/rust-by-example/scope/raii.html|access-date=2020-11-22|website=doc.rust-lang.org|archive-date=2019-04-21|archive-url=https://web.archive.org/web/20190421131142/https://doc.rust-lang.org/rust-by-example/scope/raii.html|url-status=live}}</ref> with optional [[reference counting]]. Rust provides deterministic management of resources, with very low [[Overhead (computing)|overhead]].<ref>{{Cite web|url=https://blog.rust-lang.org/2015/05/11/traits.html|title=Abstraction without overhead: traits in Rust|website=Rust Blog|access-date=October 19, 2021|archive-date=September 23, 2021|archive-url=https://web.archive.org/web/20210923101530/https://blog.rust-lang.org/2015/05/11/traits.html|url-status=live}}</ref> Values are [[Stack-based memory allocation|allocated on the stack]] by default, and all [[dynamic allocation]]s must be explicit.<ref>{{Cite web |title=Box, stack and heap |url=https://doc.rust-lang.org/stable/rust-by-example/std/box.html |access-date=2022-06-13 |website=Rust By Example}}</ref>\n\nThe built-in reference types using the <code>&</code> symbol do not involve run-time reference counting. The safety and validity of the underlying pointers is verified at compile time, preventing [[dangling pointers]] and other forms of [[undefined behavior]].{{sfn|Klabnik|Nichols|2019|pp=70\u201375}} Rust's type system separates shared, [[Immutable object|immutable]] references of the form <code>&T</code> from unique, mutable references of the form <code>&mut T</code>. A mutable reference can be coerced to an immutable reference, but not vice versa.{{sfn|Klabnik|Nichols|2019|p=323}}\n\n=== Polymorphism ===\n==== Generics ====\nRust's more advanced features include the use of [[generic function]]s. A generic function is given [[Generic programming|generic]] [[Parameter (computer programming)|parameters]], which allow the same function to be applied to different variable types. This capability reduces [[duplicate code]]{{sfn|Klabnik|Nichols|2019|pp=171\u2013172}} and is known as [[parametric polymorphism]].\n\nThe following program calculates the sum of two things, for which addition is implemented using a generic function:\n\n<syntaxhighlight lang=\"rust\">\nuse std::ops::Add;\n\n// sum is a generic function with one type parameter, T\nfn sum<T>(num1: T, num2: T) -> T\nwhere  \n    T: Add<Output = T>,  // T must implement the Add trait where addition returns another T\n{\n    num1 + num2  // num1 + num2 is syntactic sugar for num1.add(num2) provided by the Add trait\n}\n\nfn main() {\n    let result1 = sum(10, 20);\n    println!(\"Sum is: {}\", result1); // Sum is: 30\n\n    let result2 = sum(10.23, 20.45);\n    println!(\"Sum is: {}\", result2); // Sum is: 30.68\n}\n</syntaxhighlight>\n\nAt compile time, polymorphic functions like <code>sum</code> are [[Instance (computer science)|instantiated]] with the specific types the code requires; in this case, sum of integers and sum of floats.\n\nGenerics can be used in functions to allow implementing a behavior for different types without repeating the same code. Generic functions can be written in relation to other generics, without knowing the actual type.{{sfn|Klabnik|Nichols|2019|pp=171\u2013172,205}}\n\n==== Traits ====\nRust's type system supports a mechanism called traits, inspired by [[type class]]es in the [[Haskell]] language,<ref name=\"influences\"/> to define shared behavior between different types. For example, the <code>Add</code> trait can be implemented for floats and integers, which can be added; and the <code>Display</code> or <code>Debug</code> traits can be implemented for any type that can be converted to a string. Traits can be used to provide a set of common behavior for different types without knowing the actual type. This facility is known as [[ad hoc polymorphism]].\n\nGeneric functions can constrain the generic type to implement a particular trait or traits; for example, an <code>add_one</code> function might require the type to implement <code>Add</code>. This means that a generic function can be type-checked as soon as it is defined. The implementation of generics is similar to the typical implementation of C++ templates: a separate copy of the code is generated for each instantiation. This is called [[monomorphization]] and contrasts with the [[type erasure]] scheme typically used in Java and Haskell. Type erasure is also available via the keyword <code>dyn</code> (short for dynamic).{{sfn|Klabnik|Nichols|2019|pp=181,182}} Because monomorphization duplicates the code for each type used, it can result in more optimized code for specific-use cases, but compile time and size of the output binary are also increased.{{sfn|Gjengset|2021|p=25}}\n\nIn addition to defining methods for a user-defined type, the <code>impl</code> keyword can be used to implement a trait for a type.{{sfn|Klabnik|Nichols|2019|pp=93}} Traits can provide additional derived methods when implemented.{{sfn|Klabnik|Nichols|2019|pp=182\u2013184}} For example, the trait <code>Iterator</code> requires that the <code>next</code> method be defined for the type. Once the <code>next</code> method is defined, the trait can provide common functional helper methods over the iterator, such as <code>map</code> or <code>filter</code>.{{sfn|Klabnik|Nichols|2019|pp=281\u2013283}}\n\n==== Trait objects ====\nRust traits are implemented using [[static dispatch]], meaning that the type of all values is known at compile time; however, Rust also uses a feature known as ''trait objects'' to accomplish [[dynamic dispatch]] (also known as [[duck typing]]).<ref name=TraitObjectsBook>{{Cite web |title=Using Trait Objects That Allow for Values of Different Types \u2013 The Rust Programming Language |url=https://doc.rust-lang.org/book/ch17-02-trait-objects.html |access-date=2022-07-11 |website=doc.rust-lang.org}}</ref> Dynamically dispatched trait objects are declared using the syntax <code>dyn Tr</code> where <code>Tr</code> is a trait. Trait objects are dynamically sized, therefore they must be put behind a pointer, such as <code>Box</code>.{{sfn|Klabnik|Nichols|2019|pp=441\u2013442}} The following example creates a list of objects where each object can be printed out using the <code>Display</code> trait:\n\n<syntaxhighlight lang=\"Rust\">\nuse std::fmt::Display;\n\nlet v: Vec<Box<dyn Display>> = vec![\n    Box::new(3),\n    Box::new(5.0),\n    Box::new(\"hi\"),\n];\n\nfor x in v {\n    println!(\"{x}\");\n}\n</syntaxhighlight>\n\nIf an element in the list does not implement the <code>Display</code> trait, it will cause a compile-time error.{{sfn|Klabnik|Nichols|2019|pp=379\u2013380}}\n\n=== Iterators ===\n[[For loop]]s in Rust work in a functional style as operations over an [[iterator]] type. For example, in the loop\n\n<syntaxhighlight lang=\"rust\">\nfor x in 0..100 {\n   f(x);\n}\n</syntaxhighlight>\n\n<code>0..100</code> is a value of type <code>Range</code> which implements the <code>Iterator</code> trait; the code applies the function <code>f</code> to each element returned by the iterator. Iterators can be combined with functions over iterators like <code>map</code>, <code>filter</code>, and <code>sum</code>. For example, the following adds up all numbers between 1 and 100 that are multiples of 3:\n\n<syntaxhighlight lang=\"rust\">\n(1..=100).filter(|&x| x % 3 == 0).sum()\n</syntaxhighlight>\n\n=== Macros ===\nIt is possible to extend the Rust language using macros.\n\n==== Declarative macros ====\nA declarative macro (also called a \"macro by example\") is a macro that uses pattern matching to determine its expansion.<ref name=\"Rust Ref. \u2013 Macros By Example\">{{cite web |title=Macros By Example |url=https://doc.rust-lang.org/reference/macros-by-example.html |archive-url= |archive-date= |url-status= |website=The Rust Reference |access-date=21 April 2023}}</ref>{{sfn|Klabnik|Nichols|2019|pp=446\u2013448}}\n\n==== Procedural macros ====\nProcedural macros are Rust functions that run and modify the compiler's input [[Token (parser)|token]] stream, before any other components are compiled. They are generally more flexible than declarative macros, but are more difficult to maintain due to their complexity.<ref name=\"rust-procedural-macros\">{{cite web |url=https://doc.rust-lang.org/reference/procedural-macros.html |title=Procedural Macros |website=The Rust Programming Language Reference |access-date=23 Mar 2021 |archive-date=7 November 2020 |archive-url=https://web.archive.org/web/20201107233444/https://doc.rust-lang.org/reference/procedural-macros.html |url-status=live}}</ref>{{sfn|Klabnik|Nichols|2019|pp=449\u2013455}}\n\nProcedural macros come in three flavors:\n* Function-like macros <code>custom!(...)</code>\n* Derive macros <code>#[derive(CustomDerive)]</code>\n* Attribute macros <code>#[custom_attribute]</code>\n\nThe <code>println!</code> macro is an example of a function-like macro. The<code>serde_derive</code> macro<ref>{{cite web|url=https://serde.rs/derive.html|title=Serde Derive|website=Serde Derive documentation|access-date=23 Mar 2021|archive-date=17 April 2021|archive-url=https://web.archive.org/web/20210417114849/https://serde.rs/derive.html|url-status=live}}</ref> provides a commonly used library for generating code\nfor reading and writing data in many formats, such as [[JSON]]. Attribute macros are commonly used for language bindings, such as the <code>extendr</code> library for Rust bindings to [[R (programming language)|R]].<ref>{{cite web|url=https://extendr.github.io/extendr/extendr_api/index.html|title=extendr_api \u2013 Rust|website=Extendr Api Documentation|access-date=23 Mar 2021|archive-date=May 25, 2021|archive-url=https://web.archive.org/web/20210525082129/https://extendr.github.io/extendr/extendr_api/index.html|url-status=live}}</ref>\n\nThe following code shows the use of the <code>Serialize</code>, <code>Deserialize</code>, and <code>Debug</code>-derived procedural macros\nto implement JSON reading and writing, as well as the ability to format a structure for debugging.\n[[File:Rust serde UML diagram.svg|thumb|A [[UML diagram]] depicting a Rust struct named Point.]]\n<syntaxhighlight lang=\"rust\">\nuse serde_json::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let point = Point { x: 1, y: 2 };\n\n    let serialized = serde_json::to_string(&point).unwrap();\n    println!(\"serialized = {}\", serialized);\n\n    let deserialized: Point = serde_json::from_str(&serialized).unwrap();\n    println!(\"deserialized = {:?}\", deserialized);\n}\n</syntaxhighlight>\n\n==== Variadic macros ====\n{{excerpt|Variadic function|In Rust|subsections=yes}}\n\n=== Interface with C and C++ ===\nRust has a [[foreign function interface]] (FFI) that can be used both to call code written in languages such as [[C (programming language)|C]] from Rust and to call Rust code from those languages. As of 2023, an external library called CXX exists for calling to or from C++.<ref>{{Cite web|title=Safe Interoperability between Rust and C++ with CXX|url=https://www.infoq.com/news/2020/12/cpp-rust-interop-cxx/|date=2020-12-06|access-date=2021-01-03|website=InfoQ|language=en|archive-date=January 22, 2021|archive-url=https://web.archive.org/web/20210122142035/https://www.infoq.com/news/2020/12/cpp-rust-interop-cxx/|url-status=live}}</ref> Rust and C differ in how they lay out structs in memory, so Rust structs may be given a <code>#[repr(C)]</code> attribute, forcing the same layout as the equivalent C struct.<ref>{{cite web |title=Type layout \u2013 The Rust Reference |url=https://doc.rust-lang.org/reference/type-layout.html#the-c-representation |website=doc.rust-lang.org |access-date=15 July 2022}}</ref>\n\n"}, {"title": " Hello World program ", "content": "Below is a [[\"Hello, World!\" program]] in Rust. The {{Rust|fn}} keyword denotes a [[Function (computer programming)|function]], and the <code>println!</code> [[Macro (computer science)|macro]] prints the message to [[standard output]].{{sfn|Klabnik|Nichols|2019|pp=5\u20136}} [[Statement (computer science)|Statements]] in Rust are [[Semicolon#Programming|separated]] by semicolons.\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    println!(\"Hello, World!\");\n}\n</syntaxhighlight>\n\n"}, {"title": " Keywords and control flow ", "content": "In Rust, blocks of code are delimited by [[Bracket#Curly brackets|curly brackets]], and [[control flow]] is implemented by keywords including <code>[[Conditional (computer programming)|if]]</code>, <code>else</code>, <code>[[While loop|while]]</code>, and <code>[[For loop|for]]</code>.{{sfn|Klabnik|Nichols|2019|pp=49\u201357}} [[Pattern matching]] can be done using the {{Rust|match}} keyword.{{sfn|Klabnik|Nichols|2019|pp=104\u2013109}} In the examples below, explanations are given in [[comment (computer programming)|comment]]s, which start with {{code|//}}.{{sfn|Klabnik|Nichols|2019|p=49}}\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    // Defining a mutable variable with 'let mut'\n    // Using the macro vec! to create a vector\n    let mut values = vec![1, 2, 3, 4];\n\n    for value in &values {\n        println!(\"value = {}\", value);\n    }\n\n    if values.len() > 5 {\n        println!(\"List is longer than five items\");\n    }\n\n    // Pattern matching\n    match values.len() {\n        0 => println!(\"Empty\"),\n        1 => println!(\"One value\"),\n        // pattern matching can use ranges of integers\n        2..=10 => println!(\"Between two and ten values\"),\n        11 => println!(\"Eleven values\"),\n        // A `_` pattern is called a \"wildcard\", it matches any value\n        _ => println!(\"Many values\"),\n    };\n\n    // while loop with predicate and pattern matching using let\n    while let Some(value) = values.pop() {\n        println!(\"value = {value}\"); // using curly brackets to format a local variable\n    }\n}\n</syntaxhighlight>\n\n"}, {"title": " Expression blocks ", "content": "Rust is [[Expression-oriented programming language|expression-oriented]], with nearly every part of a function body being an [[Expression (computer science)|expression]], including control-flow operators.{{sfn|Klabnik|Nichols|2019|pp=50\u201353}} The ordinary <code>if</code> expression is used instead of [[?:|C's ternary conditional]]. With returns being implicit, a function does not need to end with a <code>return</code> expression; if the semicolon is omitted, the value of the last expression in the function is used as the [[return value]],<ref>{{Cite web |last=Tyson |first=Matthew |date=2022-03-03 |title=Rust programming for Java developers |url=https://www.infoworld.com/article/3651362/rust-programming-for-java-developers.html |access-date=2022-07-14 |website=InfoWorld |language=en}}</ref> as seen in the following [[Recursion (computer science)|recursive]] implementation of the [[factorial]] function:\n\n<syntaxhighlight lang=\"rust\">\nfn factorial(i: u64) -> u64 {\n    if i == 0 {\n        1\n    } else {\n        i * factorial(i - 1)\n    }\n}\n</syntaxhighlight>\n\nThe following [[Iteration (computer science)|iterative]] implementation uses the <code>..=</code> operator to create an inclusive range:\n\n<syntaxhighlight lang=\"rust\">\nfn factorial(i: u64) -> u64 {\n    (2..=i).product()\n}\n</syntaxhighlight>\n\n==== Closures ====\n{{excerpt|Anonymous function|Rust|subsections=yes}}\n\n"}, {"title": " Closures ", "content": "{{excerpt|Anonymous function|Rust|subsections=yes}}\n\n"}, {"title": " Types ", "content": "Rust is [[strongly typed]] and [[statically typed]]. The types of all variables must be known at compilation time; assigning a value of a particular type to a differently typed variable causes a [[compilation error]]. Variables are declared with the [[Reserved word|keyword]] <code>let</code>, and type inference is used to determine their type.{{sfn|Klabnik|Nichols|2019|pp=24}} Variables assigned multiple times must be marked with the keyword <code>mut</code> (short for mutable).{{sfn|Klabnik|Nichols|2019|pp=32\u201333}}\n\nThe default integer type is {{rust|i32}}, and the default [[floating point]] type is {{rust|f64}}. If the type of a [[Literal (computer programming)|literal]] number is not explicitly provided, either it is [[type inference|inferred]] from the context or the default type is used.{{sfn|Klabnik|Nichols|2019|pp=36\u201338}}\n\n==== Primitive types ====\n{| class=\"wikitable\"\n|+Summary of Rust's [[Primitive data type|Primitive Types]]\n!Type\n!Description\n!Examples\n|-\n|{{rust|bool}}\n|[[Boolean value]]\n|{{plainlist|\n* {{rust|true}}\n* {{rust|false}}\n  }}\n|-\n|{{rust|u8}}\n|Unsigned [[8-bit integer]] (a [[byte]])\n|{{plainlist|\n* {{rust|255u8}}<ref group=\"note\" name=\"ExplicitSuffix\">This literal uses an explicit suffix, which is not needed when type can be inferred from the context</ref>\n* {{Rust|b'W'}} ([[ASCII]] encoded byte)\n  }}\n|-\n|{{plainlist|\n* {{rust|i8}}\n* {{rust|i16}}\n* {{rust|i32}}\n* {{rust|i64}}\n* {{rust|i128}}\n  }}\n|[[Signed integer]]s, up to [[128-bit computing|128 bits]]\n|{{plainlist|\n* {{rust|7}}<ref group=\"note\" name=\"Default\">Interpreted as {{rust|i32}} by default, or inferred from the context</ref>\n* {{rust|7i128}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n  }}\n|-\n|{{plainlist|\n* {{rust|u16}}\n* {{rust|u32}}\n* {{rust|u64}}\n* {{rust|u128}}\n  }}\n|[[Unsigned integer]]s, up to [[128-bit computing|128 bits]]\n|{{plainlist|\n* {{rust|14}}<ref group=\"note\" name=\"Inferred\">Type inferred from the context</ref>\n* {{rust|14u128}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n  }}\n|-\n|{{plainlist|\n* {{rust|usize}}\n* {{rust|isize}}\n  }}\n|[[Pointer (computer programming)|Pointer]]-sized integers (size depends on [[computing platform|platform]])\n|{{plainlist|\n* {{rust|14usize}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n* {{rust|-2isize}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n  }}\n|-\n|{{plainlist|\n* {{rust|f32}}\n* {{rust|f64}}\n  }}\n|[[Floating-point arithmetic|Floating-point number]]s\n|{{plainlist|\n* {{rust|-3f32}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n  }}\n|-\n|{{Rust|char}}\n|{{Plainlist|\n* [[UTF-32]] scalar value (occupies 4 bytes)\n* A [[Unicode codepoint]] that is not a [[Universal Character Set characters#Surrogates|surrogate]]{{sfn|Klabnik|Nichols|2019|pp=39\u201340}}\n  }}\n|{{plainlist|\n* {{Rust|'a'}}\n* {{Rust|'\u8bed'}}\n* {{Rust|'\ud83e\udd80'}} ([[Emoji]])\n* {{Rust|'\\u{200D}'}} (Unicode escape, [[zero-width joiner]])\n  }}\n|-\n|{{Rust|str}}\n|[[UTF-8]]-encoded string slice, the primitive string type. It is usually seen in its borrowed form, {{Rust|&str}}. It is also the type of string literals, {{Rust|&'static str}}<ref>{{Cite web |title=str \u2013 Rust |url=https://doc.rust-lang.org/beta/std/primitive.str.html |access-date=2023-06-23 |website=doc.rust-lang.org}}</ref>\n|{{plainlist|\n* {{Rust|\"Hello\"}}\n* {{Rust|\"3\"}}\n* {{Rust|\"\ud83e\udd80\ud83e\udd80\ud83e\udd80\"}}\n  }}\n|-\n|{{Rust|[T; N]}}\n|[[Array (data structure)|Array]] \u2013 collection of N objects of the same type T, stored in contiguous memory\n|{{plainlist|\n* {{Rust|[2, 4, 6]}}\n* {{Rust|[0; 100]}}\n* {{Rust|b\"Hello\"}}\n  }}\n|-\n|{{Rust|[T]}}\n|Slice \u2013 a dynamically-sized view into a contiguous sequence<ref>{{Cite web |title=slice \u2013 Rust |url=https://doc.rust-lang.org/beta/std/primitive.slice.html |access-date=2023-06-23 |website=doc.rust-lang.org}}</ref>\n|{{plainlist|\n* {{Rust|[1, 2, 3, 4, 5][..i]}}\n* {{Rust|\"Hello, world!\".as_bytes()}}\n* {{Rust|let v {{=}} vec![1, 2, 3]; v.as_slice()}}\n  }}\n|-\n|{{plainlist|{{Rust|(T, U, ..)}}}}\n|[[Tuple]] \u2013 a finite heterogeneous sequence\n|{{plainlist|\n* {{Rust|()}} (An empty tuple, the [[unit type]] in Rust)\n* {{Rust|(5,)}} ({{Rust|(5)}} is parsed as an integer)<ref>{{Cite web |title=Tuples |url=https://doc.rust-lang.org/rust-by-example/primitives/tuples.html |access-date=2023-10-01 |website=Rust By Example}}</ref>\n* {{Rust|(\"Age\", 10)}}\n* {{Rust|(1, true, \"Name\")}}\n  }}\n|-\n| {{Rust|!}}\n| [[Bottom type|Never type]] (unreachable value)\n| {{Rust|let x {{=}} { return 123 };}}\n|}\n\n==== Standard library ====\n{| class=\"wikitable\"\n|+Summary of Rust's types in the [[standard library]]\n!Type\n!Description\n!Examples\n|-\n|{{Rust|String}}\n|UTF-8-encoded strings (dynamic)\n|{{plainlist|\n* {{Rust|String::new()}}\n* {{Rust|String::from(\"Hello\")}}\n* {{Rust|\"\ud83e\udd80\ud83e\udd80\ud83e\udd80\".to_string()}}\n  }}\n|-\n|{{plainlist|\n* {{Rust|OsStr}}\n* {{Rust|OsString}}\n  }}\n|Platform-native strings<ref group=\"note\" name=\"OsString\">On Unix systems, this is often UTF-8 strings without an internal 0 byte. On Windows, this is [[UTF-16]] strings without an internal 0 byte. Unlike these, {{Rust|str}} and {{Rust|String}} are always valid UTF-8 and can contain internal zeros.</ref> (borrowed<ref>{{Cite web |title=OsStr in std::ffi \u2013 Rust |url=https://doc.rust-lang.org/beta/std/ffi/struct.OsStr.html |access-date=2023-10-02 |website=doc.rust-lang.org}}</ref> and dynamic<ref>{{Cite web |title=OsString in std::ffi \u2013 Rust |url=https://doc.rust-lang.org/beta/std/ffi/struct.OsString.html |access-date=2023-10-02 |website=doc.rust-lang.org}}</ref>)\n|{{plainlist|\n* {{Rust|OsStr::new(\"Hello\")}}\n* {{Rust|OsString::from(\"world\")}}\n  }}\n|-\n|{{plainlist|\n* {{Rust|Path}}\n* {{Rust|PathBuf}}\n  }}\n|[[Path (computing)|Paths]] (borrowed<ref>{{Cite web |title=Path in std::path \u2013 Rust |url=https://doc.rust-lang.org/beta/std/path/struct.Path.html |access-date=2023-10-02 |website=doc.rust-lang.org}}</ref> and dynamic<ref>{{Cite web |title=PathBuf in std::path \u2013 Rust |url=https://doc.rust-lang.org/beta/std/path/struct.PathBuf.html |access-date=2023-10-02 |website=doc.rust-lang.org}}</ref>)\n|{{plainlist|\n* {{Rust|Path::new(\"./path/to\")}}\n* {{Rust|PathBuf::from(r\"C:.\\path\\to\")}}\n  }}\n|-\n|{{plainlist|\n* {{Rust|CStr}}\n* {{Rust|CString}}\n  }}\n|[[C (programming language)|C]]-compatible, [[null-terminated string]]s (borrowed<ref name=\"std::boxed \u2013 Rust\">{{Cite web |title=std::boxed \u2013 Rust |url=https://doc.rust-lang.org/std/boxed/index.html |access-date=2023-06-23 |website=doc.rust-lang.org}}</ref> and dynamic<ref name=\"std::boxed \u2013 Rust\"/>)\n|{{plainlist|\n* {{Rust|CStr::from_bytes_with_nul(b\"Hello\\0\").unwrap()}}\n* {{Rust|CString::new(\"world\").unwrap()}}\n  }}\n|-\n|{{Rust|Vec<T>}}\n|[[Dynamic array]]s\n|{{plainlist|\n* {{Rust|Vec::new()}}\n* {{Rust|vec![1, 2, 3, 4, 5]}}\n  }}\n|-\n|{{Rust|Option<T>}}\n|[[Option type]]\n|{{plainlist|\n* {{Rust|None}}\n* {{Rust|Some(3)}}\n* {{Rust|Some(\"hello\")}}\n  }}\n|-\n|{{Rust|Result<T, E>}}\n|[[Exception handling|Error handling]] using a [[result type]]\n|{{plainlist|\n* {{Rust|Ok(3)}}\n* {{Rust|Err(\"something went wrong\")}}\n  }}\n|-\n|{{Rust|Box<T>}}\n|A pointer to a [[Heap (programming)|heap]]-allocated value<ref>{{Cite web |title=std::boxed \u2013 Rust |url=https://doc.rust-lang.org/std/boxed/index.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>. Similar to C++'s [https://en.cppreference.com/w/cpp/memory/unique_ptr std::unique_ptr].\n| <syntaxhighlight lang=\"rust\">\nlet boxed: Box<u8> = Box::new(5);\nlet val: u8 = *boxed;\n</syntaxhighlight>\n|-\n|{{Rust|Rc<T>}}\n|[[Reference counting]] pointer<ref>{{Cite web |title=Rc in std::rc \u2013 Rust |url=https://doc.rust-lang.org/beta/std/rc/struct.Rc.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet five = Rc::new(5);\nlet also_five = five.clone();\n</syntaxhighlight>\n|-\n|{{Rust|Arc<T>}}\n|[[Linearizability|Atomic]], [[Thread safety|thread-safe]] reference counting pointer<ref>{{Cite web |title=Arc in std::sync \u2013 Rust |url=https://doc.rust-lang.org/beta/std/sync/struct.Arc.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet foo = Arc::new(vec![1.0, 2.0]);\nlet a = foo.clone(); // a can be sent to another thread\n</syntaxhighlight>\n|-\n|{{Rust|Cell<T>}}\n|A mutable memory location<ref>{{Cite web |title=Cell in std::cell \u2013 Rust |url=https://doc.rust-lang.org/beta/std/cell/struct.Cell.html# |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet c = Cell::new(5);\nc.set(10);\n</syntaxhighlight>\n|-\n|<code>Mutex<T></code>\n|A [[Lock (computer science)|mutex lock]] for shared data contained within.<ref>{{Cite web |title=Mutex in std::sync \u2013 Rust |url=https://doc.rust-lang.org/beta/std/sync/struct.Mutex.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet mutex = Mutex::new(0_u32);\nlet _guard = mutex.lock();\n</syntaxhighlight>\n|-\n|{{Rust|RwLock<T>}}\n|[[Readers\u2013writer lock]]<ref>{{Cite web |title=RwLock in std::sync \u2013 Rust |url=https://doc.rust-lang.org/beta/std/sync/struct.RwLock.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet lock = RwLock::new(5);\nlet r1 = lock.read().unwrap();\n</syntaxhighlight>\n|-\n|{{Rust|Condvar}}\n|A [[Monitor (synchronization)|conditional monitor]] for shared data<ref>{{Cite web |title=Condvar in std::sync \u2013 Rust |url=https://doc.rust-lang.org/beta/std/sync/struct.Condvar.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\n let (lock, cvar) = (Mutex::new(true), Condvar::new());\n// As long as the value inside the `Mutex<bool>` is `true`, we wait.\nlet _guard = cvar.wait_while(lock.lock().unwrap(), |pending| { *pending }).unwrap();\n\n</syntaxhighlight>\n|-\n|{{Rust|Duration}}\n|Type that represents a span of time<ref>{{Cite web |title=Duration in std::time \u2013 Rust |url=https://doc.rust-lang.org/beta/std/time/struct.Duration.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nDuration::from_millis(1) // 1ms\n</syntaxhighlight>\n|-\n|{{Rust|1=HashMap<K, V>}}\n|[[Hash table]]<ref>{{Cite web |title=HashMap in std::collections \u2013 Rust |url=https://doc.rust-lang.org/beta/std/collections/struct.HashMap.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet mut player_stats = HashMap::new();\nplayer_stats.insert(\"damage\", 1);\nplayer_stats.entry(\"health\").or_insert(100);\n</syntaxhighlight>\n|-\n|{{Rust|1=BTreeMap<K, V>}}\n|[[B-tree]]<ref>{{Cite web |title=BTreeMap in std::collections \u2013 Rust |url=https://doc.rust-lang.org/beta/std/collections/struct.BTreeMap.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet mut solar_distance = BTreeMap::from([\n    (\"Mercury\", 0.4),\n    (\"Venus\", 0.7),\n]);\nsolar_distance.entry(\"Earth\").or_insert(1.0);\n\n</syntaxhighlight>\n|}\n\n[[Option type|<code>Option</code>]] values are handled using [[syntactic sugar]], such as the <code>if let</code> construction, to access the inner value (in this case, a string):{{sfn|McNamara|2021}}\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    let name1: Option<&str> = None;\n    // In this case, nothing will be printed out\n    if let Some(name) = name1 {\n        println!(\"{name}\");\n    }\n\n    let name2: Option<&str> = Some(\"Matthew\");\n    // In this case, the word \"Matthew\" will be printed out\n    if let Some(name) = name2 {\n        println!(\"{name}\");\n    }\n}\n</syntaxhighlight>\n\n==== Pointers ====\n{| class=\"wikitable\"\n|+Summary of Rust's [[Pointer (computer programming)|pointer]] and [[Reference (computer science)|reference]] primitive types\n!Type\n!Description\n!Examples\n|-\n|{{plainlist|\n* {{Rust|&T}}\n* {{Rust|&mut T}}\n  }}\n|[[Reference (computer science)|References]] (immutable and mutable)\n|{{plainlist|\n* {{Rust|let x_ref {{=}} {{not a typo|&x;}}}}\n* {{Rust|let x_ref {{=}} &mut x;}}\n  }}\n|-\n|{{plainlist|\n* {{Rust|Option<&T>}}\n* {{Rust|Option<&mut T>}}\n  }}\n|{{plainlist|\n* Option wrapped reference\n* Possibly null reference\n  }}\n|{{plainlist|\n* {{Rust|None}}\n* {{Rust|let x_ref {{=}} Some(&x);}}\n* {{Rust|let x_ref {{=}} Some(&mut x);}}\n  }}\n|-\n|{{Plain list|* {{Rust|Box<T>}}\n* {{Rust|Option<Box<T>>}}}}\n|A pointer to heap-allocated value\n(or possibly null pointer if wrapped in option)<ref name=\"std::boxed \u2013 Rust\"/>\n|{{Plain list|* {{Rust|let boxed {{=}} Box::new(0);}}\n* {{Rust|let boxed {{=}} Some(Box::new(\"Hello World\"));}}}}\n|-\n|{{Plainlist|\n* {{Rust|*const T}}\n* {{Rust|*mut T}}\n  }}\n|{{Plainlist|\n* Raw pointers (immutable and mutable)\n* Possibly [[Null pointer|null]]; {{Rust|unsafe}} to [[dereference]]\n  }}\n|{{Plainlist|\n* {{Rust|let x_ptr {{=}} &x as *const T;}}\n* {{Rust|let x_ptr {{=}} &mut x as *mut T;}}\n  }}\n|}\n\nRust does not use [[null pointer]]s to indicate a lack of data, as doing so can lead to [[Null pointer#Null dereferencing|null dereferencing]]. Accordingly, the basic <code>&</code> and <code>&mut</code> references are guaranteed to not be null. Rust instead uses <code>Option</code> for this purpose: <code>Some(T)</code> indicates that a value is present, and <code>None</code> is analogous to the null pointer.{{sfn|Klabnik|Nichols|2019|pp=101\u2013104}} <code>Option</code> implements a \"null pointer optimization\", avoiding any spatial overhead for types that cannot have a null value (references or the <code>NonZero</code> types, for example).<ref>{{Cite web |title=std::option - Rust |url=https://doc.rust-lang.org/std/option/index.html#representation |access-date=2023-11-12 |website=doc.rust-lang.org}}</ref>\n\nUnlike references, the raw pointer types <code>*const</code> and <code>*mut</code> may be null; however, it is impossible to dereference them unless the code is explicitly declared unsafe through the use of an <code>unsafe</code> block. Unlike dereferencing, the creation of raw pointers is allowed inside of safe Rust code.{{sfn|Klabnik|Nichols|2019|pp=418\u2013427}}\n\n==== User-defined types ====\nUser-defined types are created with the <code>struct</code> or <code>enum</code> keywords. The <code>struct</code> keyword is used to denote a [[Record (computer science)|record type]] that groups multiple related values.{{sfn|Klabnik|Nichols|2019|p=83}} <code>enum</code>s can take on different variants at runtime, with its capabilities similar to [[algebraic data types]] found in functional programming languages.{{sfn|Klabnik|Nichols|2019|p=97}} Both structs and enums can contain [[Field (computer science)|fields]] with different types.{{sfn|Klabnik|Nichols|2019|pp=98\u2013101}} Alternative names for the same type can be defined with the <code>type</code> keyword.{{sfn|Klabnik|Nichols|2019|pp=438\u2013440}}\n\nThe <code>impl</code> keyword can define methods for a user-defined type (data and functions are defined separately). Implementations fulfill a role similar to that of classes within other languages.{{sfn|Klabnik|Nichols|2019|pp=93}}\n\n==== Type conversion ====\n{{excerpt|Type conversion|Rust}}\n\n"}, {"title": " Primitive types ", "content": "{| class=\"wikitable\"\n|+Summary of Rust's [[Primitive data type|Primitive Types]]\n!Type\n!Description\n!Examples\n|-\n|{{rust|bool}}\n|[[Boolean value]]\n|{{plainlist|\n* {{rust|true}}\n* {{rust|false}}\n  }}\n|-\n|{{rust|u8}}\n|Unsigned [[8-bit integer]] (a [[byte]])\n|{{plainlist|\n* {{rust|255u8}}<ref group=\"note\" name=\"ExplicitSuffix\">This literal uses an explicit suffix, which is not needed when type can be inferred from the context</ref>\n* {{Rust|b'W'}} ([[ASCII]] encoded byte)\n  }}\n|-\n|{{plainlist|\n* {{rust|i8}}\n* {{rust|i16}}\n* {{rust|i32}}\n* {{rust|i64}}\n* {{rust|i128}}\n  }}\n|[[Signed integer]]s, up to [[128-bit computing|128 bits]]\n|{{plainlist|\n* {{rust|7}}<ref group=\"note\" name=\"Default\">Interpreted as {{rust|i32}} by default, or inferred from the context</ref>\n* {{rust|7i128}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n  }}\n|-\n|{{plainlist|\n* {{rust|u16}}\n* {{rust|u32}}\n* {{rust|u64}}\n* {{rust|u128}}\n  }}\n|[[Unsigned integer]]s, up to [[128-bit computing|128 bits]]\n|{{plainlist|\n* {{rust|14}}<ref group=\"note\" name=\"Inferred\">Type inferred from the context</ref>\n* {{rust|14u128}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n  }}\n|-\n|{{plainlist|\n* {{rust|usize}}\n* {{rust|isize}}\n  }}\n|[[Pointer (computer programming)|Pointer]]-sized integers (size depends on [[computing platform|platform]])\n|{{plainlist|\n* {{rust|14usize}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n* {{rust|-2isize}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n  }}\n|-\n|{{plainlist|\n* {{rust|f32}}\n* {{rust|f64}}\n  }}\n|[[Floating-point arithmetic|Floating-point number]]s\n|{{plainlist|\n* {{rust|-3f32}}<ref group=\"note\" name=\"ExplicitSuffix\" />\n  }}\n|-\n|{{Rust|char}}\n|{{Plainlist|\n* [[UTF-32]] scalar value (occupies 4 bytes)\n* A [[Unicode codepoint]] that is not a [[Universal Character Set characters#Surrogates|surrogate]]{{sfn|Klabnik|Nichols|2019|pp=39\u201340}}\n  }}\n|{{plainlist|\n* {{Rust|'a'}}\n* {{Rust|'\u8bed'}}\n* {{Rust|'\ud83e\udd80'}} ([[Emoji]])\n* {{Rust|'\\u{200D}'}} (Unicode escape, [[zero-width joiner]])\n  }}\n|-\n|{{Rust|str}}\n|[[UTF-8]]-encoded string slice, the primitive string type. It is usually seen in its borrowed form, {{Rust|&str}}. It is also the type of string literals, {{Rust|&'static str}}<ref>{{Cite web |title=str \u2013 Rust |url=https://doc.rust-lang.org/beta/std/primitive.str.html |access-date=2023-06-23 |website=doc.rust-lang.org}}</ref>\n|{{plainlist|\n* {{Rust|\"Hello\"}}\n* {{Rust|\"3\"}}\n* {{Rust|\"\ud83e\udd80\ud83e\udd80\ud83e\udd80\"}}\n  }}\n|-\n|{{Rust|[T; N]}}\n|[[Array (data structure)|Array]] \u2013 collection of N objects of the same type T, stored in contiguous memory\n|{{plainlist|\n* {{Rust|[2, 4, 6]}}\n* {{Rust|[0; 100]}}\n* {{Rust|b\"Hello\"}}\n  }}\n|-\n|{{Rust|[T]}}\n|Slice \u2013 a dynamically-sized view into a contiguous sequence<ref>{{Cite web |title=slice \u2013 Rust |url=https://doc.rust-lang.org/beta/std/primitive.slice.html |access-date=2023-06-23 |website=doc.rust-lang.org}}</ref>\n|{{plainlist|\n* {{Rust|[1, 2, 3, 4, 5][..i]}}\n* {{Rust|\"Hello, world!\".as_bytes()}}\n* {{Rust|let v {{=}} vec![1, 2, 3]; v.as_slice()}}\n  }}\n|-\n|{{plainlist|{{Rust|(T, U, ..)}}}}\n|[[Tuple]] \u2013 a finite heterogeneous sequence\n|{{plainlist|\n* {{Rust|()}} (An empty tuple, the [[unit type]] in Rust)\n* {{Rust|(5,)}} ({{Rust|(5)}} is parsed as an integer)<ref>{{Cite web |title=Tuples |url=https://doc.rust-lang.org/rust-by-example/primitives/tuples.html |access-date=2023-10-01 |website=Rust By Example}}</ref>\n* {{Rust|(\"Age\", 10)}}\n* {{Rust|(1, true, \"Name\")}}\n  }}\n|-\n| {{Rust|!}}\n| [[Bottom type|Never type]] (unreachable value)\n| {{Rust|let x {{=}} { return 123 };}}\n|}\n\n"}, {"title": " Standard library ", "content": "{| class=\"wikitable\"\n|+Summary of Rust's types in the [[standard library]]\n!Type\n!Description\n!Examples\n|-\n|{{Rust|String}}\n|UTF-8-encoded strings (dynamic)\n|{{plainlist|\n* {{Rust|String::new()}}\n* {{Rust|String::from(\"Hello\")}}\n* {{Rust|\"\ud83e\udd80\ud83e\udd80\ud83e\udd80\".to_string()}}\n  }}\n|-\n|{{plainlist|\n* {{Rust|OsStr}}\n* {{Rust|OsString}}\n  }}\n|Platform-native strings<ref group=\"note\" name=\"OsString\">On Unix systems, this is often UTF-8 strings without an internal 0 byte. On Windows, this is [[UTF-16]] strings without an internal 0 byte. Unlike these, {{Rust|str}} and {{Rust|String}} are always valid UTF-8 and can contain internal zeros.</ref> (borrowed<ref>{{Cite web |title=OsStr in std::ffi \u2013 Rust |url=https://doc.rust-lang.org/beta/std/ffi/struct.OsStr.html |access-date=2023-10-02 |website=doc.rust-lang.org}}</ref> and dynamic<ref>{{Cite web |title=OsString in std::ffi \u2013 Rust |url=https://doc.rust-lang.org/beta/std/ffi/struct.OsString.html |access-date=2023-10-02 |website=doc.rust-lang.org}}</ref>)\n|{{plainlist|\n* {{Rust|OsStr::new(\"Hello\")}}\n* {{Rust|OsString::from(\"world\")}}\n  }}\n|-\n|{{plainlist|\n* {{Rust|Path}}\n* {{Rust|PathBuf}}\n  }}\n|[[Path (computing)|Paths]] (borrowed<ref>{{Cite web |title=Path in std::path \u2013 Rust |url=https://doc.rust-lang.org/beta/std/path/struct.Path.html |access-date=2023-10-02 |website=doc.rust-lang.org}}</ref> and dynamic<ref>{{Cite web |title=PathBuf in std::path \u2013 Rust |url=https://doc.rust-lang.org/beta/std/path/struct.PathBuf.html |access-date=2023-10-02 |website=doc.rust-lang.org}}</ref>)\n|{{plainlist|\n* {{Rust|Path::new(\"./path/to\")}}\n* {{Rust|PathBuf::from(r\"C:.\\path\\to\")}}\n  }}\n|-\n|{{plainlist|\n* {{Rust|CStr}}\n* {{Rust|CString}}\n  }}\n|[[C (programming language)|C]]-compatible, [[null-terminated string]]s (borrowed<ref name=\"std::boxed \u2013 Rust\">{{Cite web |title=std::boxed \u2013 Rust |url=https://doc.rust-lang.org/std/boxed/index.html |access-date=2023-06-23 |website=doc.rust-lang.org}}</ref> and dynamic<ref name=\"std::boxed \u2013 Rust\"/>)\n|{{plainlist|\n* {{Rust|CStr::from_bytes_with_nul(b\"Hello\\0\").unwrap()}}\n* {{Rust|CString::new(\"world\").unwrap()}}\n  }}\n|-\n|{{Rust|Vec<T>}}\n|[[Dynamic array]]s\n|{{plainlist|\n* {{Rust|Vec::new()}}\n* {{Rust|vec![1, 2, 3, 4, 5]}}\n  }}\n|-\n|{{Rust|Option<T>}}\n|[[Option type]]\n|{{plainlist|\n* {{Rust|None}}\n* {{Rust|Some(3)}}\n* {{Rust|Some(\"hello\")}}\n  }}\n|-\n|{{Rust|Result<T, E>}}\n|[[Exception handling|Error handling]] using a [[result type]]\n|{{plainlist|\n* {{Rust|Ok(3)}}\n* {{Rust|Err(\"something went wrong\")}}\n  }}\n|-\n|{{Rust|Box<T>}}\n|A pointer to a [[Heap (programming)|heap]]-allocated value<ref>{{Cite web |title=std::boxed \u2013 Rust |url=https://doc.rust-lang.org/std/boxed/index.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>. Similar to C++'s [https://en.cppreference.com/w/cpp/memory/unique_ptr std::unique_ptr].\n| <syntaxhighlight lang=\"rust\">\nlet boxed: Box<u8> = Box::new(5);\nlet val: u8 = *boxed;\n</syntaxhighlight>\n|-\n|{{Rust|Rc<T>}}\n|[[Reference counting]] pointer<ref>{{Cite web |title=Rc in std::rc \u2013 Rust |url=https://doc.rust-lang.org/beta/std/rc/struct.Rc.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet five = Rc::new(5);\nlet also_five = five.clone();\n</syntaxhighlight>\n|-\n|{{Rust|Arc<T>}}\n|[[Linearizability|Atomic]], [[Thread safety|thread-safe]] reference counting pointer<ref>{{Cite web |title=Arc in std::sync \u2013 Rust |url=https://doc.rust-lang.org/beta/std/sync/struct.Arc.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet foo = Arc::new(vec![1.0, 2.0]);\nlet a = foo.clone(); // a can be sent to another thread\n</syntaxhighlight>\n|-\n|{{Rust|Cell<T>}}\n|A mutable memory location<ref>{{Cite web |title=Cell in std::cell \u2013 Rust |url=https://doc.rust-lang.org/beta/std/cell/struct.Cell.html# |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet c = Cell::new(5);\nc.set(10);\n</syntaxhighlight>\n|-\n|<code>Mutex<T></code>\n|A [[Lock (computer science)|mutex lock]] for shared data contained within.<ref>{{Cite web |title=Mutex in std::sync \u2013 Rust |url=https://doc.rust-lang.org/beta/std/sync/struct.Mutex.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet mutex = Mutex::new(0_u32);\nlet _guard = mutex.lock();\n</syntaxhighlight>\n|-\n|{{Rust|RwLock<T>}}\n|[[Readers\u2013writer lock]]<ref>{{Cite web |title=RwLock in std::sync \u2013 Rust |url=https://doc.rust-lang.org/beta/std/sync/struct.RwLock.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet lock = RwLock::new(5);\nlet r1 = lock.read().unwrap();\n</syntaxhighlight>\n|-\n|{{Rust|Condvar}}\n|A [[Monitor (synchronization)|conditional monitor]] for shared data<ref>{{Cite web |title=Condvar in std::sync \u2013 Rust |url=https://doc.rust-lang.org/beta/std/sync/struct.Condvar.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\n let (lock, cvar) = (Mutex::new(true), Condvar::new());\n// As long as the value inside the `Mutex<bool>` is `true`, we wait.\nlet _guard = cvar.wait_while(lock.lock().unwrap(), |pending| { *pending }).unwrap();\n\n</syntaxhighlight>\n|-\n|{{Rust|Duration}}\n|Type that represents a span of time<ref>{{Cite web |title=Duration in std::time \u2013 Rust |url=https://doc.rust-lang.org/beta/std/time/struct.Duration.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nDuration::from_millis(1) // 1ms\n</syntaxhighlight>\n|-\n|{{Rust|1=HashMap<K, V>}}\n|[[Hash table]]<ref>{{Cite web |title=HashMap in std::collections \u2013 Rust |url=https://doc.rust-lang.org/beta/std/collections/struct.HashMap.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet mut player_stats = HashMap::new();\nplayer_stats.insert(\"damage\", 1);\nplayer_stats.entry(\"health\").or_insert(100);\n</syntaxhighlight>\n|-\n|{{Rust|1=BTreeMap<K, V>}}\n|[[B-tree]]<ref>{{Cite web |title=BTreeMap in std::collections \u2013 Rust |url=https://doc.rust-lang.org/beta/std/collections/struct.BTreeMap.html |access-date=2023-06-24 |website=doc.rust-lang.org}}</ref>\n|<syntaxhighlight lang=\"rust\">\nlet mut solar_distance = BTreeMap::from([\n    (\"Mercury\", 0.4),\n    (\"Venus\", 0.7),\n]);\nsolar_distance.entry(\"Earth\").or_insert(1.0);\n\n</syntaxhighlight>\n|}\n\n[[Option type|<code>Option</code>]] values are handled using [[syntactic sugar]], such as the <code>if let</code> construction, to access the inner value (in this case, a string):{{sfn|McNamara|2021}}\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    let name1: Option<&str> = None;\n    // In this case, nothing will be printed out\n    if let Some(name) = name1 {\n        println!(\"{name}\");\n    }\n\n    let name2: Option<&str> = Some(\"Matthew\");\n    // In this case, the word \"Matthew\" will be printed out\n    if let Some(name) = name2 {\n        println!(\"{name}\");\n    }\n}\n</syntaxhighlight>\n\n"}, {"title": " Pointers ", "content": "{| class=\"wikitable\"\n|+Summary of Rust's [[Pointer (computer programming)|pointer]] and [[Reference (computer science)|reference]] primitive types\n!Type\n!Description\n!Examples\n|-\n|{{plainlist|\n* {{Rust|&T}}\n* {{Rust|&mut T}}\n  }}\n|[[Reference (computer science)|References]] (immutable and mutable)\n|{{plainlist|\n* {{Rust|let x_ref {{=}} {{not a typo|&x;}}}}\n* {{Rust|let x_ref {{=}} &mut x;}}\n  }}\n|-\n|{{plainlist|\n* {{Rust|Option<&T>}}\n* {{Rust|Option<&mut T>}}\n  }}\n|{{plainlist|\n* Option wrapped reference\n* Possibly null reference\n  }}\n|{{plainlist|\n* {{Rust|None}}\n* {{Rust|let x_ref {{=}} Some(&x);}}\n* {{Rust|let x_ref {{=}} Some(&mut x);}}\n  }}\n|-\n|{{Plain list|* {{Rust|Box<T>}}\n* {{Rust|Option<Box<T>>}}}}\n|A pointer to heap-allocated value\n(or possibly null pointer if wrapped in option)<ref name=\"std::boxed \u2013 Rust\"/>\n|{{Plain list|* {{Rust|let boxed {{=}} Box::new(0);}}\n* {{Rust|let boxed {{=}} Some(Box::new(\"Hello World\"));}}}}\n|-\n|{{Plainlist|\n* {{Rust|*const T}}\n* {{Rust|*mut T}}\n  }}\n|{{Plainlist|\n* Raw pointers (immutable and mutable)\n* Possibly [[Null pointer|null]]; {{Rust|unsafe}} to [[dereference]]\n  }}\n|{{Plainlist|\n* {{Rust|let x_ptr {{=}} &x as *const T;}}\n* {{Rust|let x_ptr {{=}} &mut x as *mut T;}}\n  }}\n|}\n\nRust does not use [[null pointer]]s to indicate a lack of data, as doing so can lead to [[Null pointer#Null dereferencing|null dereferencing]]. Accordingly, the basic <code>&</code> and <code>&mut</code> references are guaranteed to not be null. Rust instead uses <code>Option</code> for this purpose: <code>Some(T)</code> indicates that a value is present, and <code>None</code> is analogous to the null pointer.{{sfn|Klabnik|Nichols|2019|pp=101\u2013104}} <code>Option</code> implements a \"null pointer optimization\", avoiding any spatial overhead for types that cannot have a null value (references or the <code>NonZero</code> types, for example).<ref>{{Cite web |title=std::option - Rust |url=https://doc.rust-lang.org/std/option/index.html#representation |access-date=2023-11-12 |website=doc.rust-lang.org}}</ref>\n\nUnlike references, the raw pointer types <code>*const</code> and <code>*mut</code> may be null; however, it is impossible to dereference them unless the code is explicitly declared unsafe through the use of an <code>unsafe</code> block. Unlike dereferencing, the creation of raw pointers is allowed inside of safe Rust code.{{sfn|Klabnik|Nichols|2019|pp=418\u2013427}}\n\n"}, {"title": " User-defined types ", "content": "User-defined types are created with the <code>struct</code> or <code>enum</code> keywords. The <code>struct</code> keyword is used to denote a [[Record (computer science)|record type]] that groups multiple related values.{{sfn|Klabnik|Nichols|2019|p=83}} <code>enum</code>s can take on different variants at runtime, with its capabilities similar to [[algebraic data types]] found in functional programming languages.{{sfn|Klabnik|Nichols|2019|p=97}} Both structs and enums can contain [[Field (computer science)|fields]] with different types.{{sfn|Klabnik|Nichols|2019|pp=98\u2013101}} Alternative names for the same type can be defined with the <code>type</code> keyword.{{sfn|Klabnik|Nichols|2019|pp=438\u2013440}}\n\nThe <code>impl</code> keyword can define methods for a user-defined type (data and functions are defined separately). Implementations fulfill a role similar to that of classes within other languages.{{sfn|Klabnik|Nichols|2019|pp=93}}\n\n"}, {"title": " Type conversion ", "content": "{{excerpt|Type conversion|Rust}}\n\n"}, {"title": " Ownership and lifetimes ", "content": "Rust's ownership system consists of rules that ensure memory safety without using a garbage collector. At compile time, each value must be attached to a variable called the ''owner'' of that value, and every value must have exactly one owner.{{sfn|Klabnik|Nichols|2019|pp=59\u201361}} Values are moved between different owners through assignment or passing a value as a function parameter.  Values can also be ''borrowed,'' meaning they are temporarily passed to a different function before being returned to the owner.{{sfn|Klabnik|Nichols|2019|pp=63\u201368}} With these rules, Rust can prevent the creation and use of [[dangling pointers]]:{{sfn|Klabnik|Nichols|2019|pp=63\u201368}}{{sfn|Klabnik|Nichols|2019|pp=74\u201375}}\n\n<syntaxhighlight lang=\"rust\">\nfn print_string(s: String) {\n    println!(\"{}\", s);\n}\n\nfn main() {\n    let s = String::from(\"Hello, World\");\n    print_string(s); // s consumed by print_string\n    // s has been moved, so cannot be used any more\n    // another print_string(s); would result in a compile error\n}\n</syntaxhighlight>\n\nBecause of these ownership rules, Rust types are known as ''[[linear types|linear]]'' or ''affine'' types, meaning each value can be used exactly once. This enforces a form of [[software fault isolation]] as the owner of a value is solely responsible for its correctness and deallocation.<ref name=\"BeyondSafety\">{{Cite book |last1=Balasubramanian |first1=Abhiram |last2=Baranowski |first2=Marek S. |last3=Burtsev |first3=Anton |last4=Panda |first4=Aurojit |last5=Rakamari\u0107 |first5=Zvonimir |last6=Ryzhyk |first6=Leonid |title=Proceedings of the 16th Workshop on Hot Topics in Operating Systems |chapter=System Programming in Rust |date=2017-05-07 |chapter-url=https://doi.org/10.1145/3102980.3103006 |series=HotOS '17 |location=New York, NY, US |publisher=Association for Computing Machinery |pages=156\u2013161 |doi=10.1145/3102980.3103006 |isbn=978-1-4503-5068-6 |s2cid=24100599 |access-date=June 1, 2022 |archive-date=June 11, 2022 |archive-url=https://web.archive.org/web/20220611034046/https://dl.acm.org/doi/10.1145/3102980.3103006 |url-status=live}}</ref>\n\nWhen a value goes out of scope, it is ''dropped'' by running its [[Destructor (computer programming)|destructor]]. The destructor may be programmatically defined through implementing the {{code|Drop}} [[#Traits|trait]]. This helps manage resources such as file handles, network sockets, and [[Lock (computer science)|locks]], since when objects are dropped, the resources associated with them are closed or released automatically.{{sfn|Klabnik|Nichols|2023|pp=327-30}}\n\n''Lifetimes'' are usually an implicit part of all [[Reference (computer science)|reference types]] in Rust. Each lifetime encompasses a set of locations in the code for which a variable is valid. For example, a reference to a local variable has a lifetime corresponding to the block it is defined in:{{sfn|Klabnik|Nichols|2019|p=194}}\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    let x = 5;                              // ------------------+- Lifetime 'b\n                                            //                   |\n    let r = &x;                             // -+-- Lifetime 'a  |\n                                            //  |                |\n    println!(\"r: {}\", r);                   //  |                |\n                                            //  |                |\n                                            // -+                |\n}                                           // ------------------+\n</syntaxhighlight>\n\nThe borrow checker in the Rust compiler uses lifetimes to ensure that the values a reference points to remain valid.{{sfn|Klabnik|Nichols|2019|pp=75,134}}<ref>{{Cite web |last=Shamrell-Harrington |first=Nell |title=The Rust Borrow Checker \u2013 a Deep Dive |url=https://www.infoq.com/presentations/rust-borrow-checker/ |access-date=2022-06-25 |website=InfoQ |language=en}}</ref> In the example above, storing a reference to variable {{code|x}} to {{code|r}} is valid, as variable {{code|x}} has a longer lifetime ({{code|'b}}) than variable {{code|r}} ({{code|'a}}). However, when {{code|x}} has a shorter lifetime, the borrow checker would reject the program:\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    let r;                                  // ------------------+- Lifetime 'a\n                                            //                   |\n    {                                       //                   |\n        let x = 5;                          // -+-- Lifetime 'b  |\n        r = x;                              //  |                |\n    }                                       //  |                |\n                                            //                   |\n    println!(\"r: {}\", r);                   //                   |\n}                                           // ------------------+\n</syntaxhighlight>\n\nSince the lifetime of the referenced variable ({{code|'b}}) is shorter than the lifetime of the variable holding the reference ({{code|'a}}), the borrow checker errors, preventing {{code|x}} from being used from outside its scope.{{sfn|Klabnik|Nichols|2019|pp=194-195}}\n\nRust defines the relationship between the lifetimes of the objects created and used by functions, using ''lifetime parameters'', as a signature feature.{{sfn|Klabnik|Nichols|2019|pp=192\u2013204}}\n\nThe example below parses some configuration options from a string and creates a struct containing the options. The struct only contains references to the data; so, for the struct to remain valid, the data referred to by the struct must be valid as well. The function signature for <code>parse_config</code> specifies this relationship explicitly. In this example, the explicit lifetimes are unnecessary in newer Rust versions, due to lifetime elision, which is an algorithm that automatically assigns lifetimes to functions if they are trivial.{{sfn|Klabnik|Nichols|2019|pp=201\u2013203}}\n\n<syntaxhighlight lang=\"rust\">\nuse std::collections::HashMap;\n\n// This struct has one lifetime parameter, 'src. The name is only used within the struct's definition.\n#[derive(Debug)]\nstruct Config<'src> {\n    hostname: &'src str,\n    username: &'src str,\n}\n\n// This function also has a lifetime parameter, 'cfg. 'cfg is attached to the \"config\" parameter, which\n// establishes that the data in \"config\" lives at least as long as the 'cfg lifetime.\n// The returned struct also uses 'cfg for its lifetime, so it can live at most as long as 'cfg.\nfn parse_config<'cfg>(config: &'cfg str) -> Config<'cfg> {\n    let key_values: HashMap<_, _> = config\n        .lines()\n        .filter(|line| !line.starts_with('#'))\n        .filter_map(|line| line.split_once('='))\n        .map(|(key, value)| (key.trim(), value.trim()))\n        .collect();\n    Config {\n        hostname: key_values[\"hostname\"],\n        username: key_values[\"username\"],\n    }\n}\n\nfn main() {\n    let config = parse_config(\n        r#\"hostname = foobar\nusername=barfoo\"#,\n    );\n    println!(\"Parsed config: {:#?}\", config);\n}\n</syntaxhighlight>\n\n[[File:Rust 101.webm|thumb|A presentation on Rust by Emily Dunham from [[Mozilla]]'s Rust team ([[linux.conf.au]] conference, Hobart, 2017)]]\n\n"}, {"title": " Memory safety ", "content": "Rust is designed to be [[memory safe]]. It does not permit null pointers, [[dangling pointer]]s, or [[data race]]s.<ref name=\"cnet\">{{cite web |url=http://reviews.cnet.com/8301-3514_7-57577639/samsung-joins-mozillas-quest-for-rust/ |title=Samsung joins Mozilla's quest for Rust |last=Rosenblatt |first=Seth |date=2013-04-03 |publisher=[[CNET]] |access-date=2013-04-05 |archive-date=2013-04-04 |archive-url=https://web.archive.org/web/20130404142333/http://reviews.cnet.com/8301-3514_7-57577639/samsung-joins-mozillas-quest-for-rust/ |url-status=live}}</ref><ref name=\"lwn\">{{cite web |url=https://lwn.net/Articles/547145/ |title=A taste of Rust |last=Brown |first=Neil |date=2013-04-17 |access-date=2013-04-25 |archive-date=2013-04-26 |archive-url=https://web.archive.org/web/20130426010754/http://lwn.net/Articles/547145/ |url-status=live}}</ref><ref name=\"The Rustonomicon\">{{Cite web|url=https://doc.rust-lang.org/nomicon/races.html|title=Races \u2013 The Rustonomicon|website=doc.rust-lang.org|access-date=2017-07-03|archive-date=2017-07-10|archive-url=https://web.archive.org/web/20170710194643/https://doc.rust-lang.org/nomicon/races.html|url-status=live}}</ref> Data values can be initialized only through a fixed set of forms, all of which require their inputs to be already initialized.<ref name=\"lang-faq\">{{cite web  |title=The Rust Language FAQ |website=static.rust-lang.org |url=http://static.rust-lang.org/doc/master/complement-lang-faq.html |url-status=dead |archive-url=https://web.archive.org/web/20150420104147/http://static.rust-lang.org/doc/master/complement-lang-faq.html |archive-date=2015-04-20 |year=2015 |access-date=2017-04-24}}</ref>\n\nUnsafe code can subvert some of these restrictions, using the <code>unsafe</code> keyword.{{sfn|Klabnik|Nichols|2019|pp=418\u2013427}} Unsafe code may also be used for low-level functionality, such as [[Volatile (computer programming)|volatile memory access]], architecture-specific intrinsics, [[type punning]], and inline assembly.{{sfn|McNamara|2021|p=139, 376\u2013379, 395}}\n\n"}, {"title": " Memory management ", "content": "Rust does not use [[garbage collection (computer science)|garbage collection]]. Memory and other resources are instead managed through the \"resource acquisition is initialization\" convention,<ref>{{Cite web|title=RAII \u2013 Rust By Example|url=https://doc.rust-lang.org/rust-by-example/scope/raii.html|access-date=2020-11-22|website=doc.rust-lang.org|archive-date=2019-04-21|archive-url=https://web.archive.org/web/20190421131142/https://doc.rust-lang.org/rust-by-example/scope/raii.html|url-status=live}}</ref> with optional [[reference counting]]. Rust provides deterministic management of resources, with very low [[Overhead (computing)|overhead]].<ref>{{Cite web|url=https://blog.rust-lang.org/2015/05/11/traits.html|title=Abstraction without overhead: traits in Rust|website=Rust Blog|access-date=October 19, 2021|archive-date=September 23, 2021|archive-url=https://web.archive.org/web/20210923101530/https://blog.rust-lang.org/2015/05/11/traits.html|url-status=live}}</ref> Values are [[Stack-based memory allocation|allocated on the stack]] by default, and all [[dynamic allocation]]s must be explicit.<ref>{{Cite web |title=Box, stack and heap |url=https://doc.rust-lang.org/stable/rust-by-example/std/box.html |access-date=2022-06-13 |website=Rust By Example}}</ref>\n\nThe built-in reference types using the <code>&</code> symbol do not involve run-time reference counting. The safety and validity of the underlying pointers is verified at compile time, preventing [[dangling pointers]] and other forms of [[undefined behavior]].{{sfn|Klabnik|Nichols|2019|pp=70\u201375}} Rust's type system separates shared, [[Immutable object|immutable]] references of the form <code>&T</code> from unique, mutable references of the form <code>&mut T</code>. A mutable reference can be coerced to an immutable reference, but not vice versa.{{sfn|Klabnik|Nichols|2019|p=323}}\n\n"}, {"title": " Polymorphism ", "content": "==== Generics ====\nRust's more advanced features include the use of [[generic function]]s. A generic function is given [[Generic programming|generic]] [[Parameter (computer programming)|parameters]], which allow the same function to be applied to different variable types. This capability reduces [[duplicate code]]{{sfn|Klabnik|Nichols|2019|pp=171\u2013172}} and is known as [[parametric polymorphism]].\n\nThe following program calculates the sum of two things, for which addition is implemented using a generic function:\n\n<syntaxhighlight lang=\"rust\">\nuse std::ops::Add;\n\n// sum is a generic function with one type parameter, T\nfn sum<T>(num1: T, num2: T) -> T\nwhere  \n    T: Add<Output = T>,  // T must implement the Add trait where addition returns another T\n{\n    num1 + num2  // num1 + num2 is syntactic sugar for num1.add(num2) provided by the Add trait\n}\n\nfn main() {\n    let result1 = sum(10, 20);\n    println!(\"Sum is: {}\", result1); // Sum is: 30\n\n    let result2 = sum(10.23, 20.45);\n    println!(\"Sum is: {}\", result2); // Sum is: 30.68\n}\n</syntaxhighlight>\n\nAt compile time, polymorphic functions like <code>sum</code> are [[Instance (computer science)|instantiated]] with the specific types the code requires; in this case, sum of integers and sum of floats.\n\nGenerics can be used in functions to allow implementing a behavior for different types without repeating the same code. Generic functions can be written in relation to other generics, without knowing the actual type.{{sfn|Klabnik|Nichols|2019|pp=171\u2013172,205}}\n\n==== Traits ====\nRust's type system supports a mechanism called traits, inspired by [[type class]]es in the [[Haskell]] language,<ref name=\"influences\"/> to define shared behavior between different types. For example, the <code>Add</code> trait can be implemented for floats and integers, which can be added; and the <code>Display</code> or <code>Debug</code> traits can be implemented for any type that can be converted to a string. Traits can be used to provide a set of common behavior for different types without knowing the actual type. This facility is known as [[ad hoc polymorphism]].\n\nGeneric functions can constrain the generic type to implement a particular trait or traits; for example, an <code>add_one</code> function might require the type to implement <code>Add</code>. This means that a generic function can be type-checked as soon as it is defined. The implementation of generics is similar to the typical implementation of C++ templates: a separate copy of the code is generated for each instantiation. This is called [[monomorphization]] and contrasts with the [[type erasure]] scheme typically used in Java and Haskell. Type erasure is also available via the keyword <code>dyn</code> (short for dynamic).{{sfn|Klabnik|Nichols|2019|pp=181,182}} Because monomorphization duplicates the code for each type used, it can result in more optimized code for specific-use cases, but compile time and size of the output binary are also increased.{{sfn|Gjengset|2021|p=25}}\n\nIn addition to defining methods for a user-defined type, the <code>impl</code> keyword can be used to implement a trait for a type.{{sfn|Klabnik|Nichols|2019|pp=93}} Traits can provide additional derived methods when implemented.{{sfn|Klabnik|Nichols|2019|pp=182\u2013184}} For example, the trait <code>Iterator</code> requires that the <code>next</code> method be defined for the type. Once the <code>next</code> method is defined, the trait can provide common functional helper methods over the iterator, such as <code>map</code> or <code>filter</code>.{{sfn|Klabnik|Nichols|2019|pp=281\u2013283}}\n\n==== Trait objects ====\nRust traits are implemented using [[static dispatch]], meaning that the type of all values is known at compile time; however, Rust also uses a feature known as ''trait objects'' to accomplish [[dynamic dispatch]] (also known as [[duck typing]]).<ref name=TraitObjectsBook>{{Cite web |title=Using Trait Objects That Allow for Values of Different Types \u2013 The Rust Programming Language |url=https://doc.rust-lang.org/book/ch17-02-trait-objects.html |access-date=2022-07-11 |website=doc.rust-lang.org}}</ref> Dynamically dispatched trait objects are declared using the syntax <code>dyn Tr</code> where <code>Tr</code> is a trait. Trait objects are dynamically sized, therefore they must be put behind a pointer, such as <code>Box</code>.{{sfn|Klabnik|Nichols|2019|pp=441\u2013442}} The following example creates a list of objects where each object can be printed out using the <code>Display</code> trait:\n\n<syntaxhighlight lang=\"Rust\">\nuse std::fmt::Display;\n\nlet v: Vec<Box<dyn Display>> = vec![\n    Box::new(3),\n    Box::new(5.0),\n    Box::new(\"hi\"),\n];\n\nfor x in v {\n    println!(\"{x}\");\n}\n</syntaxhighlight>\n\nIf an element in the list does not implement the <code>Display</code> trait, it will cause a compile-time error.{{sfn|Klabnik|Nichols|2019|pp=379\u2013380}}\n\n"}, {"title": " Generics ", "content": "Rust's more advanced features include the use of [[generic function]]s. A generic function is given [[Generic programming|generic]] [[Parameter (computer programming)|parameters]], which allow the same function to be applied to different variable types. This capability reduces [[duplicate code]]{{sfn|Klabnik|Nichols|2019|pp=171\u2013172}} and is known as [[parametric polymorphism]].\n\nThe following program calculates the sum of two things, for which addition is implemented using a generic function:\n\n<syntaxhighlight lang=\"rust\">\nuse std::ops::Add;\n\n// sum is a generic function with one type parameter, T\nfn sum<T>(num1: T, num2: T) -> T\nwhere  \n    T: Add<Output = T>,  // T must implement the Add trait where addition returns another T\n{\n    num1 + num2  // num1 + num2 is syntactic sugar for num1.add(num2) provided by the Add trait\n}\n\nfn main() {\n    let result1 = sum(10, 20);\n    println!(\"Sum is: {}\", result1); // Sum is: 30\n\n    let result2 = sum(10.23, 20.45);\n    println!(\"Sum is: {}\", result2); // Sum is: 30.68\n}\n</syntaxhighlight>\n\nAt compile time, polymorphic functions like <code>sum</code> are [[Instance (computer science)|instantiated]] with the specific types the code requires; in this case, sum of integers and sum of floats.\n\nGenerics can be used in functions to allow implementing a behavior for different types without repeating the same code. Generic functions can be written in relation to other generics, without knowing the actual type.{{sfn|Klabnik|Nichols|2019|pp=171\u2013172,205}}\n\n"}, {"title": " Traits ", "content": "Rust's type system supports a mechanism called traits, inspired by [[type class]]es in the [[Haskell]] language,<ref name=\"influences\"/> to define shared behavior between different types. For example, the <code>Add</code> trait can be implemented for floats and integers, which can be added; and the <code>Display</code> or <code>Debug</code> traits can be implemented for any type that can be converted to a string. Traits can be used to provide a set of common behavior for different types without knowing the actual type. This facility is known as [[ad hoc polymorphism]].\n\nGeneric functions can constrain the generic type to implement a particular trait or traits; for example, an <code>add_one</code> function might require the type to implement <code>Add</code>. This means that a generic function can be type-checked as soon as it is defined. The implementation of generics is similar to the typical implementation of C++ templates: a separate copy of the code is generated for each instantiation. This is called [[monomorphization]] and contrasts with the [[type erasure]] scheme typically used in Java and Haskell. Type erasure is also available via the keyword <code>dyn</code> (short for dynamic).{{sfn|Klabnik|Nichols|2019|pp=181,182}} Because monomorphization duplicates the code for each type used, it can result in more optimized code for specific-use cases, but compile time and size of the output binary are also increased.{{sfn|Gjengset|2021|p=25}}\n\nIn addition to defining methods for a user-defined type, the <code>impl</code> keyword can be used to implement a trait for a type.{{sfn|Klabnik|Nichols|2019|pp=93}} Traits can provide additional derived methods when implemented.{{sfn|Klabnik|Nichols|2019|pp=182\u2013184}} For example, the trait <code>Iterator</code> requires that the <code>next</code> method be defined for the type. Once the <code>next</code> method is defined, the trait can provide common functional helper methods over the iterator, such as <code>map</code> or <code>filter</code>.{{sfn|Klabnik|Nichols|2019|pp=281\u2013283}}\n\n"}, {"title": " Trait objects ", "content": "Rust traits are implemented using [[static dispatch]], meaning that the type of all values is known at compile time; however, Rust also uses a feature known as ''trait objects'' to accomplish [[dynamic dispatch]] (also known as [[duck typing]]).<ref name=TraitObjectsBook>{{Cite web |title=Using Trait Objects That Allow for Values of Different Types \u2013 The Rust Programming Language |url=https://doc.rust-lang.org/book/ch17-02-trait-objects.html |access-date=2022-07-11 |website=doc.rust-lang.org}}</ref> Dynamically dispatched trait objects are declared using the syntax <code>dyn Tr</code> where <code>Tr</code> is a trait. Trait objects are dynamically sized, therefore they must be put behind a pointer, such as <code>Box</code>.{{sfn|Klabnik|Nichols|2019|pp=441\u2013442}} The following example creates a list of objects where each object can be printed out using the <code>Display</code> trait:\n\n<syntaxhighlight lang=\"Rust\">\nuse std::fmt::Display;\n\nlet v: Vec<Box<dyn Display>> = vec![\n    Box::new(3),\n    Box::new(5.0),\n    Box::new(\"hi\"),\n];\n\nfor x in v {\n    println!(\"{x}\");\n}\n</syntaxhighlight>\n\nIf an element in the list does not implement the <code>Display</code> trait, it will cause a compile-time error.{{sfn|Klabnik|Nichols|2019|pp=379\u2013380}}\n\n"}, {"title": " Iterators ", "content": "[[For loop]]s in Rust work in a functional style as operations over an [[iterator]] type. For example, in the loop\n\n<syntaxhighlight lang=\"rust\">\nfor x in 0..100 {\n   f(x);\n}\n</syntaxhighlight>\n\n<code>0..100</code> is a value of type <code>Range</code> which implements the <code>Iterator</code> trait; the code applies the function <code>f</code> to each element returned by the iterator. Iterators can be combined with functions over iterators like <code>map</code>, <code>filter</code>, and <code>sum</code>. For example, the following adds up all numbers between 1 and 100 that are multiples of 3:\n\n<syntaxhighlight lang=\"rust\">\n(1..=100).filter(|&x| x % 3 == 0).sum()\n</syntaxhighlight>\n\n"}, {"title": " Macros ", "content": "It is possible to extend the Rust language using macros.\n\n==== Declarative macros ====\nA declarative macro (also called a \"macro by example\") is a macro that uses pattern matching to determine its expansion.<ref name=\"Rust Ref. \u2013 Macros By Example\">{{cite web |title=Macros By Example |url=https://doc.rust-lang.org/reference/macros-by-example.html |archive-url= |archive-date= |url-status= |website=The Rust Reference |access-date=21 April 2023}}</ref>{{sfn|Klabnik|Nichols|2019|pp=446\u2013448}}\n\n==== Procedural macros ====\nProcedural macros are Rust functions that run and modify the compiler's input [[Token (parser)|token]] stream, before any other components are compiled. They are generally more flexible than declarative macros, but are more difficult to maintain due to their complexity.<ref name=\"rust-procedural-macros\">{{cite web |url=https://doc.rust-lang.org/reference/procedural-macros.html |title=Procedural Macros |website=The Rust Programming Language Reference |access-date=23 Mar 2021 |archive-date=7 November 2020 |archive-url=https://web.archive.org/web/20201107233444/https://doc.rust-lang.org/reference/procedural-macros.html |url-status=live}}</ref>{{sfn|Klabnik|Nichols|2019|pp=449\u2013455}}\n\nProcedural macros come in three flavors:\n* Function-like macros <code>custom!(...)</code>\n* Derive macros <code>#[derive(CustomDerive)]</code>\n* Attribute macros <code>#[custom_attribute]</code>\n\nThe <code>println!</code> macro is an example of a function-like macro. The<code>serde_derive</code> macro<ref>{{cite web|url=https://serde.rs/derive.html|title=Serde Derive|website=Serde Derive documentation|access-date=23 Mar 2021|archive-date=17 April 2021|archive-url=https://web.archive.org/web/20210417114849/https://serde.rs/derive.html|url-status=live}}</ref> provides a commonly used library for generating code\nfor reading and writing data in many formats, such as [[JSON]]. Attribute macros are commonly used for language bindings, such as the <code>extendr</code> library for Rust bindings to [[R (programming language)|R]].<ref>{{cite web|url=https://extendr.github.io/extendr/extendr_api/index.html|title=extendr_api \u2013 Rust|website=Extendr Api Documentation|access-date=23 Mar 2021|archive-date=May 25, 2021|archive-url=https://web.archive.org/web/20210525082129/https://extendr.github.io/extendr/extendr_api/index.html|url-status=live}}</ref>\n\nThe following code shows the use of the <code>Serialize</code>, <code>Deserialize</code>, and <code>Debug</code>-derived procedural macros\nto implement JSON reading and writing, as well as the ability to format a structure for debugging.\n[[File:Rust serde UML diagram.svg|thumb|A [[UML diagram]] depicting a Rust struct named Point.]]\n<syntaxhighlight lang=\"rust\">\nuse serde_json::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let point = Point { x: 1, y: 2 };\n\n    let serialized = serde_json::to_string(&point).unwrap();\n    println!(\"serialized = {}\", serialized);\n\n    let deserialized: Point = serde_json::from_str(&serialized).unwrap();\n    println!(\"deserialized = {:?}\", deserialized);\n}\n</syntaxhighlight>\n\n==== Variadic macros ====\n{{excerpt|Variadic function|In Rust|subsections=yes}}\n\n"}, {"title": " Declarative macros ", "content": "A declarative macro (also called a \"macro by example\") is a macro that uses pattern matching to determine its expansion.<ref name=\"Rust Ref. \u2013 Macros By Example\">{{cite web |title=Macros By Example |url=https://doc.rust-lang.org/reference/macros-by-example.html |archive-url= |archive-date= |url-status= |website=The Rust Reference |access-date=21 April 2023}}</ref>{{sfn|Klabnik|Nichols|2019|pp=446\u2013448}}\n\n"}, {"title": " Procedural macros ", "content": "Procedural macros are Rust functions that run and modify the compiler's input [[Token (parser)|token]] stream, before any other components are compiled. They are generally more flexible than declarative macros, but are more difficult to maintain due to their complexity.<ref name=\"rust-procedural-macros\">{{cite web |url=https://doc.rust-lang.org/reference/procedural-macros.html |title=Procedural Macros |website=The Rust Programming Language Reference |access-date=23 Mar 2021 |archive-date=7 November 2020 |archive-url=https://web.archive.org/web/20201107233444/https://doc.rust-lang.org/reference/procedural-macros.html |url-status=live}}</ref>{{sfn|Klabnik|Nichols|2019|pp=449\u2013455}}\n\nProcedural macros come in three flavors:\n* Function-like macros <code>custom!(...)</code>\n* Derive macros <code>#[derive(CustomDerive)]</code>\n* Attribute macros <code>#[custom_attribute]</code>\n\nThe <code>println!</code> macro is an example of a function-like macro. The<code>serde_derive</code> macro<ref>{{cite web|url=https://serde.rs/derive.html|title=Serde Derive|website=Serde Derive documentation|access-date=23 Mar 2021|archive-date=17 April 2021|archive-url=https://web.archive.org/web/20210417114849/https://serde.rs/derive.html|url-status=live}}</ref> provides a commonly used library for generating code\nfor reading and writing data in many formats, such as [[JSON]]. Attribute macros are commonly used for language bindings, such as the <code>extendr</code> library for Rust bindings to [[R (programming language)|R]].<ref>{{cite web|url=https://extendr.github.io/extendr/extendr_api/index.html|title=extendr_api \u2013 Rust|website=Extendr Api Documentation|access-date=23 Mar 2021|archive-date=May 25, 2021|archive-url=https://web.archive.org/web/20210525082129/https://extendr.github.io/extendr/extendr_api/index.html|url-status=live}}</ref>\n\nThe following code shows the use of the <code>Serialize</code>, <code>Deserialize</code>, and <code>Debug</code>-derived procedural macros\nto implement JSON reading and writing, as well as the ability to format a structure for debugging.\n[[File:Rust serde UML diagram.svg|thumb|A [[UML diagram]] depicting a Rust struct named Point.]]\n<syntaxhighlight lang=\"rust\">\nuse serde_json::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let point = Point { x: 1, y: 2 };\n\n    let serialized = serde_json::to_string(&point).unwrap();\n    println!(\"serialized = {}\", serialized);\n\n    let deserialized: Point = serde_json::from_str(&serialized).unwrap();\n    println!(\"deserialized = {:?}\", deserialized);\n}\n</syntaxhighlight>\n\n"}, {"title": " Variadic macros ", "content": "{{excerpt|Variadic function|In Rust|subsections=yes}}\n\n"}, {"title": " Interface with C and C++ ", "content": "Rust has a [[foreign function interface]] (FFI) that can be used both to call code written in languages such as [[C (programming language)|C]] from Rust and to call Rust code from those languages. As of 2023, an external library called CXX exists for calling to or from C++.<ref>{{Cite web|title=Safe Interoperability between Rust and C++ with CXX|url=https://www.infoq.com/news/2020/12/cpp-rust-interop-cxx/|date=2020-12-06|access-date=2021-01-03|website=InfoQ|language=en|archive-date=January 22, 2021|archive-url=https://web.archive.org/web/20210122142035/https://www.infoq.com/news/2020/12/cpp-rust-interop-cxx/|url-status=live}}</ref> Rust and C differ in how they lay out structs in memory, so Rust structs may be given a <code>#[repr(C)]</code> attribute, forcing the same layout as the equivalent C struct.<ref>{{cite web |title=Type layout \u2013 The Rust Reference |url=https://doc.rust-lang.org/reference/type-layout.html#the-c-representation |website=doc.rust-lang.org |access-date=15 July 2022}}</ref>\n\n"}, {"title": " Ecosystem ", "content": "[[File:Rustc building paru with cargo screenshot.png|thumb|right|Compiling a Rust program with Cargo]]\n\nThe Rust ecosystem includes its compiler, its [[standard library]], and additional components for software development. Component installation is typically managed by {{code|rustup}}, a Rust [[toolchain]] installer developed by the Rust project.{{sfn|Blandy|Orendorff|Tindall|2021|pp=6-8}}\n<!-- Add Miri Compiler? -->\n\n=== Compiler ===\nThe Rust compiler is named <code>rustc</code>, and translates Rust code into a low level language called LLVM intermediate representation (LLVM IR). LLVM is then invoked as a subcomponent to translate IR code into [[machine code]]. A [[Linker (computing)|linker]] is then used to combine multiple crates together as a single executable or binary file.{{sfn|McNamara|2021|pp=411-412}}<ref>{{Cite web |title=Overview of the compiler |url=https://rustc-dev-guide.rust-lang.org/overview.html |access-date=2023-06-02 |website=Rust Compiler Development Guide}}</ref>\n\nOther than LLVM, the compiler also supports using alternative backends such as [[GNU Compiler Collection|GCC]] and [[Cranelift]] for code generation.<ref>{{cite web |title=Code Generation - Rust Compiler Development Guide |url=https://rustc-dev-guide.rust-lang.org/backend/codegen.html |website=rustc-dev-guide.rust-lang.org |access-date=3 March 2024}}</ref> The intention of those alternative backends is to increase platform coverage of Rust or to improve compilation times.<ref>{{cite web |title=rust-lang/rustc_codegen_gcc |url=https://github.com/rust-lang/rustc_codegen_gcc#Motivation |website=GitHub |publisher=The Rust Programming Language |access-date=3 March 2024 |date=2 March 2024}}</ref><ref>{{cite web |title=rust-lang/rustc_codegen_cranelift |url=https://github.com/rust-lang/rustc_codegen_cranelift |website=GitHub |publisher=The Rust Programming Language |access-date=3 March 2024 |date=2 March 2024}}</ref>\n\n=== Standard library ===\nThe Rust standard library defines and implements many widely used custom data types, including core data structures such as {{code|Vec}}, {{code|Option}}, and {{code|HashMap}}, as well as [[smart pointer]] types. Rust also provides a way to exclude most of the standard library using the attribute {{rust|#![no_std]}}; this enables applications, such as embedded devices, which want to remove dependency code or provide their own core data structures. Internally, the standard library is divided into three parts, {{code|core}}, {{code|alloc}}, and {{code|std}}, where {{code|std}} and {{Code|alloc}} are excluded by {{rust|#![no_std]}}.{{sfn|Gjengset|2021|p=213-215}}\n\n[[File:Crates.io website.png|thumb|right|Screenshot of crates.io in June 2022]]\n\n=== Cargo ===\nCargo is Rust's [[Build automation|build system]] and [[package manager]]. It downloads, compiles, distributes, and uploads packages\u2014called ''crates''\u2014that are maintained in an official registry. It also acts as a front-end for Clippy and other Rust components.<ref name=\"Nature\" />\n\nBy default, Cargo sources its dependencies from the user-contributed registry ''crates.io'', but [[Git]] repositories and crates in the local filesystem, and other external sources can also be specified as dependencies.<ref>{{Cite web |last=Simone |first=Sergio De |date=2019-04-18 |title=Rust 1.34 Introduces Alternative Registries for Non-Public Crates |url=https://www.infoq.com/news/2019/04/rust-1.34-additional-registries |access-date=2022-07-14 |website=InfoQ |language=en}}</ref>\n\n=== Rustfmt ===\nRustfmt is a [[code formatter]] for Rust. It formats whitespace and [[Indentation style|indentation]] to produce code in accordance with a common [[Programming style|style]], unless otherwise specified. It can be invoked as a standalone program, or from a Rust project through Cargo.{{sfn|Klabnik|Nichols|2019|pp=511\u2013512}}\n\n[[File:Cargo clippy hello world example.png|thumb|right|Example output of Clippy on a hello world Rust program]]\n\n=== Clippy ===\nClippy is Rust's built-in [[linting]] tool to improve the correctness, performance, and readability of Rust code. {{as of|2024}}, it has more than 700 rules.<ref>{{Citation |title=Clippy |date=2023-11-30 |url=https://github.com/rust-lang/rust-clippy |access-date=2023-11-30 |publisher=The Rust Programming Language}}</ref><ref>{{Cite web |title=Clippy Lints |url=https://rust-lang.github.io/rust-clippy/master/index.html |access-date=2023-11-30 |website=The Rust Programming Language}}</ref>\n\n=== Versioning system ===\nFollowing Rust 1.0, new features are developed in ''nightly'' versions which are released daily. During each six-week release cycle, changes to nightly versions are released to beta, while changes from the previous beta version are released to a new stable version.<ref name=\"Rust Book G\">{{harvnb|Klabnik|Nichols|2019|loc=Appendix G \u2013 How Rust is Made and \"Nightly Rust\"}}</ref>\n\nEvery two or three years, a new \"edition\" is produced. Editions are released to allow making limited [[breaking changes]], such as promoting {{code|await}} to a keyword to support [[async/await]] features. Crates targeting different editions can interoperate with each other, so a crate can upgrade to a new edition even if its callers or its dependencies still target older editions. Migration to a new edition can be assisted with automated tooling.{{sfn|Blandy|Orendorff|Tindall|2021|pp=176\u2013177}}\n\n=== IDE support ===\nThe most popular [[Language Server Protocol|language server]] for Rust is ''Rust Analyzer'', which officially replaced the original language server, ''RLS'', in July 2022.<ref>{{Cite web |first=Tim |last=Anderson |date=2022-07-05 |title=Rust team releases 1.62, sets end date for deprecated language server |url=https://devclass.com/2022/07/05/rust-team-releases-1-62-sets-end-date-for-deprecated-language-server/ |access-date=2022-07-14 |website=DEVCLASS |language=en-GB}}</ref> Rust Analyzer provides [[Integrated development environment|IDE]]s and [[text editor]]s with information about a Rust project; basic features including [[autocompletion]], and the display of compilation errors while editing.{{sfn|Klabnik|Nichols|2023|p=623}}\n\n"}, {"title": " Compiler ", "content": "The Rust compiler is named <code>rustc</code>, and translates Rust code into a low level language called LLVM intermediate representation (LLVM IR). LLVM is then invoked as a subcomponent to translate IR code into [[machine code]]. A [[Linker (computing)|linker]] is then used to combine multiple crates together as a single executable or binary file.{{sfn|McNamara|2021|pp=411-412}}<ref>{{Cite web |title=Overview of the compiler |url=https://rustc-dev-guide.rust-lang.org/overview.html |access-date=2023-06-02 |website=Rust Compiler Development Guide}}</ref>\n\nOther than LLVM, the compiler also supports using alternative backends such as [[GNU Compiler Collection|GCC]] and [[Cranelift]] for code generation.<ref>{{cite web |title=Code Generation - Rust Compiler Development Guide |url=https://rustc-dev-guide.rust-lang.org/backend/codegen.html |website=rustc-dev-guide.rust-lang.org |access-date=3 March 2024}}</ref> The intention of those alternative backends is to increase platform coverage of Rust or to improve compilation times.<ref>{{cite web |title=rust-lang/rustc_codegen_gcc |url=https://github.com/rust-lang/rustc_codegen_gcc#Motivation |website=GitHub |publisher=The Rust Programming Language |access-date=3 March 2024 |date=2 March 2024}}</ref><ref>{{cite web |title=rust-lang/rustc_codegen_cranelift |url=https://github.com/rust-lang/rustc_codegen_cranelift |website=GitHub |publisher=The Rust Programming Language |access-date=3 March 2024 |date=2 March 2024}}</ref>\n\n"}, {"title": " Standard library ", "content": "The Rust standard library defines and implements many widely used custom data types, including core data structures such as {{code|Vec}}, {{code|Option}}, and {{code|HashMap}}, as well as [[smart pointer]] types. Rust also provides a way to exclude most of the standard library using the attribute {{rust|#![no_std]}}; this enables applications, such as embedded devices, which want to remove dependency code or provide their own core data structures. Internally, the standard library is divided into three parts, {{code|core}}, {{code|alloc}}, and {{code|std}}, where {{code|std}} and {{Code|alloc}} are excluded by {{rust|#![no_std]}}.{{sfn|Gjengset|2021|p=213-215}}\n\n[[File:Crates.io website.png|thumb|right|Screenshot of crates.io in June 2022]]\n\n"}, {"title": " Cargo ", "content": "Cargo is Rust's [[Build automation|build system]] and [[package manager]]. It downloads, compiles, distributes, and uploads packages\u2014called ''crates''\u2014that are maintained in an official registry. It also acts as a front-end for Clippy and other Rust components.<ref name=\"Nature\" />\n\nBy default, Cargo sources its dependencies from the user-contributed registry ''crates.io'', but [[Git]] repositories and crates in the local filesystem, and other external sources can also be specified as dependencies.<ref>{{Cite web |last=Simone |first=Sergio De |date=2019-04-18 |title=Rust 1.34 Introduces Alternative Registries for Non-Public Crates |url=https://www.infoq.com/news/2019/04/rust-1.34-additional-registries |access-date=2022-07-14 |website=InfoQ |language=en}}</ref>\n\n"}, {"title": " Rustfmt ", "content": "Rustfmt is a [[code formatter]] for Rust. It formats whitespace and [[Indentation style|indentation]] to produce code in accordance with a common [[Programming style|style]], unless otherwise specified. It can be invoked as a standalone program, or from a Rust project through Cargo.{{sfn|Klabnik|Nichols|2019|pp=511\u2013512}}\n\n[[File:Cargo clippy hello world example.png|thumb|right|Example output of Clippy on a hello world Rust program]]\n\n"}, {"title": " Clippy ", "content": "Clippy is Rust's built-in [[linting]] tool to improve the correctness, performance, and readability of Rust code. {{as of|2024}}, it has more than 700 rules.<ref>{{Citation |title=Clippy |date=2023-11-30 |url=https://github.com/rust-lang/rust-clippy |access-date=2023-11-30 |publisher=The Rust Programming Language}}</ref><ref>{{Cite web |title=Clippy Lints |url=https://rust-lang.github.io/rust-clippy/master/index.html |access-date=2023-11-30 |website=The Rust Programming Language}}</ref>\n\n"}, {"title": " Versioning system ", "content": "Following Rust 1.0, new features are developed in ''nightly'' versions which are released daily. During each six-week release cycle, changes to nightly versions are released to beta, while changes from the previous beta version are released to a new stable version.<ref name=\"Rust Book G\">{{harvnb|Klabnik|Nichols|2019|loc=Appendix G \u2013 How Rust is Made and \"Nightly Rust\"}}</ref>\n\nEvery two or three years, a new \"edition\" is produced. Editions are released to allow making limited [[breaking changes]], such as promoting {{code|await}} to a keyword to support [[async/await]] features. Crates targeting different editions can interoperate with each other, so a crate can upgrade to a new edition even if its callers or its dependencies still target older editions. Migration to a new edition can be assisted with automated tooling.{{sfn|Blandy|Orendorff|Tindall|2021|pp=176\u2013177}}\n\n"}, {"title": " IDE support ", "content": "The most popular [[Language Server Protocol|language server]] for Rust is ''Rust Analyzer'', which officially replaced the original language server, ''RLS'', in July 2022.<ref>{{Cite web |first=Tim |last=Anderson |date=2022-07-05 |title=Rust team releases 1.62, sets end date for deprecated language server |url=https://devclass.com/2022/07/05/rust-team-releases-1-62-sets-end-date-for-deprecated-language-server/ |access-date=2022-07-14 |website=DEVCLASS |language=en-GB}}</ref> Rust Analyzer provides [[Integrated development environment|IDE]]s and [[text editor]]s with information about a Rust project; basic features including [[autocompletion]], and the display of compilation errors while editing.{{sfn|Klabnik|Nichols|2023|p=623}}\n\n"}, {"title": " Performance ", "content": "In general, Rust's memory safety guarantees do not impose a runtime overhead.{{sfn|McNamara|2021|p=11}} A notable exception is [[Array (data structure)|array indexing]] which is checked at runtime, though this often does not impact performance.<ref>{{Cite journal |last1=Popescu |first1=Natalie |last2=Xu |first2=Ziyang |last3=Apostolakis |first3=Sotiris |last4=August |first4=David I. |last5=Levy |first5=Amit |date=2021-10-15 |title=Safer at any speed: automatic context-aware safety enhancement for Rust |url=https://doi.org/10.1145/3485480 |journal=Proceedings of the ACM on Programming Languages |volume=5 |issue=OOPSLA | quote=\"We observe a large variance in the overheads of checked indexing: 23.6% of benchmarks do report significant performance hits from checked indexing, but 64.5% report little-to-no impact and, surprisingly, 11.8% report improved performance ... Ultimately, while unchecked indexing can improve performance, most of the time it does not.\" |quote-page=5 |at=Section 2 |doi=10.1145/3485480|s2cid=238212612|doi-access=free }}</ref> Since it does not perform garbage collection, Rust is often faster than other memory-safe languages.<ref>{{Cite web |last=Anderson |first=Tim |title=Can Rust save the planet? Why, and why not |url=https://www.theregister.com/2021/11/30/aws_reinvent_rust/ |access-date=2022-07-11 |website=The Register |language=en}}</ref><ref>{{Cite book |last1=Balasubramanian |first1=Abhiram |last2=Baranowski |first2=Marek S. |last3=Burtsev |first3=Anton |last4=Panda |first4=Aurojit |last5=Rakamari\u0107 |first5=Zvonimir |last6=Ryzhyk |first6=Leonid |title=Proceedings of the 16th Workshop on Hot Topics in Operating Systems |chapter=System Programming in Rust |date=2017-05-07 |chapter-url=https://dl.acm.org/doi/10.1145/3102980.3103006 |language=en |location=Whistler BC Canada |publisher=ACM |pages=156\u2013161 |doi=10.1145/3102980.3103006 |isbn=978-1-4503-5068-6|s2cid=24100599 }}</ref><ref>{{Cite web |last=Yegulalp |first=Serdar |date=2021-10-06 |title=What is the Rust language? Safe, fast, and easy software development |url=https://www.infoworld.com/article/3218074/what-is-rust-safe-fast-and-easy-software-development.html |access-date=2022-06-25 |website=InfoWorld |language=en}}</ref>\n\nRust provides two \"modes\": safe and unsafe. Safe mode is the \"normal\" one, in which most Rust is written. In unsafe mode, the developer is responsible for the code's memory safety, which is useful for cases where the compiler is too restrictive.<ref>{{Cite web |last=Wr\u00f3bel |first=Krzysztof |date=April 11, 2022 |title=Rust projects \u2013 why large IT companies use Rust? |url=https://codilime.com/blog/rust-projects-why-large-it-companies-use-rust/ |url-status=live |archive-url=https://web.archive.org/web/20221227212821/https://codilime.com/blog/rust-projects-why-large-it-companies-use-rust/ |archive-date=2022-12-27}}</ref>\n\nMany of Rust's features are so-called ''zero-cost abstractions'', meaning they are optimized away at compile time and incur no runtime penalty.{{sfn|McNamara|2021|p=19, 27}} The ownership and borrowing system permits [[zero-copy]] implementations for some performance-sensitive tasks, such as [[parsing]].<ref>{{Cite book |last=Couprie |first=Geoffroy |title=2015 IEEE Security and Privacy Workshops |chapter=Nom, A Byte oriented, streaming, Zero copy, Parser Combinators Library in Rust |date=2015 |chapter-url=https://ieeexplore.ieee.org/document/7163218 |pages=142\u2013148 |doi=10.1109/SPW.2015.31|isbn=978-1-4799-9933-0 |s2cid=16608844 }}</ref> Static dispatch is used by default to eliminate [[method call]]s, with the exception of methods called on dynamic trait objects.{{sfn|McNamara|2021|p=20}} The compiler also uses [[inline expansion]] to eliminate [[function call]]s and statically-dispatched method invocations.<ref>{{Cite web |title=Code generation \u2013 The Rust Reference |url=https://doc.rust-lang.org/reference/attributes/codegen.html |access-date=2022-10-09 |website=doc.rust-lang.org}}</ref>\n\nSince Rust utilizes [[LLVM]], any performance improvements in LLVM also carry over to Rust.<ref name=\"how-fast-is-rust\">{{cite web |url=https://doc.rust-lang.org/1.0.0/complement-lang-faq.html#how-fast-is-rust? |title=How Fast Is Rust? |website=The Rust Programming Language FAQ |access-date=11 April 2019 |archive-date=28 October 2020 |archive-url=https://web.archive.org/web/20201028102013/https://doc.rust-lang.org/1.0.0/complement-lang-faq.html#how-fast-is-rust? |url-status=live}}</ref> Unlike C and C++, Rust allows for reordering struct and enum elements<ref>{{Cite book |url=https://dlnext.acm.org/doi/abs/10.1145/3445814.3446724 |access-date=2022-07-12 |year=2021 |language=en |doi=10.1145/3445814.3446724|quote=... While some compilers (e.g., Rust) support structure reordering [82], C & C++ compilers are forbidden to reorder data structures (e.g., struct or class) [74] ...|last1=Farshin |first1=Alireza |last2=Barbette |first2=Tom |last3=Roozbeh |first3=Amir |last4=Maguire Jr |first4=Gerald Q. |last5=Kosti\u0107 |first5=Dejan |title=Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems |chapter=PacketMill: Toward per-Core 100-GBPS networking |pages=1\u201317 |isbn=9781450383172 |s2cid=231949599}}</ref> to reduce the sizes of structures in memory, for better memory alignment, and to improve [[CPU cache|cache]] access efficiency.<ref>{{Cite web |title=Type layout |url=https://doc.rust-lang.org/reference/type-layout.html |access-date=2022-07-14 |website=The Rust Reference}}</ref>\n\n"}, {"title": " Adoption ", "content": "{{See also|Category:Rust (programming language) software}}\n<!--\nIMPORTANT:\nPlease add entries only with independent published sources, e.g., news articles, not GitHub projects with no secondary source(s). For specific guidelines, see: Wikipedia:Identifying reliable sources\n-->\n[[File:Home page servo v0.01.png|thumb|right|Early homepage of Mozilla's Servo browser engine]]\nRust has been used in software across different domains. Rust was initially funded by Mozilla as part of developing Servo, an experimental [[parallel computing|parallel]] browser engine, in collaboration with [[Samsung]].<ref>{{cite news|last=Lardinois|first=Frederic|date=2015-04-03|title=Mozilla And Samsung Team Up To Develop Servo, Mozilla's Next-Gen Browser Engine For Multicore Processors|work=TechCrunch|url=https://techcrunch.com/2013/04/03/mozilla-and-samsung-collaborate-on-servo-mozillas-next-gen-browser-engine-for-tomorrows-multicore-processors/|access-date=2017-06-25|archive-date=2016-09-10|archive-url=https://web.archive.org/web/20160910211537/https://techcrunch.com/2013/04/03/mozilla-and-samsung-collaborate-on-servo-mozillas-next-gen-browser-engine-for-tomorrows-multicore-processors/|url-status=live}}</ref> Components from the Servo engine were later incorporated in the [[Gecko (software)|Gecko]] browser engine underlying Firefox.<ref>{{Cite web |last=Keizer |first=Gregg |date=2016-10-31 |title=Mozilla plans to rejuvenate Firefox in 2017 |url=https://www.computerworld.com/article/3137050/mozilla-plans-to-rejuvenate-firefox-in-2017.html |access-date=2023-05-13 |website=Computerworld |language=en}}</ref> In January 2023, Google ([[Alphabet Inc.|Alphabet]]) announced support for third party Rust libraries in [[Chromium (web browser)|Chromium]] and consequently in the [[ChromeOS]] code base.<ref>{{Cite web |title=Supporting the Use of Rust in the Chromium Project |url=https://security.googleblog.com/2023/01/supporting-use-of-rust-in-chromium.html |access-date=2023-11-12 |website=Google Online Security Blog |language=en}}</ref>\n\nRust is used in several [[Frontend and backend|backend]] software projects of large [[web service]]s. [[OpenDNS]], a [[Domain Name System|DNS]] resolution service owned by [[Cisco]], uses Rust internally.<ref>{{Cite web |last=Shankland |first=Stephen |date=2016-07-12 |title=Firefox will get overhaul in bid to get you interested again |url=https://www.cnet.com/tech/services-and-software/firefox-mozilla-gets-overhaul-in-a-bid-to-get-you-interested-again/ |access-date=2022-07-14 |publisher=CNET |language=en}}</ref><ref>{{Cite web |author=Security Research Team |date=2013-10-04 |title=ZeroMQ: Helping us Block Malicious Domains in Real Time |url=https://umbrella.cisco.com/blog/zeromq-helping-us-block-malicious-domains |access-date=2023-05-13 |website=Cisco Umbrella |language=en-US}}</ref> Amazon Web Services began developing projects in Rust as early as 2017,<ref name=\":2\">{{Cite web|date=2021-03-03|title=How our AWS Rust team will contribute to Rust's future successes|url=https://aws.amazon.com/blogs/opensource/how-our-aws-rust-team-will-contribute-to-rusts-future-successes/|access-date=2022-01-02|website=Amazon Web Services|language=en-US|archive-date=January 2, 2022|archive-url=https://web.archive.org/web/20220102233211/https://aws.amazon.com/blogs/opensource/how-our-aws-rust-team-will-contribute-to-rusts-future-successes/|url-status=live}}</ref> including [[Firecracker (software)|Firecracker]], a virtualization solution;<ref>{{Cite web|date=2018-11-26|title=Firecracker \u2013 Lightweight Virtualization for Serverless Computing|url=https://aws.amazon.com/blogs/aws/firecracker-lightweight-virtualization-for-serverless-computing/|access-date=2022-01-02|website=Amazon Web Services|language=en-US|archive-date=December 8, 2021|archive-url=https://web.archive.org/web/20211208100629/https://aws.amazon.com/blogs/aws/firecracker-lightweight-virtualization-for-serverless-computing/|url-status=live}}</ref> Bottlerocket, a [[Linux distribution]] and [[Containerization (computing)|containerization]] solution;<ref>{{Cite web |date=2020-08-31 |title=Announcing the General Availability of Bottlerocket, an open source Linux distribution built to run containers |url=https://aws.amazon.com/blogs/opensource/announcing-the-general-availability-of-bottlerocket-an-open-source-linux-distribution-purpose-built-to-run-containers/ |url-status=live |archive-url=https://web.archive.org/web/20220102233213/https://aws.amazon.com/blogs/opensource/announcing-the-general-availability-of-bottlerocket-an-open-source-linux-distribution-purpose-built-to-run-containers/ |archive-date=January 2, 2022 |access-date=2022-01-02 |website=Amazon Web Services |language=en-US}}</ref> and [[Tokio (software)|Tokio]], an asynchronous networking stack.<ref>{{Cite web |date=2020-11-24 |title=Why AWS loves Rust, and how we'd like to help |url=https://aws.amazon.com/blogs/opensource/why-aws-loves-rust-and-how-wed-like-to-help/ |access-date=2022-04-21 |website=Amazon Web Services |language=en-US |archive-date=December 3, 2020 |archive-url=https://web.archive.org/web/20201203170127/https://aws.amazon.com/blogs/opensource/why-aws-loves-rust-and-how-wed-like-to-help/ |url-status=live}}</ref> [[Microsoft Azure]] IoT Edge, a platform used to run Azure services on [[Internet of things|IoT]] devices, has components implemented in Rust.<ref>{{Cite web|url=https://www.theregister.co.uk/2018/06/27/microsofts_next_cloud_trick_kicking_things_out_of_the_cloud_to_azure_iot_edge/|title=Microsoft's next trick? Kicking things out of the cloud to Azure IoT Edge|last=Nichols|first=Shaun|date=27 June 2018|website=The Register|language=en|access-date=2019-09-27|archive-date=2019-09-27|archive-url=https://web.archive.org/web/20190927092433/https://www.theregister.co.uk/2018/06/27/microsofts_next_cloud_trick_kicking_things_out_of_the_cloud_to_azure_iot_edge/|url-status=live}}</ref> Microsoft also uses Rust to run containerized modules with [[WebAssembly]] and [[Kubernetes]].<ref>{{Cite web |last=Tung |first=Liam |title=Microsoft: Why we used programming language Rust over Go for WebAssembly on Kubernetes app |url=https://www.zdnet.com/article/microsoft-why-we-used-programming-language-rust-over-go-for-webassembly-on-kubernetes-app/ |access-date=2022-04-21 |publisher=ZDNet |language=en |archive-date=April 21, 2022 |archive-url=https://web.archive.org/web/20220421043549/https://www.zdnet.com/article/microsoft-why-we-used-programming-language-rust-over-go-for-webassembly-on-kubernetes-app/ |url-status=live}}</ref> [[Cloudflare]], a company providing [[content delivery network]] services uses Rust for its [[Firewall (computing)|firewall]] pattern matching engine and the [[Pingora]] web server.<ref>{{Cite web |date=2019-03-04 |title=How we made Firewall Rules |url=http://blog.cloudflare.com/how-we-made-firewall-rules/ |access-date=2022-06-11 |website=The Cloudflare Blog |language=en}}</ref><ref>{{Cite web |date=2019-01-22 |title=Enjoy a slice of QUIC, and Rust! |url=http://blog.cloudflare.com/enjoy-a-slice-of-quic-and-rust/ |access-date=2022-06-11 |website=The Cloudflare Blog |language=en}}</ref>\n\nIn operating systems, Rust support has been added to [[Rust for Linux|Linux]]<ref>{{Cite web |first=Tim |last=Anderson |date=2021-12-07 |title=Rusty Linux kernel draws closer with new patch |url=https://www.theregister.com/2021/12/07/rusty_linux_kernel_draws_closer/ |access-date=2022-07-14 |website=The Register |language=en}}</ref><ref>{{Cite web |title=A first look at Rust in the 6.1 kernel [LWN.net] |url=https://lwn.net/Articles/910762/ |access-date=2023-11-11 |website=lwn.net}}</ref> and [[Android (operating system)|Android]].<ref name=\":1\">{{Cite web |title=Rust in the Android platform |url=https://security.googleblog.com/2021/04/rust-in-android-platform.html |access-date=2022-04-21 |website=Google Online Security Blog |language=en |archive-date=April 3, 2022 |archive-url=https://web.archive.org/web/20220403015852/https://security.googleblog.com/2021/04/rust-in-android-platform.html |url-status=live}}</ref><ref>{{Cite web |last=Amadeo |first=Ron |date=2021-04-07 |title=Google is now writing low-level Android code in Rust |url=https://arstechnica.com/gadgets/2021/04/google-is-now-writing-low-level-android-code-in-rust/ |access-date=2022-04-21 |website=Ars Technica |language=en-us |archive-date=April 8, 2021 |archive-url=https://web.archive.org/web/20210408001446/https://arstechnica.com/gadgets/2021/04/google-is-now-writing-low-level-android-code-in-rust/ |url-status=live}}</ref> [[Microsoft]] is rewriting parts of [[Windows]] in Rust.<ref>{{Cite web |last=Claburn |first=Thomas |title=Microsoft is rewriting core Windows libraries in Rust |url=https://www.theregister.com/2023/04/27/microsoft_windows_rust/ |date=2023-04-27 |access-date=2023-05-13 |website=[[The Register]] |language=en}}</ref> The r9 project aims to re-implement [[Plan 9 from Bell Labs]] in Rust.<ref>{{cite web |last1=Proven |first1=Liam |title=Small but mighty, 9Front's 'Humanbiologics' is here for the truly curious |url=https://www.theregister.com/2023/12/01/9front_humanbiologics/ |website=The Register |publisher=The Register |access-date=7 March 2024}}</ref> Rust has been used in the development of new operating systems such as [[Redox (operating system)|Redox]], a \"Unix-like\" operating system and [[microkernel]],<ref>{{cite news |last=Yegulalp |first=Serdar |title=Rust's Redox OS could show Linux a few new tricks |url=http://www.infoworld.com/article/3046100/open-source-tools/rusts-redox-os-could-show-linux-a-few-new-tricks.html |access-date=21 March 2016 |work=InfoWorld |archive-date=21 March 2016 |archive-url=https://web.archive.org/web/20160321192838/http://www.infoworld.com/article/3046100/open-source-tools/rusts-redox-os-could-show-linux-a-few-new-tricks.html |url-status=live}}</ref> Theseus, an experimental operating system with modular state management,<ref>{{Cite web |first=Tim |last=Anderson |date=2021-01-14 |title=Another Rust-y OS: Theseus joins Redox in pursuit of safer, more resilient systems |url=https://www.theregister.com/2021/01/14/rust_os_theseus/ |access-date=2022-07-14 |website=The Register |language=en}}</ref><ref>{{Cite book |last1=Boos |first1=Kevin |last2=Liyanage |first2=Namitha |last3=Ijaz |first3=Ramla |last4=Zhong |first4=Lin |date=2020 |title=Theseus: an Experiment in Operating System Structure and State Management |url=https://www.usenix.org/conference/osdi20/presentation/boos |language=en |pages=1\u201319 |isbn=978-1-939133-19-9}}</ref> and most of [[Fuchsia (operating system)|Fuchsia]].<ref name=\"rustmag-1\">{{cite web |first1=HanDong (Alex)|last1=Zhang |title=2022 Review {{!}} The adoption of Rust in Business |url=https://rustmagazine.org/issue-1/2022-review-the-adoption-of-rust-in-business/ |date=2023-01-31 |website=Rust Magazine |access-date=February 7, 2023 |language=en}}</ref> Rust is also used for command-line tools and operating system components, including [[Stratis (configuration daemon)|stratisd]], a [[file system]] manager<ref>{{cite web |url=https://www.marksei.com/fedora-29-new-features-startis/ |title=Fedora 29 new features: Startis now officially in Fedora |last=Sei |first=Mark |date=10 October 2018 |website=Marksei, Weekly sysadmin pills |access-date=2019-05-13 |archive-date=2019-04-13 |archive-url=https://web.archive.org/web/20190413075055/https://www.marksei.com/fedora-29-new-features-startis/ |url-status=live}}</ref><ref>{{Cite web |last=Proven |first=Liam |date=2022-07-12 |title=Oracle Linux 9 released, with some interesting additions |url=https://www.theregister.com/2022/07/12/oracle_linux_9/ |access-date=2022-07-14 |website=The Register |language=en}}</ref> and COSMIC, a [[desktop environment]] by [[System76]].<ref name=\"FOSSN_()\">{{cite web |last1=Patel |first1=Pratham |title=I Tried System76's New Rust-based COSMIC Desktop! |url=https://news.itsfoss.com/system76-rust-cosmic-desktop/ |website=It's FOSS News \u2013 Development Updates |date=January 14, 2022 |publisher=It's FOSS News |access-date=10 January 2023}}</ref><ref name=\"S76_(2023)\">{{cite web |title=Pop!_OS by System76 |url=https://pop.system76.com/ |website=pop.system76.com |publisher=System76, Inc. |access-date=10 January 2023 |language=en}}</ref>\n\n[[File:Ruffle.rs demo (1).png|thumb|Ruffle, a web emulator for [[Adobe Flash]] [[SWF]] files]]\n\nIn web development, the [[npm|npm package manager]] started using Rust in production in 2019.<ref>{{Cite web |last=Simone |first=Sergio De |title=NPM Adopted Rust to Remove Performance Bottlenecks |url=https://www.infoq.com/news/2019/03/rust-npm-performance/ |access-date=2023-11-20 |website=InfoQ |language=en}}</ref><ref>{{Citation |last=Lyu |first=Shing |title=Welcome to the World of Rust |date=2020 |url=https://doi.org/10.1007/978-1-4842-5599-5_1 |work=Practical Rust Projects: Building Game, Physical Computing, and Machine Learning Applications |pages=1\u20138 |editor-last=Lyu |editor-first=Shing |access-date=2023-11-29 |place=Berkeley, CA |publisher=Apress |language=en |doi=10.1007/978-1-4842-5599-5_1 |isbn=978-1-4842-5599-5}}</ref><ref>{{Citation |last=Lyu |first=Shing |title=Rust in the Web World |date=2021 |url=https://doi.org/10.1007/978-1-4842-6589-5_1 |work=Practical Rust Web Projects: Building Cloud and Web-Based Applications |pages=1\u20137 |editor-last=Lyu |editor-first=Shing |access-date=2023-11-29 |place=Berkeley, CA |publisher=Apress |language=en |doi=10.1007/978-1-4842-6589-5_1 |isbn=978-1-4842-6589-5}}</ref> [[Deno (software)|Deno]], a secure runtime for [[JavaScript]] and [[TypeScript]], is built with [[V8 (JavaScript engine)|V8]], Rust, and Tokio.<ref>{{Cite web |first=Vivian |last=Hu |date=2020-06-12 |title=Deno Is Ready for Production |url=https://www.infoq.com/news/2020/06/deno-1-ready-production/ |access-date=2022-07-14 |website=InfoQ |language=en}}</ref> Other notable adoptions in this space include [[Ruffle (software)|Ruffle]], an open-source [[SWF]] emulator,<ref>{{Cite web |last=Abrams|first=Lawrence|date=2021-02-06|title=This Flash Player emulator lets you securely play your old games|url=https://www.bleepingcomputer.com/news/software/this-flash-player-emulator-lets-you-securely-play-your-old-games/|access-date=2021-12-25|website=BleepingComputer|language=en-us}}</ref> and [[Polkadot (cryptocurrency)|Polkadot]], an open source [[blockchain]] and [[cryptocurrency]] platform.<ref>{{Cite web |last=Kharif |first=Olga |date=October 17, 2020 |title=Ethereum Blockchain Killer Goes By Unassuming Name of Polkadot |url=https://www.bloomberg.com/news/articles/2020-10-17/ethereum-blockchain-killer-goes-by-unassuming-name-of-polkadot |url-access=subscription |access-date=July 14, 2021 |publisher=Bloomberg L.P.}}</ref>\n\n[[Discord]], an [[instant messaging]] social platform uses Rust for portions of its backend, as well as client-side [[video encoding]].<ref name=\":3\">{{cite web |last=Howarth |first=Jesse |date=2020-02-04 |title=Why Discord is switching from Go to Rust |url=https://discord.com/blog/why-discord-is-switching-from-go-to-rust |url-status=live |archive-url=https://web.archive.org/web/20200630181517/https://blog.discord.com/why-discord-is-switching-from-go-to-rust-a190bbca2b1f |archive-date=2020-06-30 |access-date=2020-04-14}}</ref> In 2021, [[Dropbox]] announced their use of Rust for a screen, video, and image capturing service.<ref>{{Cite web |last=The Dropbox Capture Team |title=Why we built a custom Rust library for Capture |url=https://dropbox.tech/application/why-we-built-a-custom-rust-library-for-capture |access-date=2022-04-21 |website=Dropbox.Tech |language=en |archive-date=April 6, 2022 |archive-url=https://web.archive.org/web/20220406142301/https://dropbox.tech/application/why-we-built-a-custom-rust-library-for-capture |url-status=live}}</ref> [[Facebook]] ([[Meta Platforms|Meta]]) used Rust for Mononoke, a server for the [[Mercurial]] version control system.<ref>{{Cite web |date=2021-04-29 |title=A brief history of Rust at Facebook |url=https://engineering.fb.com/2021/04/29/developer-tools/rust/ |access-date=2022-04-21 |website=Engineering at Meta |language=en-US |archive-date=January 19, 2022 |archive-url=https://web.archive.org/web/20220119012056/https://engineering.fb.com/2021/04/29/developer-tools/rust/ |url-status=live}}</ref>\n\nIn the 2023 [[Stack Overflow]] Developer Survey, 13% of respondents had recently done extensive development in Rust.<ref name=\"SO-2023-survey\">{{Cite web |title=Stack Overflow Developer Survey 2023 |url=https://survey.stackoverflow.co/2023/ |access-date=2023-06-25 |website=Stack Overflow}}</ref> The survey also named Rust the \"most loved programming language\" every year from 2016 to 2023 (inclusive), based on the number of developers interested in continuing to work in the same language.<ref>{{Cite web |last=Claburn |first=Thomas |date=2022-06-23 |title=Linus Torvalds says Rust is coming to the Linux kernel |url=https://www.theregister.com/2022/06/23/linus_torvalds_rust_linux_kernel/ |access-date=2022-07-15 |website=The Register |language=en}}</ref>{{refn|group=note|That is, among respondents who have done \"extensive development work [with Rust] in over the past year\" (13.05%), Rust had the largest percentage who also expressed interest to \"work in [Rust] over the next year\" (84.66%).<ref name=\"SO-2023-survey\"/>}} In 2023, Rust was the 6th \"most wanted technology\", with 31% of developers not currently working in Rust expressing an interest in doing so.<ref name=\"SO-2023-survey\" />\n\n"}, {"title": " Community ", "content": "[[File:Rustacean-orig-noshadow.svg|alt=A bright orange crab icon|thumb|Some Rust users refer to themselves as Rustaceans (similar to the word [[crustacean]]) and have adopted an orange crab, Ferris, as their unofficial mascot.{{sfn|Klabnik|Nichols|2019|p=4}}<ref>{{cite web |title=Getting Started |url=https://www.rust-lang.org/learn/get-started#ferris |website=rust-lang.org |access-date=11 October 2020 |archive-date=1 November 2020 |archive-url=https://web.archive.org/web/20201101145703/https://www.rust-lang.org/learn/get-started#ferris |url-status=live}}</ref>]]\n\n=== Rust Foundation ===\n{{Infobox organization\n| name = Rust Foundation\n| logo = Rust Foundation logo.png\n| formation = {{Start date and age|2021|02|08}}\n| founders = {{unbulleted list|[[Amazon Web Services]]|[[Google]]|[[Huawei]]|[[Microsoft]]|[[Mozilla Foundation]]}}\n| type = [[Nonprofit organization]]\n| location_country = [[United States]]\n| leader_title = [[Chairperson]]\n| leader_name = Shane Miller\n| leader_title2 = [[Executive Director]]\n| leader_name2 = Rebecca Rumbul\n| website = {{URL|https://foundation.rust-lang.org}}\n}}\n\nThe '''Rust Foundation''' is a [[Nonprofit organization|non-profit]] [[membership organization]] incorporated in [[United States]], with the primary purposes of backing the technical project as a [[legal entity]] and helping to manage the trademark and infrastructure assets.<ref>{{Cite web |first=Liam |last=Tung |date=2021-02-08 |title=The Rust programming language just took a huge step forwards |url=https://www.zdnet.com/article/the-rust-programming-language-just-took-a-huge-step-forwards/ |access-date=2022-07-14 |publisher=ZDNet |language=en}}</ref><ref name=\":4\">{{Cite web |last=Brandon Vigliarolo |date=2021-02-10 |title=The Rust programming language now has its own independent foundation |url=https://www.techrepublic.com/article/the-rust-programming-language-now-has-its-own-independent-foundation/ |access-date=2022-07-14 |website=TechRepublic |language=en-US}}</ref>\n\nIt was established on February 8, 2021, with five founding corporate members (Amazon Web Services, Huawei, Google, Microsoft, and Mozilla).<ref>{{cite news|first=Paul|last=Krill|title=Rust language moves to independent foundation|url=https://www.infoworld.com/article/3606774/rust-language-moves-to-independent-foundation.html|work=[[InfoWorld]]|access-date=10 April 2021|archive-date=10 April 2021|archive-url=https://web.archive.org/web/20210410161528/https://www.infoworld.com/article/3606774/rust-language-moves-to-independent-foundation.html|url-status=live}}</ref> The foundation's board is chaired by Shane Miller.<ref>{{cite news|first=Steven J.|last=Vaughan-Nichols|date=9 April 2021|title=AWS's Shane Miller to head the newly created Rust Foundation|url=https://www.zdnet.com/article/awss-shane-miller-to-head-the-newly-created-rust-foundation/|publisher=[[ZDNet]]|access-date=10 April 2021|archive-date=10 April 2021|archive-url=https://web.archive.org/web/20210410031305/https://www.zdnet.com/article/awss-shane-miller-to-head-the-newly-created-rust-foundation/|url-status=live}}</ref> Starting in late 2021, its Executive Director and CEO is Rebecca Rumbul.<!--Q109621019--><ref>{{Cite news|url=https://www.zdnet.com/article/rust-foundation-appoints-rebecca-rumbul-as-executive-director/|title=Rust Foundation appoints Rebecca Rumbul as executive director|publisher=[[ZDNet]]|first=Steven J.|last=Vaughan-Nichols|date=17 November 2021|access-date=18 November 2021|archive-date=November 18, 2021|archive-url=https://web.archive.org/web/20211118062346/https://www.zdnet.com/article/rust-foundation-appoints-rebecca-rumbul-as-executive-director/|url-status=live}}</ref> Prior to this, Ashley Williams was interim executive director.<ref>{{Cite news|title=The Rust programming language now has its own independent foundation|url=https://www.techrepublic.com/article/the-rust-programming-language-now-has-its-own-independent-foundation/|date=February 10, 2021|access-date=2021-11-18|website=TechRepublic|language=en|archive-date=November 18, 2021|archive-url=https://web.archive.org/web/20211118143514/https://www.techrepublic.com/article/the-rust-programming-language-now-has-its-own-independent-foundation/|url-status=live}}</ref>\n\n=== Governance teams ===\nThe Rust project is composed of ''teams'' that are responsible for different subareas of the development. The compiler team develops, manages, and optimizes compiler internals; and the language team designs new language features and helps implement them. The Rust project website lists 9 top-level teams {{as of|January 2024|lc=y}}.<ref>{{Cite web |title=Governance |url=https://www.rust-lang.org/governance |access-date=2022-05-07 |website=The Rust Programming Language |language=en-US |archive-date=May 10, 2022 |archive-url=https://web.archive.org/web/20220510225505/https://www.rust-lang.org/governance |url-status=live}}</ref> Representatives among teams form the Leadership council, which oversees the Rust project as a whole.<ref>{{Cite web |title=Introducing the Rust Leadership Council |url=https://blog.rust-lang.org/2023/06/20/introducing-leadership-council.html |access-date=2024-01-12 |website=Rust Blog |language=en}}</ref><!--<ref>{{Cite web |first=Tim |last=Anderson |date=2021-11-23 |title=Entire Rust moderation team resigns |url=https://www.theregister.com/2021/11/23/rust_moderation_team_quits/ |access-date=2024-01-12 |website=The Register |language=en}}</ref>-->\n\n"}, {"title": " Rust Foundation ", "content": "{{Infobox organization\n| name = Rust Foundation\n| logo = Rust Foundation logo.png\n| formation = {{Start date and age|2021|02|08}}\n| founders = {{unbulleted list|[[Amazon Web Services]]|[[Google]]|[[Huawei]]|[[Microsoft]]|[[Mozilla Foundation]]}}\n| type = [[Nonprofit organization]]\n| location_country = [[United States]]\n| leader_title = [[Chairperson]]\n| leader_name = Shane Miller\n| leader_title2 = [[Executive Director]]\n| leader_name2 = Rebecca Rumbul\n| website = {{URL|https://foundation.rust-lang.org}}\n}}\n\nThe '''Rust Foundation''' is a [[Nonprofit organization|non-profit]] [[membership organization]] incorporated in [[United States]], with the primary purposes of backing the technical project as a [[legal entity]] and helping to manage the trademark and infrastructure assets.<ref>{{Cite web |first=Liam |last=Tung |date=2021-02-08 |title=The Rust programming language just took a huge step forwards |url=https://www.zdnet.com/article/the-rust-programming-language-just-took-a-huge-step-forwards/ |access-date=2022-07-14 |publisher=ZDNet |language=en}}</ref><ref name=\":4\">{{Cite web |last=Brandon Vigliarolo |date=2021-02-10 |title=The Rust programming language now has its own independent foundation |url=https://www.techrepublic.com/article/the-rust-programming-language-now-has-its-own-independent-foundation/ |access-date=2022-07-14 |website=TechRepublic |language=en-US}}</ref>\n\nIt was established on February 8, 2021, with five founding corporate members (Amazon Web Services, Huawei, Google, Microsoft, and Mozilla).<ref>{{cite news|first=Paul|last=Krill|title=Rust language moves to independent foundation|url=https://www.infoworld.com/article/3606774/rust-language-moves-to-independent-foundation.html|work=[[InfoWorld]]|access-date=10 April 2021|archive-date=10 April 2021|archive-url=https://web.archive.org/web/20210410161528/https://www.infoworld.com/article/3606774/rust-language-moves-to-independent-foundation.html|url-status=live}}</ref> The foundation's board is chaired by Shane Miller.<ref>{{cite news|first=Steven J.|last=Vaughan-Nichols|date=9 April 2021|title=AWS's Shane Miller to head the newly created Rust Foundation|url=https://www.zdnet.com/article/awss-shane-miller-to-head-the-newly-created-rust-foundation/|publisher=[[ZDNet]]|access-date=10 April 2021|archive-date=10 April 2021|archive-url=https://web.archive.org/web/20210410031305/https://www.zdnet.com/article/awss-shane-miller-to-head-the-newly-created-rust-foundation/|url-status=live}}</ref> Starting in late 2021, its Executive Director and CEO is Rebecca Rumbul.<!--Q109621019--><ref>{{Cite news|url=https://www.zdnet.com/article/rust-foundation-appoints-rebecca-rumbul-as-executive-director/|title=Rust Foundation appoints Rebecca Rumbul as executive director|publisher=[[ZDNet]]|first=Steven J.|last=Vaughan-Nichols|date=17 November 2021|access-date=18 November 2021|archive-date=November 18, 2021|archive-url=https://web.archive.org/web/20211118062346/https://www.zdnet.com/article/rust-foundation-appoints-rebecca-rumbul-as-executive-director/|url-status=live}}</ref> Prior to this, Ashley Williams was interim executive director.<ref>{{Cite news|title=The Rust programming language now has its own independent foundation|url=https://www.techrepublic.com/article/the-rust-programming-language-now-has-its-own-independent-foundation/|date=February 10, 2021|access-date=2021-11-18|website=TechRepublic|language=en|archive-date=November 18, 2021|archive-url=https://web.archive.org/web/20211118143514/https://www.techrepublic.com/article/the-rust-programming-language-now-has-its-own-independent-foundation/|url-status=live}}</ref>\n\n"}, {"title": " Governance teams ", "content": "The Rust project is composed of ''teams'' that are responsible for different subareas of the development. The compiler team develops, manages, and optimizes compiler internals; and the language team designs new language features and helps implement them. The Rust project website lists 9 top-level teams {{as of|January 2024|lc=y}}.<ref>{{Cite web |title=Governance |url=https://www.rust-lang.org/governance |access-date=2022-05-07 |website=The Rust Programming Language |language=en-US |archive-date=May 10, 2022 |archive-url=https://web.archive.org/web/20220510225505/https://www.rust-lang.org/governance |url-status=live}}</ref> Representatives among teams form the Leadership council, which oversees the Rust project as a whole.<ref>{{Cite web |title=Introducing the Rust Leadership Council |url=https://blog.rust-lang.org/2023/06/20/introducing-leadership-council.html |access-date=2024-01-12 |website=Rust Blog |language=en}}</ref><!--<ref>{{Cite web |first=Tim |last=Anderson |date=2021-11-23 |title=Entire Rust moderation team resigns |url=https://www.theregister.com/2021/11/23/rust_moderation_team_quits/ |access-date=2024-01-12 |website=The Register |language=en}}</ref>-->\n\n"}, {"title": " See also ", "content": "* [[Comparison of programming languages]]\n* [[History of programming languages]]\n* [[List of programming languages]]\n* [[List of programming languages by type]]\n\n"}, {"title": " Notes ", "content": "{{Reflist|group=note}}\n\n"}, {"title": " References ", "content": "=== Book sources ===\n{{refbegin}}\n* {{Cite book |last=Gjengset |first=Jon |url=https://www.worldcat.org/oclc/1277511986 |title=Rust for Rustaceans |date=2021 |publisher=No Starch Press |isbn=9781718501850 |edition=1st |oclc=1277511986 |language=en}}\n* {{Cite book|last1=Klabnik|first1=Steve|url=https://books.google.com/books?id=0Vv6DwAAQBAJ|title=The Rust Programming Language (Covers Rust 2018)|last2=Nichols|first2=Carol|date=2019-08-12|publisher=No Starch Press|isbn=978-1-7185-0044-0|language=en}}\n* {{Cite book|last1=Blandy|first1=Jim|last2=Orendorff|first2=Jason|last3=Tindall|first3=Leonora F. S.|url=https://www.worldcat.org/oclc/1289839504|date=2021|edition=2nd|title=Programming Rust: Fast, Safe Systems Development|publisher=O'Reilly Media|isbn=978-1-4920-5254-8 |language=en|oclc=1289839504}}\n* {{Cite book|last1=McNamara|first1=Tim|url=https://www.worldcat.org/oclc/1153044639|title=Rust in Action|oclc=1153044639|date=2021|publisher=Manning Publications|isbn=978-1-6172-9455-6|language=en}}\n* {{Cite book |last1=Klabnik |first1=Steve |last2=Nichols |first2=Carol |url=https://www.worldcat.org/oclc/1363816350 |title=The Rust programming language |date=2023 |publisher=No Starch Press |isbn=978-1-7185-0310-6 |edition=2nd |oclc=1363816350}}\n{{refend}}\n\n=== Others ===\n{{reflist|refs=\n<ref name=\"legal\">{{cite web |url=https://www.rust-lang.org/policies/licenses |title=Rust Legal Policies |access-date=2018-04-03 |website=Rust-lang.org |archive-date=2018-04-04 |archive-url=https://web.archive.org/web/20180404073350/https://www.rust-lang.org/en-US/legal.html |url-status=live}}</ref>\n<ref name=\"influences\">{{cite web |title=Influences - The Rust Reference |url=https://doc.rust-lang.org/reference/influences.html |website=The Rust Reference |access-date=December 31, 2023 |archive-date=November 26, 2023 |archive-url=https://web.archive.org/web/20231126231034/https://doc.rust-lang.org/reference/influences.html |url-status=live}}</ref>\n<ref name=\"Jaloyan\">{{Cite arXiv|last=Jaloyan |first=Georges-Axel |date=19 October 2017 |title=Safe Pointers in SPARK 2014 |class=cs.PL |eprint=1710.07047}}</ref>\n<ref name=\"Lattner\">{{cite web |url=http://nondot.org/sabre/ |title=Chris Lattner's Homepage |last=Lattner |first=Chris |date=<!--Undated--> |website=Nondot.org |access-date=2019-05-14 |archive-date=2018-12-25 |archive-url=https://web.archive.org/web/20181225175312/http://nondot.org/sabre/ |url-status=live}}</ref>\n<ref name=\"Project Verona\">{{cite web|url=https://www.zdnet.com/article/microsoft-opens-up-rust-inspired-project-verona-programming-language-on-github/|title=Microsoft opens up Rust-inspired Project Verona programming language on GitHub|publisher=[[ZDNet]]|access-date=2020-01-17|archive-date=2020-01-17|archive-url=https://web.archive.org/web/20200117143852/https://www.zdnet.com/article/microsoft-opens-up-rust-inspired-project-verona-programming-language-on-github/|url-status=live}}</ref>\n}}\n\n"}, {"title": " Book sources ", "content": "{{refbegin}}\n* {{Cite book |last=Gjengset |first=Jon |url=https://www.worldcat.org/oclc/1277511986 |title=Rust for Rustaceans |date=2021 |publisher=No Starch Press |isbn=9781718501850 |edition=1st |oclc=1277511986 |language=en}}\n* {{Cite book|last1=Klabnik|first1=Steve|url=https://books.google.com/books?id=0Vv6DwAAQBAJ|title=The Rust Programming Language (Covers Rust 2018)|last2=Nichols|first2=Carol|date=2019-08-12|publisher=No Starch Press|isbn=978-1-7185-0044-0|language=en}}\n* {{Cite book|last1=Blandy|first1=Jim|last2=Orendorff|first2=Jason|last3=Tindall|first3=Leonora F. S.|url=https://www.worldcat.org/oclc/1289839504|date=2021|edition=2nd|title=Programming Rust: Fast, Safe Systems Development|publisher=O'Reilly Media|isbn=978-1-4920-5254-8 |language=en|oclc=1289839504}}\n* {{Cite book|last1=McNamara|first1=Tim|url=https://www.worldcat.org/oclc/1153044639|title=Rust in Action|oclc=1153044639|date=2021|publisher=Manning Publications|isbn=978-1-6172-9455-6|language=en}}\n* {{Cite book |last1=Klabnik |first1=Steve |last2=Nichols |first2=Carol |url=https://www.worldcat.org/oclc/1363816350 |title=The Rust programming language |date=2023 |publisher=No Starch Press |isbn=978-1-7185-0310-6 |edition=2nd |oclc=1363816350}}\n{{refend}}\n\n"}, {"title": " Others ", "content": "{{reflist|refs=\n<ref name=\"legal\">{{cite web |url=https://www.rust-lang.org/policies/licenses |title=Rust Legal Policies |access-date=2018-04-03 |website=Rust-lang.org |archive-date=2018-04-04 |archive-url=https://web.archive.org/web/20180404073350/https://www.rust-lang.org/en-US/legal.html |url-status=live}}</ref>\n<ref name=\"influences\">{{cite web |title=Influences - The Rust Reference |url=https://doc.rust-lang.org/reference/influences.html |website=The Rust Reference |access-date=December 31, 2023 |archive-date=November 26, 2023 |archive-url=https://web.archive.org/web/20231126231034/https://doc.rust-lang.org/reference/influences.html |url-status=live}}</ref>\n<ref name=\"Jaloyan\">{{Cite arXiv|last=Jaloyan |first=Georges-Axel |date=19 October 2017 |title=Safe Pointers in SPARK 2014 |class=cs.PL |eprint=1710.07047}}</ref>\n<ref name=\"Lattner\">{{cite web |url=http://nondot.org/sabre/ |title=Chris Lattner's Homepage |last=Lattner |first=Chris |date=<!--Undated--> |website=Nondot.org |access-date=2019-05-14 |archive-date=2018-12-25 |archive-url=https://web.archive.org/web/20181225175312/http://nondot.org/sabre/ |url-status=live}}</ref>\n<ref name=\"Project Verona\">{{cite web|url=https://www.zdnet.com/article/microsoft-opens-up-rust-inspired-project-verona-programming-language-on-github/|title=Microsoft opens up Rust-inspired Project Verona programming language on GitHub|publisher=[[ZDNet]]|access-date=2020-01-17|archive-date=2020-01-17|archive-url=https://web.archive.org/web/20200117143852/https://www.zdnet.com/article/microsoft-opens-up-rust-inspired-project-verona-programming-language-on-github/|url-status=live}}</ref>\n}}\n\n"}, {"title": "Further reading", "content": "* {{Cite book|last1=Blandy|first1=Jim|last2=Orendorff|first2=Jason|last3=Tindall|first3=Leonora F. S.|date=2021-07-06|title=Programming Rust: Fast, Safe Systems Development|publisher=O'Reilly Media|isbn=978-1-4920-5259-3 |language=en|ref=none}}\n\n"}, {"title": " External links ", "content": "{{Sister project links|display=Rust |wikt=no |commons=Category:Rust (programming language) |b=no |n=no |q=no |s=no |v=Rust |voy=no |species=no |d=Q575650}}\n* {{Official website}}\n\n{{Programming languages}}\n{{Mozilla}}\n{{Portal bar|Computer programming}}\n{{Authority control}}\n\n[[Category:Rust (programming language)| ]]\n[[Category:Articles with example Rust code]]\n[[Category:Concurrent programming languages]]\n[[Category:Free compilers and interpreters]]\n[[Category:Free software projects]]\n[[Category:Functional languages]]\n[[Category:High-level programming languages]]\n[[Category:Mozilla]]\n[[Category:Multi-paradigm programming languages]]\n[[Category:Pattern matching programming languages]]\n[[Category:Procedural programming languages]]\n[[Category:Programming languages created in 2015]]\n[[Category:Software using the Apache license]]\n[[Category:Software using the MIT license]]\n[[Category:Statically typed programming languages]]\n[[Category:Systems programming languages]]"}]}